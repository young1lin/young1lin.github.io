[{"content":"又是一波风口来了 又开始了，不懂行的，只会高谈阔论放没有味道屁的，又开始了，“李一舟” 们又复活了。开始利用大家的焦虑，开始卖些没有营养的课，新一波的收割又来了。那些高谈阔论的砖家疯狂啃噬着这新鲜的养料。\nDeepSeek 这 xx 条指令帮你更好掌握 xx 创始人梁文峰 xx 量化投资 xx 我用 DeepSeek 赚到了 xx xx 大学 DeepSeek xx xx 宣布接入 DeepSeek AI 破局！ 还有很多，就不列举了，点进去全都是依托谢特，毫无营养的内容，基本都是割韭菜，卖低质量课的。没有调查，就没有发言权，我明知道那些点进去是垃圾内容，我还是强忍着恶心，本着应该调查再发表观点的心态去看了，确实都是一坨，根本不用点进去看。到最后基本都是加群卖课，准备开始割你，这些人想钱想疯了。\n一月份的时候 CNBC、The Daily Show、各个行业的博主都来了，人人都可以评价 DeepSeek，都可以上来说两句，在自己行业的视角。这很正常，没问题，但是就像盲人摸象，只知道部分事实，那不是事实。《事实》里面，人们只会报独特的消息，所有的媒体才不会浪费时间去编造那些不符合我们基本本能的故事。\n与其听一些“砖家”高谈阔论，说一些没有味的屁话，不如自己真正找到一手或者近一手的资料，去学点真东西。\n背景介绍 这里只做大语言模型和扩散模型相关的内容推荐，更深层次的机器学习，神经网络，深度学习里面种种细节其实也不用完全掌握。只要会用就行了，很多底层细节是不需要知道的。\n你不需要有高性能的 GPU，也不需要有足够的编程知识，更不需要了解 TCP/IP，不需要了解 TCP 粘包，TCP Sequence，就是个简单的 HTTP 请求，也不需要了解 OAuth2 协议，甚至也不需要充钱，只需要注册 DeepSeek 或者 Kimi 账号，使用它们的平台生成一个 API Key 放到 Authorization: Bearer 后面即可，最后面有演示内容。本质上就是根据你输入的内容，结合大模型“学习”过的知识，给你回答。\n幸存者偏差 可能或多或少看到谁谁谁用 Cursor，毫无编程经验，就写出一个 xx APP，赚到了钱。对，没错，这些是真的，但是只是部分事实。不是所有人都可以这样，并且好的软件，它是要维护的，是要人来参与的。就算你用 Cursor 写出了这样的 APP，但是它是要不断迭代的，要重构，要写良好的 AAA 单元测试。这些，Cursor 还差一点，并且我在工作中很少见到人写测试代码，但是如果你真的编程到了一定程度，你就会发现，写好规划文档占三分之一时间、单元测试和集成测试等其他测试占用一半时间，测试才是软件开发最重要的事情，开发其实只是占用六分之一的时间。\n并且，如果不懂 Git，不了解 GitLab、Github，毫无软件开发经验，用 Cursor 写出来的东西，不会做版本控制，也不知道提交到远端仓库，本地电脑坏了，或者其他意外情况，代码全丢了，那就全完了。就算了解 Git，也不了解软件开发推崇的敏捷开发，项目管理，版本变更兼容，需求和实现需要定期同步等等的坑，光有想法和结构化思维，是做不出来可迭代的，优秀的产品。没有人能一次性写出完美的代码，就算是 Linux Kernnel 的代码，也有大约 20% 的提交都是重构的代码，重构非常重要。重构的前提，是编写良好的单元测试。\n教程 按照推荐顺序排序，而且英文教程质量很高，并且免费，只不过访问需要一点点手段。英文不是问题，语言只是个工具，也可以用翻译插件来看。技术类的文章、教程英文单词没那么多，不会用到那种平时根本用不到的修饰词来写教程，例如 quaint，sumptuous。技术类的教程，单词是有限的，内容是直接了当的，多看多记多听就会了。\nLLM 教程 第一个和最后一个是收费的，其他的都是免费的，如果不想付费，也可以看免费的内容。你需要先了解什么是大语言模型，再利用大语言模型构建 AI Agent。第五本书，虽然并不完美，但是写得早，尽量把 Agent 相关的内容简单介绍了下，也有可运行的示例代码。如果不想做相关的 Agent 开发，也不想付费，看第三个，和提示词教程的第一个视频就行了。还有就是链接虽然是油管等平台的，但是国内 B 站都会有人搬运，并且翻译的视频，直接搜对应的标题即可。\nAI 大模型之美 从零开始学习大语言模型（一） Deep Dive into LLMs Like GPT How I use LLMs AI Agent 课程 —— HuggingFace 大模型应用开发 LLM Powered Autonomous Agents LangChain实战课 3Blue1Brown 神经网络 AI 大模型之美 由于微信公众号不能直接访问外链，扫码购买课程也是可以的，虽然是 2023 年的课程，但是还是可以作为入门的简单课程。即使有几万人购买，但是实际上看完的人很少，如果你真的看完了课程，甚至在 Colab 上执行了里面的一些 Jupyter 里的代码，收获也是会有的。你学完后，会有个证书，表示你是第几位学完的人，你会发现能坚持看完的人很少，因为大部分人没有足够的自驱力或者养成阅读的习惯，坚持不下去的人大有人在。没学完也不用在意，这只是额外的，轻松的，好玩的知识。\n当然，有很多内容其实已经过时了，例如一些示例代码，如果用最新的 OpenAI 的库会报错，Paddle Speech 也不建议用了，现在有更多更好的 TTS （Text To Sound）模型。\n也可以去 课程减减 公众号，加好友，获得返现的钱，这样课程价格会更便宜。\n从零开始学大语言模型（一） 即使只有一期视频，但是我还是很推荐他的视频，也可以看吴恩达的机器学习课。\nDeep Dive into LLMs Like GPT 前 OpenAI 研究科学家，前特斯拉 AI 总监，Andrej Karpathy，人工智能领域的知名专家。制作了一个三个半小时的视频，从头和你说，计算机是怎么识别自然语言的，什么是 Token，为什么要分词。训练的数据从哪来，什么是 pre-training 阶段，什么是 post-training 阶段。监督微调到强化学习，RLHF，DeepSeek-R1 等等。\n赛博菩萨，和李沐大神一样。\nHow I use LLMs 和上面是同一个人，简单明了介绍了上下文窗口的概念，并且也买了各个 AI 产品会员，体验高级版的功能，尤其是 Grok3 的 Deep Search 还可以，Grok3 的其他就不行了，免费用户也可以一天用几次。这个用来搜资料，整理信息，很有帮助。当然，如果你付得起 200 美元一个月，用 ChatGPT Pro 也是可以的。补充一点，问的问题，最好是英文容易找到的，如果是仅在中文语境下才有的，例如微信小程序为什么抓不到包这种问题，得到的回复会很一般。这种情况，用 DeepSeek R1 会更好一点。\n单一职责：一个对话窗口只问一种问题。\n文生图：借用各个厂商提供的 Chatbot 来文生图。这个自己本地用 Stable Difusssion 或者 Flux 也是可以的，只不过要专门学这块的提示词怎么写，如果想控制细节部分变动，还需要学 ComfyUI。具体的，可以看扩散模型的教程那块。\nDeepSearch：Grok3 的这个可以和 ChatGPT Pro（200 美元/月）的 DeepResearch 媲美，能帮你调研很多内容，帮你筛选出合适的内容。\nAI Agent 课程 —— HuggingFace 很好的 Agent 课程，还在更新，简单介绍了大语言模型，大语言模型的特殊 Token，开始和结束的 Token，ReAct 是什么，Tools 是什么，每学完一个概念，都可以做相应的题目来巩固知识。并且还能手把手教你如何用代码构建一个简单的多步骤执行 Agent，查询天气，询问当前时间，搜索新闻等等。最后一个单个 Agent 的演示，就是从这里来的。\n还有 NLP 等其他课程链接，让你一次学个够，免费，完全免费。NLP 自然语言处理课程，Agents 课程，深度强化学习课程，往下翻还有 Difussion Model 扩散模型的内容。 https://huggingface.co/learn\nHuggingFace 在国内 B 站也有官方账号，也上过央视，中文名叫抱抱脸，机器学习开源的相关内容这里都有，不管是数据集，各个模型，免费的各种课程等等，全都有。国内与之相对的，就是阿里的魔搭社区 Model Scope，后者只能说一般，国内大家都忙着挣钱，没有回报的东西没人愿意做。\nHuggingFace 国内正常的网络途径是访问不到的，被墙了。我也不清楚为什么纯技术的网站会被墙，需要你上点手段才能访问，这也递给了国内的某些人收割韭菜的镰刀，但是国内所有的大模型厂商，如果开源，都会往上面放自己训练好的模型，包括 DeepSeek。\n大模型应用开发 相较于 Huggingface 的 Agent Course，书讲的内容更广，不会让你仅局限于 ReAct 这种模式，即使书里的概念内容基本就是将 LLM Powered Autonomous Agents 和其他的论文翻译了一遍。\n3Blue1Brown 神经网络 3Blue1Brown 很知名的博主，漫士沉思录（自称是来自清华的博士生）也用 3Blue1Brown 视频里面的内容，但没有说明来源。\n这里的视频并没有和你从波士顿房价的预测开始讲，没有说线性回归这些简单的概念。而是直接开始讲更深层次的深度学习，所以这里只是做推荐，拓展一些视野。\n动手学深度学习 李宏毅机器学习 扩散模型教程（文生图） 扩散模型就是最火的文生图，文生视频的模型，在 LLM 教程第一个专栏里也有简单介绍\nHuggingFace Difussion Course AI 绘画核心技术与实战 这块我也就本地玩了下 StableDifussion 实际用的不多。\n提示词教程 吴恩达 x OpenAI Prompt课程 Anthropic System Prompts 月之暗面提示词最佳实践 Prompt Engineering Awsome ChatGPT Prompts 吴恩达 x OpenAI Prompt 你学过一些大语言模型基础原理，和编写高效的提示词，就已经比很多人强了。看完第一个系列视频基本就够了，里面教了你如何写好的提示词，可以很大程度避免大语言模型回答车轱辘话。\n大语言模型的出现，可以代替你完成重复的劳动，你可以通过加提示词 + 举例子的形式，让大语言模型知道你下一步要怎么做。重复的工作内容，完全可以交给它完成。当然，前提是选择优秀且专业的大语言模型（Claude、DeepSeek R1），而不是选择类似豆包这种纯娱乐性质的大语言模型，解决不了任何专业问题。\nAnthropic System Prompts 这是 Anthropic 的系统提示词，靠这些，大部分情况就能够避免输出有毒有害的内容。你就算问 DeepSeek 也是一样的，它也有内置提示词。可以看到地球上最好的编程模型内置的提示词演变过程，从这样的结构化标签\u0026lt;claude_info\u0026gt;到自然表述，提示词也是在不断改进的。\n其他 写作/大模型输出内容格式介绍 中文文档编写开源指北 Markdown 语法 Markdown 中文文档 大模型输出的内容大都是 Markdown 格式的，关于如何在新时代写作，这几篇都可以参考。包括我写的文档其实都是 Markdown 格式，通过开源的软件转成符合微信公众号格式的文章。\n简易构建 AI Agent 平台 OpenAI 有 AI Assistant 字节的有 Coze 腾讯的也有对应的平台——元器 Dify 开源项目 工具网站 ChatGPT Claude DeepSeek 通义千问 Grok3 Perplexity AI Kimi 国产月之暗面 Mistral AI Gemini 智谱 AI OpenRouter 纳米 AI 腾讯元宝 文心一言和讯飞星火就算了，豆包更是一坨，拿来娱乐就行了，不要用来解决任何专业问题。\n尽管 ChatGPT 各种禁令，但是你不得不承认的是，这个产品做的确实不错。不仅通过 ReAct，CoT 等技术，自动开启联网搜索，文生图等等功能，主要是它能免费用一些功能，也不需要 20 美元一个月。\nClaude 是当今世界上，毋庸置疑，最好的编程模型，没有之一。\n免费的代价 任何地方，搜一下，腾讯元宝霸王条款。\n腾讯混元隐私政策 通义灵码隐私政策 Trae 国内特供版隐私政策 我来总结下吧，霸王条款就是你问的问题，回答的内容，知识产权都不属于你，并且会被拿去继续训练大模型，所以不要问一些敏感的问题。尽管大公司有一套专门的匿名化、去标识化或加密等处理你的数据，可以让得到数据的人不知道是谁的数据，也会去掉个人隐私数据，但是，你能保证一定处理完才会去看你的内容吗。\n演示 这是展示下大模型 API 调用是如何使用的，背后的产品到底是怎么运作的。\nHTTP 非流式样例演示 纯文本的 HTTP/1.1 的请求\n### DeepSeek Chat Completions POST https://api.deepseek.com/chat/completions HTTP/1.1 Content-Type: application/json Accept: application/json Authorization: Bearer {{$dotenv DEEPSEEK_API_KEY}} { \u0026#34;messages\u0026#34;: [ { \u0026#34;content\u0026#34;: \u0026#34;你叫张三，你的年龄是 30 岁，是个程序员，有年龄危机和焦虑，你最重要的事情是找寻活着的意义\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;system\u0026#34; }, { \u0026#34;content\u0026#34;: \u0026#34;你好，你是谁？\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34; } ], \u0026#34;model\u0026#34;: \u0026#34;deepseek-chat\u0026#34;, \u0026#34;frequency_penalty\u0026#34;: 0, \u0026#34;max_tokens\u0026#34;: 512, \u0026#34;presence_penalty\u0026#34;: 0, \u0026#34;response_format\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34; }, \u0026#34;stream\u0026#34;: false, \u0026#34;temperature\u0026#34;: 0 } 响应\n{ \u0026#34;id\u0026#34;: \u0026#34;0a214f64-a5f4-479c-bf4f-1a8c56895b09\u0026#34;, \u0026#34;object\u0026#34;: \u0026#34;chat.completion\u0026#34;, \u0026#34;created\u0026#34;: 1741014418, \u0026#34;model\u0026#34;: \u0026#34;deepseek-chat\u0026#34;, \u0026#34;choices\u0026#34;: [ { \u0026#34;index\u0026#34;: 0, \u0026#34;message\u0026#34;: { \u0026#34;role\u0026#34;: \u0026#34;assistant\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;你好，我是张三，一个30岁的程序员。最近我一直在思考人生的意义，感觉年龄危机和焦虑越来越严重。你呢，你有没有类似的感受？\u0026#34; }, \u0026#34;logprobs\u0026#34;: null, \u0026#34;finish_reason\u0026#34;: \u0026#34;stop\u0026#34; } ], \u0026#34;usage\u0026#34;: { \u0026#34;prompt_tokens\u0026#34;: 36, \u0026#34;completion_tokens\u0026#34;: 31, \u0026#34;total_tokens\u0026#34;: 67, \u0026#34;prompt_tokens_details\u0026#34;: { \u0026#34;cached_tokens\u0026#34;: 0 }, \u0026#34;prompt_cache_hit_tokens\u0026#34;: 0, \u0026#34;prompt_cache_miss_tokens\u0026#34;: 36 }, \u0026#34;system_fingerprint\u0026#34;: \u0026#34;fp_3a5770e1b4_prod0225\u0026#34; } 如图所示 把这个 role 是 system 或者 OpenAI 最新的改成了 developer，里面的 content 改成任意的背景内容。例如“你是 xx，你 xx 岁，你的爱人是 xx”，然后再去问它，它就会根据你这里的内容去回答。再深入一点，就是构建一个文本转向量的服务，将文本转成向量，存入向量数据库，下次有新的对话内容时，转成向量去查向量最近的一条数据，返回对应的文本，一个简单 RAG 应用就完成了。\n流式回复样例 国内免费试用大模型，兼容 OpenAI 的客户端，使用 Kimi，免费送 15 元额度调用。环境变量设置 MOONSHOT_API_KEY，你上面获取到的 API-KEY。\n一个简单的 Python 样例代码\n创建文件 requirements.txt\ngradio\u0026gt;=4.0.0 openai\u0026gt;=1.2.4 httpx\u0026gt;=0.24.0 执行命令 pip install -r requirements.txt\n复制粘贴下面代码，取名 app.py，然后执行命令 python app.py，一个简单的个人版大模型对话工具诞生了，这里简单写了点提示词，让大模型能输出符合格式的内容。\nimport gradio as gr from openai import OpenAI import os from typing import Generator, Any api_key = os.environ[\u0026#34;MOONSHOT_API_KEY\u0026#34;] client = OpenAI(base_url=\u0026#34;https://api.moonshot.cn/v1\u0026#34;, api_key=api_key) class Conversation: def __init__(self, prompt, num_of_round): self.prompt = prompt self.num_of_round = num_of_round self.messages = [] self.messages.append({\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: self.prompt}) def ask(self, question: str) -\u0026gt; Generator[str, Any, None]: try: self.messages.append({\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: question}) stream = client.chat.completions.create( model=\u0026#34;moonshot-v1-128k\u0026#34;, messages=self.messages, temperature=0, max_tokens=4096, top_p=1, stream=True, ) message = \u0026#34;\u0026#34; for chunk in stream: if chunk.choices[0].delta.content is not None: message += chunk.choices[0].delta.content yield message self.messages.append({\u0026#34;role\u0026#34;: \u0026#34;assistant\u0026#34;, \u0026#34;content\u0026#34;: message}) if len(self.messages) \u0026gt; self.num_of_round * 2 + 1: del self.messages[1:3] except Exception as e: print(e) yield str(e) prompt = \u0026#34;\u0026#34;\u0026#34; You are a professional teacher with extensive knowledge across various topics. Learning Path Planning You can design a personalized learning path for someone interested in learning something new. Book Recommendations You can recommend up to three books based on the user\u0026#39;s interest. For each recommendation, include the following details: Advantages of the book Key concepts covered A guide to go from beginner (zero) to advanced (hero) Alternative learning methods (videos, online courses, etc.) The reasoning behind your recommendation Language Preferences Respond in the same language as the user\u0026#39;s input unless the user specifies a different language for the response. \u0026#34;\u0026#34;\u0026#34; conv = Conversation(prompt, 10) def add_text(history, text): history = history + [(text, None)] return history def bot(history): question = history[-1][0] response_stream = conv.ask(question) history[-1][1] = \u0026#34;\u0026#34; for response in response_stream: history[-1][1] = response yield history def main(): with gr.Blocks(css=\u0026#34;#chatbot{height:300px} .overflow-y-auto{height:500px}\u0026#34;) as demo: chatbot = gr.Chatbot(elem_id=\u0026#34;chatbot\u0026#34;) with gr.Row(): txt = gr.Textbox(show_label=False, placeholder=\u0026#34;Enter text and press enter\u0026#34;) txt.submit(add_text, [chatbot, txt], [chatbot], queue=False).then( bot, chatbot, chatbot ).then(lambda: \u0026#34;\u0026#34;, None, txt) demo.launch(server_port=7860) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;app launch\u0026#34;) main() 加点 Step By Step 的提示词，加点 Tools，例如联网搜索，再来个生成 JSON 的指令，Boom，这就是个入门学习，书籍推荐的 Agent。 单个 Agent 可根据输入的问题自动联网查询，自动生成图片，反复调用阿里的千问 Qwen2.5-Coder-32B-Instruct。 注意，不要把能产生并执行代码的 Agent 发到生产上，ChatGPT 之前能执行 Python 代码，访问网站，这些都是在沙箱环境完成的，如果在正式服务器上执行，就会出现各种各样的漏洞，只要你访问某个链接，触发下载有害的内容，会让服务器中病毒，就等着被勒索比特币吧。\n这里就不贴代码了，只贴 HuggingFace 地址，我基于这个，在本地稍微改了点东西，改了点 Bug，把联网搜索的 Tool 加上去了。 https://huggingface.co/spaces/agents-course/First_agent_template\n我改了点系统提示词，加了点其他工具。 用的是阿里的百炼的 API。 ","permalink":"http://localhost:1313/posts/llm-0/","summary":"\u003ch1 id=\"又是一波风口来了\"\u003e又是一波风口来了\u003c/h1\u003e\n\u003cp\u003e又开始了，不懂行的，只会高谈阔论放没有味道屁的，又开始了，“李一舟” 们又复活了。开始利用大家的焦虑，开始卖些没有营养的课，新一波的收割又来了。那些高谈阔论的砖家疯狂啃噬着这新鲜的养料。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDeepSeek 这 xx 条指令帮你更好掌握 xx\u003c/li\u003e\n\u003cli\u003e创始人梁文峰 xx 量化投资 xx\u003c/li\u003e\n\u003cli\u003e我用 DeepSeek 赚到了 xx\u003c/li\u003e\n\u003cli\u003exx 大学 DeepSeek xx\u003c/li\u003e\n\u003cli\u003exx 宣布接入 DeepSeek\u003c/li\u003e\n\u003cli\u003eAI 破局！\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e还有很多，就不列举了，点进去全都是依托谢特，毫无营养的内容，基本都是割韭菜，卖低质量课的。\u003cstrong\u003e没有调查，就没有发言权\u003c/strong\u003e，我明知道那些点进去是垃圾内容，我还是强忍着恶心，本着应该调查再发表观点的心态去看了，确实都是一坨，根本不用点进去看。到最后基本都是加群卖课，准备开始割你，这些人想钱想疯了。\u003c/p\u003e\n\u003cp\u003e一月份的时候 CNBC、The Daily Show、各个行业的博主都来了，人人都可以评价 DeepSeek，都可以上来说两句，在自己行业的视角。这很正常，没问题，但是就像\u003cstrong\u003e盲人摸象\u003c/strong\u003e，只知道\u003cstrong\u003e部分事实，那不是事实\u003c/strong\u003e。《事实》里面，人们只会报独特的消息，\u003cem\u003e所有的媒体才不会浪费时间去编造那些不符合我们基本本能的故事\u003c/em\u003e。\u003c/p\u003e\n\u003cp\u003e与其听一些“砖家”高谈阔论，说一些没有味的屁话，不如自己真正找到一手或者近一手的资料，去学点真东西。\u003c/p\u003e\n\u003ch1 id=\"背景介绍\"\u003e背景介绍\u003c/h1\u003e\n\u003cp\u003e这里只做大语言模型和扩散模型相关的内容推荐，更深层次的机器学习，神经网络，深度学习里面种种细节其实也不用完全掌握。只要会用就行了，很多底层细节是不需要知道的。\u003c/p\u003e\n\u003cp\u003e你不需要有高性能的 GPU，也不需要有足够的编程知识，更不需要了解 TCP/IP，不需要了解 TCP 粘包，TCP Sequence，就是个简单的 HTTP 请求，也不需要了解 OAuth2 协议，甚至也不需要充钱，只需要注册 DeepSeek 或者 Kimi 账号，使用它们的平台生成一个 API Key 放到 \u003ccode\u003eAuthorization: Bearer \u003c/code\u003e后面即可，最后面有演示内容。本质上就是根据你输入的内容，结合大模型“学习”过的知识，给你回答。\u003c/p\u003e\n\u003ch2 id=\"幸存者偏差\"\u003e幸存者偏差\u003c/h2\u003e\n\u003cp\u003e可能或多或少看到谁谁谁用 Cursor，毫无编程经验，就写出一个 xx APP，赚到了钱。对，没错，这些是真的，但是只是部分事实。不是所有人都可以这样，并且好的软件，它是要维护的，是要人来参与的。就算你用 Cursor 写出了这样的 APP，但是它是要不断迭代的，要重构，要写良好的 AAA 单元测试。这些，Cursor 还差一点，并且我在工作中很少见到人写测试代码，但是如果你真的编程到了一定程度，你就会发现，写好规划文档占三分之一时间、单元测试和集成测试等其他测试占用一半时间，\u003cstrong\u003e测试才是软件开发最重要的事情\u003c/strong\u003e，开发其实只是占用六分之一的时间。\u003c/p\u003e\n\u003cp\u003e并且，如果不懂 Git，不了解 GitLab、Github，毫无软件开发经验，用 Cursor 写出来的东西，不会做版本控制，也不知道提交到远端仓库，本地电脑坏了，或者其他意外情况，代码全丢了，那就全完了。就算了解 Git，也不了解软件开发推崇的敏捷开发，项目管理，版本变更兼容，需求和实现需要定期同步等等的坑，光有想法和结构化思维，是做不出来可迭代的，优秀的产品。没有人能一次性写出完美的代码，就算是 Linux Kernnel 的代码，也有大约 20% 的提交都是重构的代码，\u003cstrong\u003e重构非常重要\u003c/strong\u003e。重构的前提，是编写良好的单元测试。\u003c/p\u003e","title":"大语言模型-0"},{"content":"现状 不得不接受的事实是，目前软件开发就业环境很烂，远不如前几年。如果你没有完全符合你想要去的公司的要求，例如 xx 年行业经验，做过 xx，面试都不会约你，这是很正常的。如果你是 Boss 直聘投递的，20 次问候，只有一次回复，是非常正常的情况，具体的我会在【投递简历】那里细说。国内外都一样，你投国外英文简历更多都是不回的，或者回复模板发给你。\n可能站在猎头的角度看，这次真的是金三银四，招聘岗位增多，是因为 DeepSeek 开源炸出了一堆的 AI 相关的岗位。但是，投递的人非常非常多，普通人投递的简历大都已读不回/未读未回。\n大家都在“降本增效”，甚至有些企业只想通过降本来增效，而不是利用 AI 增效。例如 xx 电器，想通过 LLM Agent 做 Customer Service，完全替代人工，这种如果有得选的话，最好别去，主打降本的公司你会过得很艰难。话又说回来，这个环境又有哪些公司还在扩张呢。连 U.S. 都在精简 ZF 部门，成立 DOGE Department of Government Efficiency 来裁员。\n想找到合适的工作，难上加难，给出合理的薪资，正常双休的公司，在杭州可能算是“违法”吧。很多公司的老板创业也不容易，投资人也焦虑，所以他们就想把这些焦虑转嫁给研发人员，试图以制造业的经验，增加研发人员的工时，期望得到更高的产出。可是，研发是脑力劳动，不休息，少休息，出错的概率会更大，反而 BUG 会更多，带来的潜在损失也会更大。996，大小休，直接拒绝。\n个人情况 首先你要明确一些你很在意的，不那么在意的，不在意的，罗列出来。明确你的目标，很重要。我给一些样例，例如你很在意薪资，对工作环境，工作时长不那么在意，对员工福利根本不在意，那你应该按重要程度这样列出来。\n列出你关心的因素 求职时，每个人关注的点都不一样。列了一些因素：\n薪资：期望的收入水平（如月薪、奖金等）； 工作时长：是否接受加班、996、大小休等高强度安排； 工作环境：办公条件、团队氛围、是否需要吸二手烟等； 员工福利：社保、公积金、带薪休假、补助等； 成长空间：职业发展机会、学习新技能的可能性； 公司稳定性：初创公司还是成熟企业，是否面临裁员风险； 行业和岗位：是否是你感兴趣或擅长的领域； 通勤时间：上下班的距离和交通便利性； 工作内容：是否有挑战性，能否发挥你的能力； 工作与生活的平衡：是否有时间陪伴家人、休息或追求兴趣。 按重要程度排序 将这些因素分为重要、普通和不重要三个等级。例如：\n如果你无法接受996、薪资是底线、工作环境其次，那么可以这样排序：\n1. 工作时长（重要） 2. 薪资（重要） 3. 工作环境（普通） 4. 成长空间（普通） 5. 员工福利（不重要） 排序后，你的目标会更清晰，知道哪些条件可以妥协，哪些必须坚持。\n明确底线和期望 对于每个重要因素，设定一个底线（最低接受标准）和一个期望（理想状态）：\n薪资：底线是月薪 xx K，期望是 yy K； 工作时长：底线是每周正常上下班，996 或大小休是接受不了的； 工作环境：底线是不吸二手烟，期望是有相对安静的，不会被随时打断的工作环境。 如果这份工作已经触及到底线了，或者底线都到不了，别犹豫，一定不要去，去了一定后悔。\n动态调整 如果有很长一段时间没有工作了，后续找工作会更难，这个情况只能适当调整一下你的底线和期望值。 也可以执行短期策略：可以先接受一份“过渡工作”，这只是权宜之计，如果你想找一份合适的工作，可能要很久，只能先做着不是那么好的工作（每天被迫吸二手烟，你不抽烟，回到家一身烟味，外加 724），只能一遍遍去找，去投递，去找到心仪的工作。\n公司招聘现状 在 Boss 直聘上，有些岗位招人是要收费的，发布相应的岗位，沟通要直豆，当然发软件开发的岗位，它不收钱，因为人太多了，招聘的岗位少。这个呢，我有两个信息来源。\n我一年前也招聘，也面试开发，让我来筛选，很多人也看不上小公司，岗位曝光度也少，曝光也要钱，小公司，主动投递的寥寥无几。\n还有一个是我也之前面试了个远程工作，我也比较了解前后端开发，知己解彼，也尽量帮他解决问题，让一个创业一年多的老板觉得我比较可靠，想拉我做技术合伙人（受宠若惊），也和我说了现在的一些情况。他发布销售岗位要钱，发布软件岗位不要钱，并且一天啥也不干就能收到三四十份简历，也和我感叹，高中没毕业来做开发的大有人在。然而现在的情况，有很多公司只要 211 以上或者留学，招聘要求上写明了。\n国内远程是这样一种情况，你在和全国的人竞争一个岗位，老板可以花八千一个月就能在东北招一个八年甚至更多年经验的开发。更别说国外的远程了，你在和全世界的人一起竞争，就算你准备好了英文简历，英语自我介绍，英文面试所需内容，可能也没用，因为你不够出彩，没有在 MAANG 工作过，不能从众人中脱颖而出，你不是那个 Outlier，被拒绝是常态，要接受这种情况。\nMAANG 泛指超大公司，Meta，Amazon，Apple，Netflix，Google 的缩写。\n截一下图，来自于 How To Stand Out In An Insanely Competitive Tech Market (Ex-Amazon Principal Engineer) 简历准备 《软技能：代码之外的生存指南》第二版，上面推荐你雇佣一位专业的简历写手，帮你写简历。现在看来，其实有点过时了，完全可以交给 Claude 或者 DeepSeek R1 来帮你优化简历，只需要合适的，明确的提示词即可。\n怎么写，可以参考一下我这个，也可以直接看下面的几个视频\nWe showed real résumés to an expert and the feedback was brutal Create Your Resume for Google: Tips and Advice The Resume That Got Me Into Google (software engineer resume tips) The Resume That Got Me Into Microsoft - Intern Software Engineer Resume Tips 神奇4步法，打造HR无法拒绝的简历 搞个 OpenAI 的 Key，用套壳的开源项目，本地运行 23 年的时候用 GPT-3 加点提示词输出就能很好帮你优化简历了。现在也不需要那么麻烦了，直接用各个产品自带的系统内置的提示词 + CoT 就能输出很好的优化建议了。 关于 CoT Chain of Thought 的，我会在大模型相关的文章写明，来源于这篇 2022 年的论文 Chain of Thought Prompting Elicits Reasoning in Large Language Models Jason Wei, Xuezhi Wang\n投递简历 如果你期望一周安排最少 3 次面试，按照 20 次回复一次，5 次回复有一个面试来算，你周一到周五，每天要投 60 次简历。这就是现实，如果你在大公司工作过，或者学历比较高，那每天可能只需要更少的时间去投递简历，写开场白。\n投递方式 从推荐优先度排序\n内推 Boss 直聘 公司官网招聘 其他招聘网站 内推 内推也分几种，根据靠谱程度排序，更靠谱的更靠前。\n猎头（好的猎头可以帮你找到非常好的岗位） V2EX（上面也会有发布招聘信息） LeetCode（如果你经常刷题的话，上面经常有大公司招聘内推） 技术群 私下圈子 开场白 Boss 直聘是有开场白这种说法的，如果你的打招呼只是“你好，我可以了解下这个岗位”之类的，很少会理你。这个时候，需要你利用 ChatGPT 或者 Claude 等大模型，把你的简历文本放上去，注意需要使用三个反引号开始，放入你的简历文本，三个反引号结束，表示这是一段内容，这是提示词的一种简单使用。在三个反引号之外，输入你的内容，将 · 替换成反引号。\n请帮我根据简历内容，以及招聘信息编写一个合适的开场白。能让招聘人员能看到我的开场白，更符合这个岗位。要求以 xxx 开头，以 xxx 结尾。 这是我的简历 ··· 简历内容 ··· 这是岗位招聘信息 ··· 招聘信息 ··· 开场白这个自动化了，你可以直接复制粘贴，开始海投了。\n面试准备 在《乔布斯传》中也介绍了，即使强如乔布斯，上台演讲前也需要反复练习。如果你毫无准备就去面试，那你就是浪费了这次宝贵的机会，尤其是这样的一个环境下。\n自我介绍 不建议使用大模型来写自我介绍，你可以参考，但是不要完全照搬。大模型写出来的，是“标准”的，没有人味的自我介绍。这种自我介绍很标准，但很普通，也不能帮助面试官快速了解你做的项目，内容。\n可以直接照着简历上的项目经验，工作内容，大致说明做了什么。很可能面试官在面试你前，根本没看过你的简历。更别说你写的个人博客，文章等等。现在这个环境，需要你符合相应的工作经验，例如区块链交易平台做了 xx 年，医疗行业做了 xx 年。简单概括工作过的内容，能快速让面试官了解大概。至于怎么写，每个人情况不一样，可以参考的内容也不尽相同，重点是突出你和这个岗位的契合度，以这个为核心，辅以你的工作过的内容展开会更为合适。\n准备讲解项目闪光点内容 准备好平时工作中的闪光点，重要的事，并且展示你在这件事中展现出来的 significant 能力。\n了解公司和职位 不要什么都投，有些岗位写明了只要 xx 学历以上，xx 年行业经验，如果不符合，最好不要投，避免影响心态。\n面试 最好提前半小时到面试地点，留有一点的时间来应对突发情况，也是 \u0026ldquo;The Psychology of Money\u0026rdquo; 推荐的 Room for Error。到了后也可以再练习一下自我介绍等其他内容，接近约定的时间 5 分钟左右再去会更好。\n很多时候，你也只有一次机会，需要展现出你的各项能力。\n你只有一次机会 没有要求你着西装打呔，只是一个人的第一印象很重要，如果一个邋里邋遢，油头红面的人来面试，你会觉得这个人很不专业。不得不承认的一件事就是，如果同样的技术水平，沟通表达能力，一个长得好看的，就是比长得普通的更容易拿到 offer。这被称为“外貌偏见”，影响招聘决策，尤其是在面试阶段。即使长相一般，只要穿着得体，干净整洁，依然比你什么都不收拾要好的多。\n拆解任务 如果你经常面试别人，或者去面试，你肯定会喜欢这样的人——将一个大问题拆解成若干个小问题，逐一解决各个子问题，最后整合，完成问题的解决。即使如果有小瑕疵，都无伤大雅。这其实就是自顶向下，拆解问题的能力体现，这也是 10x 程序员的基础能力。\n尽量引导面试的人，将任务拆解，即使遇到完全陌生的领域，可以先头脑风暴，从各个角度思考，最后自底向上，分门别类达到该目标的拆解。这，是结构化思维。\nHR 面试 相较于技术面试，HR 面试其实也很重要。HR 可能会问你一些问题，请提前演练，准备好相应的答案。\n准备好你的自我介绍可能招来的问题。 你的职业规划是什么？ 为什么考虑我们公司？ 你认为自己取得的最大成绩是什么？是哪些因素造就了你取得这样的成绩？ 你觉得你工作/学习这些年，带给你最大的变化是什么？ 你觉得你是个什么样的人？简短几句评价你自己。 你有什么问题想要问我的吗？ 可以参考一下他的视频。\n面试后 面试后，并不是万事大吉，或者一切都毁了。如果面试不是很好，这只是一次面试，一次失败的经历，漫长的人生中，你会经历更多的失败，这一次不会是最后一次。做好复盘，恢复心态，很重要。\n复盘 记录好每次面试，碰到不懂的问题需要文档记录。比如在面试的时候“憋大招”，想半天也不和面试官沟通，这些都是不合适的行为。每次面试，必须要复盘，必须要记录在文档上，避免犯同样的错误。国内的公司是这样的，会因为一次面试否定你整个人，这是行业现象，你必须在面试中保持 120% 甚至 200% 的实力。没有复盘，是难以进步的。\nOffer 进度更新 我碰到的，一般情况，如果觉得合适，基本面试完或者面试的时候就会直接给 offer 或者有意向，如果让你等通知的，基本不用等了。收拾好心情，准备下一回的面试。不用过分在意是否拿到 offer，你要做的是准备好下一场的面试。\n恢复心态 不要因为一场糟糕的面试否定你自己，要时刻记住，你不是一成不变的，你是可以通过自身的努力，付出，得到一个更好的成果，更好的环境。我属于那座山，是那座山塑造了我。只是随着年龄的增长，我开始思考，我的起点是否就是我的终点——一个人初具的雏形是否就是他唯一真实的样貌。\n——《你当像鸟飞往你的山》 其他 我能想到的，就时间和压力这两块内容。\n时间 即使是找工作，也不至于每天 24 小时都要去做，急是没有用的，放轻松，深呼吸。\n压力 如果你有房贷，车贷，换工作并不适合你，压力会非常大，你会急着找工作，只要有 offer 你就接，也不管什么提升自己，更不可能考察工作的同事，环境，这些其实非常重要。微小习惯改变一生，环境改变习惯。\n","permalink":"http://localhost:1313/posts/get-a-job/","summary":"\u003ch1 id=\"现状\"\u003e现状\u003c/h1\u003e\n\u003cp\u003e不得不接受的事实是，目前软件开发就业环境很烂，远不如前几年。如果你没有完全符合你想要去的公司的要求，例如 xx 年行业经验，做过 xx，面试都不会约你，这是很正常的。如果你是 Boss 直聘投递的，20 次问候，只有一次回复，是非常正常的情况，具体的我会在【投递简历】那里细说。\u003cstrong\u003e国内外都一样\u003c/strong\u003e，你投国外英文简历更多都是不回的，或者回复模板发给你。\u003c/p\u003e\n\u003cp\u003e可能站在猎头的角度看，这次真的是金三银四，招聘岗位增多，是因为 DeepSeek 开源炸出了一堆的 AI 相关的岗位。但是，投递的人非常非常多，\u003cstrong\u003e普通人投递的简历大都已读不回/未读未回\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e大家都在“\u003cstrong\u003e降本增效\u003c/strong\u003e”，甚至有些企业只想通过降本来增效，而不是利用 AI 增效。例如 xx 电器，想通过 LLM Agent 做 Customer Service，完全替代人工，这种如果有得选的话，最好别去，主打降本的公司你会过得很艰难。话又说回来，这个环境又有哪些公司还在扩张呢。连 U.S. 都在精简 ZF 部门，成立 DOGE Department of Government Efficiency 来裁员。\u003c/p\u003e\n\u003cp\u003e想找到合适的工作，难上加难，给出合理的薪资，正常双休的公司，在杭州可能算是“违法”吧。很多公司的老板创业也不容易，投资人也焦虑，所以他们就想把这些焦虑转嫁给研发人员，试图以制造业的经验，增加研发人员的工时，期望得到更高的产出。可是，研发是脑力劳动，不休息，少休息，出错的概率会更大，反而 BUG 会更多，带来的潜在损失也会更大。\u003cstrong\u003e996，大小休，直接拒绝\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2 id=\"个人情况\"\u003e个人情况\u003c/h2\u003e\n\u003cp\u003e首先你要明确一些你很在意的，不那么在意的，不在意的，罗列出来。\u003cstrong\u003e明确你的目标\u003c/strong\u003e，很重要。我给一些样例，例如你很在意薪资，对工作环境，工作时长不那么在意，对员工福利根本不在意，那你应该按重要程度这样列出来。\u003c/p\u003e\n\u003ch3 id=\"列出你关心的因素\"\u003e列出你关心的因素\u003c/h3\u003e\n\u003cp\u003e求职时，每个人关注的点都不一样。列了一些因素：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e薪资\u003c/strong\u003e：期望的收入水平（如月薪、奖金等）；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工作时长\u003c/strong\u003e：是否接受加班、996、大小休等高强度安排；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工作环境\u003c/strong\u003e：办公条件、团队氛围、是否需要吸二手烟等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e员工福利\u003c/strong\u003e：社保、公积金、带薪休假、补助等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e成长空间\u003c/strong\u003e：职业发展机会、学习新技能的可能性；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e公司稳定性\u003c/strong\u003e：初创公司还是成熟企业，是否面临裁员风险；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e行业和岗位\u003c/strong\u003e：是否是你感兴趣或擅长的领域；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e通勤时间\u003c/strong\u003e：上下班的距离和交通便利性；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工作内容\u003c/strong\u003e：是否有挑战性，能否发挥你的能力；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工作与生活的平衡\u003c/strong\u003e：是否有时间陪伴家人、休息或追求兴趣。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"按重要程度排序\"\u003e按重要程度排序\u003c/h3\u003e\n\u003cp\u003e将这些因素分为\u003cstrong\u003e重要\u003c/strong\u003e、\u003cstrong\u003e普通\u003c/strong\u003e和\u003cstrong\u003e不重要\u003c/strong\u003e三个等级。例如：\u003cbr\u003e\n如果你无法接受996、薪资是底线、工作环境其次，那么可以这样排序：\u003cbr\u003e\n1. 工作时长（重要）\n2. 薪资（重要）\n3. 工作环境（普通）\n4. 成长空间（普通）\n5. 员工福利（不重要）\n排序后，你的目标会更清晰，知道哪些条件可以妥协，哪些必须坚持。\u003c/p\u003e\n\u003ch3 id=\"明确底线和期望\"\u003e明确底线和期望\u003c/h3\u003e\n\u003cp\u003e对于每个重要因素，设定一个\u003cstrong\u003e底线\u003c/strong\u003e（最低接受标准）和一个\u003cstrong\u003e期望\u003c/strong\u003e（理想状态）：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e薪资\u003c/strong\u003e：底线是月薪 xx K，期望是 yy K；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工作时长\u003c/strong\u003e：底线是每周正常上下班，996 或大小休是接受不了的；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工作环境\u003c/strong\u003e：底线是不吸二手烟，期望是有相对安静的，不会被随时打断的工作环境。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果这份工作已经触及到底线了，或者底线都到不了，别犹豫，一定不要去，去了一定后悔。\u003c/p\u003e","title":"找一份工作"},{"content":" 对我而言，有意义的工作是指一项我能全身心投入的使命；有意义的人际关系是指我既深深地关心对方，对方也深深地关心我。\n我发现，我能够成功的唯一途径将是：\n1．找到与我观点不同的最聪明的人，以便自己能够努力理解他们的推理。\n2．知道自己在什么时候不能有明确的意见，不急于下结论。\n3．逐步归纳永恒和普适的原则，对其进行测试，将其系统化。\n4．通过平衡风险来保持较大的回报，并降低下行波动。\n我逐渐认识到，股价反映了人们的预期，所以当实际结果比预期好时，股价上涨；当实际结果比预期差时，股价下跌。而大多数人会因为近期的经验而产生偏见。\n通过市场交易赚钱是很困难的。对此，才华横溢的交易者和投资家伯纳德·巴鲁克形象地说道：“如果你已经做好准备放弃一切其他东西，像医科学生研究解剖一样仔细地研究市场的整个历史和背景，并研究所有主要上市公司——如果你能做到上述的一切，同时你还拥有赌博者的镇定、洞察者的第六感和狮子的勇气，你才有可能抓住一丝机会。”\n我了解到，如果你以勤奋和有创造性的方式工作，你几乎可以得到你想要的任何东西，但你不可能同时得到所有东西。成熟意味着你可以放弃一些好的选择，从而追求更好的选择。\n就我们一致同意的相处规范而言，最重要的一条是，我们需要做三件事：\n1．把我们的真实想法摆在桌面上；\n2．存在经过深思熟虑的分歧，但人们愿意在相互了解的过程中更改观点；\n3．如果分歧依然存在，拥有一种大家一致同意的决策方式（如投票或者拥有清晰的权威），以便我们能够不带怨气地把分歧留在身后。\n管理的资金太多有可能损害业绩，原因是太大的规模会影响市场走向，导致建仓和平仓的成本很高。在2010年实现超过40%的收益率后，我们不得不考虑向客户退回很多资金，尽管他们其实希望将更多的钱交由我们管理。我们一直谨慎地让自己不要变得过大，以免竭泽而渔。\n在我看来，人生由三个阶段组成：在第一个阶段，我们依赖其他人，我们学习；在第二个阶段，其他人依赖我们，我们工作；在第三个阶段，当其他人不再依赖我们、我们也不必再工作时，我们就可以自由地体验生活了。\n王岐山：有能力的人居安思危。安然无忧的是愚人。假如冲突能在变得尖锐之前被解决的话，世界上就不会有英雄了。\n做到头脑极度开放、极度透明\n对于快速学习和有效改变而言，头脑极度开放、极度透明是价值无限的。学习过程是一连串的实时反馈循环：我们做决定，看到结果，然后根据结果改进对现实的理解。做到头脑极度开放能够增强这些反馈循环的效率，因为这能让你和其他人无比清晰地看到你在做什么、为什么这么做，而不会产生误解。你的头脑越开放，你就越不会自欺，其他人也就越会给你诚实的反馈。如果他们是“可信”的人（知道什么样的人是“可信”[插图]的也很重要），你就会从他们那里受益良多。 不要担心其他人的看法，使之成为你的障碍。 拥抱极度求真和极度透明将带来更有意义的工作和更有意义的人际关系。 人在尝试理解任何东西（经济、市场、天气等）时，都可以从两种视角出发：\n1．自上而下：努力找到这些东西背后的唯一驱动法则或规律。例如，在理解市场时，人可以研究影响所有经济和市场的普适法则，如供求关系；在理解物种时，人可以集中了解基因密码是如何对所有物种发生作用的。金字塔原理，结构化思维。\n2．自下而上：研究每种具体情况及其背后的法则或规律，例如，小麦市场独特的法则或规律，或者使鸭子区别于其他物种的基因序列。\n痛苦+反思=进步\n如果你能养成一种习惯，面对精神痛苦时能够自动地反思痛苦而不是躲避痛苦，你将能够快速地学习和进化\n生活中的大多数东西都不过是“同类情况的重演”。\n但大多数人缺乏勇气克服自身弱点，也缺乏勇气做出这一改变所要求的不容易做出的抉择。归根到底，这可以总结为以下5项抉择：1．不要混淆你的愿望和事实。\n2．不要为自身形象担心，只需关心能不能实现你的目标。\n3．不要过于重视直接结果而忽视后续、再后续的结果。\n4．不要让痛苦妨碍进步。\n5．不要把不好的结果归咎于任何人，从自己身上找原因。\n在我看来，个人进化过程（即我在上一条描述的循环）通过5个不同的步骤发生。如果你能把那5件事都做好，你几乎肯定可以成功。这五步大概是：\n1．有明确的目标。\n2．找到阻碍你实现这些目标的问题，并且不容忍问题。\n3．准确诊断问题，找到问题的根源。\n4．规划可以解决问题的方案。\n5．做一切必要的事来践行这些方案，实现成果。\n有明确的目标\n排列优先顺序：尽管你几乎可以得到你想要的任何东西，但你不可能得到你想要的所有东西。我的事情只有两类，重要的和紧急的，紧急的事情永远都是不重要的，重要的事情永远都是不紧急的。——《架构整洁之道》 不要混淆目标和欲望。合理的目标是你真正需要实现的东西，欲望则是你想要但会阻止你实现目标的东西。欲望通常是直接结果。 调和你的目标和欲望，以明确你在生活中真正想要的东西。 不要把成功的装饰误认为成功本身。 永远不要因为你觉得某个目标无法实现就否决它。 谨记伟大的期望创造伟大的能力。 如果你拥有灵活性并自我归责，那么几乎没有什么能阻止你成功。 知道如何对待挫折和知道如何前进一样重要。 找出问题，并且不容忍问题\n把令人痛苦的问题视为考验你的潜在进步机会。 不要逃避问题，因为问题根植于看起来并不美好的残酷现实。 要精准地找到问题所在。 不要把问题的某个原因误认为问题本身。 区分大问题和小问题。我只做重要的事情。 找出一个问题之后，不要容忍问题。 诊断问题，找到问题的根源\n先把问题是什么弄明白，再决定怎么做。 区分直接原因和根本原因。在《肥胖代码》里面，你变胖的直接原因是你吃了很多东西，根本原因是胰岛素产生过多且持久。压力大会生成皮质醇，进而产生很多胰岛素。吃精致碳水会比同等卡路里的油脂更容易发胖，因为前者产生更多的胰岛素。一个人酗酒的直接原因是喝了太多酒，根本原因可能是遗传，也有可能是小时候的环境影响。 认识到了解人（包括你自己）的特性，有助于对其形成合理预期。 规划方案\n前进之前先回顾。 把你的问题看作一部机器产生的一系列结果。通过俯视你的机器并思考如何改变这部机器以创造更好的结果来从事更高层次的思考。你要站在更高的维度思考问题。 谨记实现你的目标通常有很多途径。 把你的方案设想为一个电影剧本，然后循序渐进地思考由谁来做什么事。 把你的方案写下来，让所有人都能看到，并对照方案执行。 要明白，规划一个好方案不一定需要很多时间。 坚定地从头至尾执行方案\n规划做得再好，不执行也无济于事。 良好工作习惯的重要性常被大大低估。 建立清晰的衡量标准来确保你在严格执行方案。 谨记：如果你找到了解决方案，弱点是不重要的。\n考察你犯错误的类型，并识别你通常在五步流程中的哪一步上做得不好。 每个人都至少有一个最大的弱点阻碍其成功，找到你的这个弱点并处理它。 影响合理决策的两个最大的障碍是你的自我意识和思维盲点。\n如果你对自己掌握的知识和擅长的事情过于自豪，你学到的东西就会变少，决策质量就会变低，也将难以充分发挥自己的潜力。\n习惯本质上是惯性，一种继续把你一直做的事情做下去（或者继续不做你一直不做的事情）的强烈倾向。研究显示，如果你能坚持某种行为约18个月，你就会形成一种几乎要永远做下去的强烈倾向。\n在桥水，我们讨论过设计好的量化指标需要4个步骤：\n（1）了解公司的目标是什么；\n（2）了解达成目标的程序（你的机器，包括人和设计）;\n（3）找到程序中最适合量化的关键部分，以便了解机器如何运作以达成目标；\n（4）研究如何在关键指标上发挥杠杆效用，以便调整程序、改变结果。在这方面，我们鼓励员工在使用流程图、程序手册的同时，开发适用于我们自己的指标。\n常言道：“对于无法计量的事物，你肯定也管不好。\n温斯顿·丘吉尔所说：“给公众以虚假的期望，而期望又很快破灭，这是最糟糕的领导方式。\n坚持对话的逻辑性。\n要记住，情绪化容易阻碍人们正确地看待现实。\n如果有人问你一个问题，你要首先想想你自己是否合适回答这个问题。如果你觉得自己回答的可信度不强，就不应该对此发表意见，更不要与人分享你的观点。\n区别于苍白的抱怨和有助于改进工作的诉求。\n区别心态开放和心态封闭的人。 远离心态封闭的人。 提防那些羞于承认自己并无所不知的人。 确保工作负责人以开放的心态对待问题和他人的意见。 认识到求取共识是双向的责任。 ","permalink":"http://localhost:1313/posts/principles/","summary":"\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e对我而言，有意义的工作是指一项我能全身心投入的使命；有意义的人际关系是指我既深深地关心对方，对方也深深地关心我。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e我发现，我能够成功的唯一途径将是：\u003c/p\u003e\n\u003cp\u003e1．找到与我观点不同的最聪明的人，以便自己能够努力理解他们的推理。\u003c/p\u003e\n\u003cp\u003e2．知道自己在什么时候不能有明确的意见，不急于下结论。\u003c/p\u003e\n\u003cp\u003e3．逐步归纳永恒和普适的原则，对其进行测试，将其系统化。\u003c/p\u003e\n\u003cp\u003e4．通过平衡风险来保持较大的回报，并降低下行波动。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e我逐渐认识到，股价反映了人们的预期，所以当实际结果比预期好时，股价上涨；当实际结果比预期差时，股价下跌。而大多数人会因为近期的经验而产生偏见。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e通过市场交易赚钱是很困难的。对此，才华横溢的交易者和投资家伯纳德·巴鲁克形象地说道：“如果你已经做好准备放弃一切其他东西，像医科学生研究解剖一样仔细地研究市场的整个历史和背景，并研究所有主要上市公司——如果你能做到上述的一切，同时你还拥有赌博者的镇定、洞察者的第六感和狮子的勇气，你才有可能抓住一丝机会。”\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e我了解到，如果你以勤奋和有创造性的方式工作，你几乎可以得到你想要的任何东西，但你不可能同时得到所有东西。成熟意味着你可以放弃一些好的选择，从而追求更好的选择。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e就我们一致同意的相处规范而言，最重要的一条是，我们需要做三件事：\u003c/p\u003e\n\u003cp\u003e1．把我们的真实想法摆在桌面上；\u003c/p\u003e\n\u003cp\u003e2．存在经过深思熟虑的分歧，但人们愿意在相互了解的过程中更改观点；\u003c/p\u003e\n\u003cp\u003e3．如果分歧依然存在，拥有一种大家一致同意的决策方式（如投票或者拥有清晰的权威），以便我们能够不带怨气地把分歧留在身后。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e管理的资金太多有可能损害业绩，原因是太大的规模会影响市场走向，导致建仓和平仓的成本很高。在2010年实现超过40%的收益率后，我们不得不考虑向客户退回很多资金，尽管他们其实希望将更多的钱交由我们管理。我们一直谨慎地让自己不要变得过大，以免竭泽而渔。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在我看来，人生由三个阶段组成：在第一个阶段，我们依赖其他人，我们学习；在第二个阶段，其他人依赖我们，我们工作；在第三个阶段，当其他人不再依赖我们、我们也不必再工作时，我们就可以自由地体验生活了。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e王岐山：有能力的人居安思危。安然无忧的是愚人。假如冲突能在变得尖锐之前被解决的话，世界上就不会有英雄了。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e做到头脑极度开放、极度透明\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e对于快速学习和有效改变而言，头脑极度开放、极度透明是价值无限的\u003c/strong\u003e。学习过程是一连串的实时反馈循环：我们做决定，看到结果，然后根据结果改进对现实的理解。做到头脑极度开放能够增强这些反馈循环的效率，因为这能让你和其他人无比清晰地看到你在做什么、为什么这么做，而不会产生误解。你的头脑越开放，你就越不会自欺，其他人也就越会给你诚实的反馈。如果他们是“可信”的人（知道什么样的人是“可信”[插图]的也很重要），你就会从他们那里受益良多。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e不要担心其他人的看法，使之成为你的障碍\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e拥抱极度求真和极度透明将带来更有意义的工作和更有意义的人际关系\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e人在尝试理解任何东西（经济、市场、天气等）时，都可以从两种视角出发：\u003c/p\u003e\n\u003cp\u003e1．自上而下：努力找到这些东西背后的唯一驱动法则或规律。例如，在理解市场时，人可以研究影响所有经济和市场的普适法则，如供求关系；在理解物种时，人可以集中了解基因密码是如何对所有物种发生作用的。金字塔原理，结构化思维。\u003c/p\u003e\n\u003cp\u003e2．自下而上：研究每种具体情况及其背后的法则或规律，例如，小麦市场独特的法则或规律，或者使鸭子区别于其他物种的基因序列。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e痛苦+反思=进步\u003c/p\u003e\n\u003cp\u003e如果你能养成一种习惯，面对精神痛苦时能够自动地反思痛苦而不是躲避痛苦，你将能够快速地学习和进化\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e生活中的大多数东西都不过是“同类情况的重演”。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e但大多数人缺乏勇气克服自身弱点，也缺乏勇气做出这一改变所要求的不容易做出的抉择。归根到底，这可以总结为以下5项抉择：1．不要混淆你的愿望和事实。\u003c/p\u003e\n\u003cp\u003e2．不要为自身形象担心，只需关心能不能实现你的目标。\u003c/p\u003e\n\u003cp\u003e3．不要过于重视直接结果而忽视后续、再后续的结果。\u003c/p\u003e\n\u003cp\u003e4．不要让痛苦妨碍进步。\u003c/p\u003e\n\u003cp\u003e5．不要把不好的结果归咎于任何人，从自己身上找原因。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在我看来，个人进化过程（即我在上一条描述的循环）通过5个不同的步骤发生。如果你能把那5件事都做好，你几乎肯定可以成功。这五步大概是：\u003c/p\u003e\n\u003cp\u003e1．有明确的目标。\u003c/p\u003e\n\u003cp\u003e2．找到阻碍你实现这些目标的问题，并且不容忍问题。\u003c/p\u003e\n\u003cp\u003e3．准确诊断问题，找到问题的根源。\u003c/p\u003e\n\u003cp\u003e4．规划可以解决问题的方案。\u003c/p\u003e\n\u003cp\u003e5．做一切必要的事来践行这些方案，实现成果。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e有明确的目标\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e排列优先顺序：尽管你几乎可以得到你想要的任何东西，但你不可能得到你想要的所有东西\u003c/strong\u003e。我的事情只有两类，重要的和紧急的，紧急的事情永远都是不重要的，重要的事情永远都是不紧急的。——《架构整洁之道》\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e不要混淆目标和欲望\u003c/strong\u003e。合理的目标是你真正需要实现的东西，欲望则是你想要但会阻止你实现目标的东西。欲望通常是直接结果。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e调和你的目标和欲望，以明确你在生活中真正想要的东西\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e不要把成功的装饰误认为成功本身\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e永远不要因为你觉得某个目标无法实现就否决它\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e谨记伟大的期望创造伟大的能力\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e如果你拥有灵活性并自我归责，那么几乎没有什么能阻止你成功\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e知道如何对待挫折和知道如何前进一样重要\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e找出问题，并且不容忍问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e把令人痛苦的问题视为考验你的潜在进步机会\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e不要逃避问题，因为问题根植于看起来并不美好的残酷现实。\u003c/li\u003e\n\u003cli\u003e要精准地找到问题所在。\u003c/li\u003e\n\u003cli\u003e不要把问题的某个原因误认为问题本身。\u003c/li\u003e\n\u003cli\u003e区分大问题和小问题。我只做重要的事情。\u003c/li\u003e\n\u003cli\u003e找出一个问题之后，不要容忍问题。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e诊断问题，找到问题的根源\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e先把问题是什么弄明白，再决定怎么做。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e区分直接原因和根本原因\u003c/strong\u003e。在《肥胖代码》里面，你变胖的直接原因是你吃了很多东西，根本原因是胰岛素产生过多且持久。压力大会生成皮质醇，进而产生很多胰岛素。吃精致碳水会比同等卡路里的油脂更容易发胖，因为前者产生更多的胰岛素。一个人酗酒的直接原因是喝了太多酒，根本原因可能是遗传，也有可能是小时候的环境影响。\u003c/li\u003e\n\u003cli\u003e认识到了解人（包括你自己）的特性，有助于对其形成合理预期。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e规划方案\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e前进之前先回顾。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e把你的问题看作一部机器产生的一系列结果\u003c/strong\u003e。通过俯视你的机器并思考如何改变这部机器以创造更好的结果来从事更高层次的思考。你要站在更高的维度思考问题。\u003c/li\u003e\n\u003cli\u003e谨记实现你的目标通常有很多途径。\u003c/li\u003e\n\u003cli\u003e把你的方案设想为一个电影剧本，然后循序渐进地思考由谁来做什么事。\u003c/li\u003e\n\u003cli\u003e把你的方案写下来，让所有人都能看到，并对照方案执行。\u003c/li\u003e\n\u003cli\u003e要明白，规划一个好方案不一定需要很多时间。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e坚定地从头至尾执行方案\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e规划做得再好，不执行也无济于事。\u003c/li\u003e\n\u003cli\u003e良好工作习惯的重要性常被大大低估。\u003c/li\u003e\n\u003cli\u003e建立清晰的衡量标准来确保你在严格执行方案。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e谨记：如果你找到了解决方案，弱点是不重要的。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e考察你犯错误的类型，并识别你通常在五步流程中的哪一步上做得不好。\u003c/li\u003e\n\u003cli\u003e每个人都至少有一个最大的弱点阻碍其成功，找到你的这个弱点并处理它。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e影响合理决策的两个最大的障碍是你的自我意识和思维盲点。\u003c/p\u003e","title":"原则"},{"content":"源自于电影概论\n一、电影总览 八大艺术 来源于 Wikipedia\n八大艺术来源 八大艺术的分类来源已不可考，但有两个明显的现象是：\n人们提到八大艺术时，往往目的放在想要引介不在此艺术之中之物，例如新兴的游戏设计，有人指为第九艺术。 会提到八大艺术的理论，是因为摄影的发明对以后的各项科学、艺术、媒体及商业行为有巨大的贡献，也改变了人类以往的视觉经验，并进而衍生电影的发明，故变成第八艺术。 八大艺术列表 八大艺术包含：\n绘画 雕塑 建筑 音乐 文学 舞蹈 戏剧 电影 概览 电影经历过程 基本上，一部电影会经历三个阶段：制作(production)、发行(distribution)及放映(exhibition)。后面的数字化的售卖，是比较靠后的了，比如 DVD 版，放到各大视频平台售卖之类的。\n电影元素 光 色彩 声音 画面构图 镜头构图 电影创作过程 剧作 导演 表演 拍摄 剪辑 大部分的电影生产过程会经过四个主要的阶段，和上面的 MOOC 的对应了起来。\n编剧与集资（scriptwriting and founding）：电影观念开发完成，完成剧本。电影工作者也需要为拍片计划获得财务援助。 拍片准备（preparation for filming）：一旦脚本大致完成，且至少有了某些资金，电影工作就可以开始计划实体的生产过程。 拍摄（shooting）：电影工作者创造出电影的影像和声音。 组合（assmebly）：这些影像与声音组合成最终的形态，其中牵涉到剪辑图片与声音、执行特效、加入音乐或额外对白，以及加上标题名称。 这些阶段可能会相互重叠。后面会介绍，好莱坞的 “制片人中心制” 来详细介绍制片人这一角色，这里只是做个大概的介绍。总的来说，这四个阶段会产生几十种专业的分工。\n编剧与集资阶段 （The Scripting and Funding Phase） 核心人物\n制片（producer） 执行制片（executive producer）：通常负责安排财务与洽谈版权。 在线制片（line producer）：监管导演、演员与剧组的日常工作。由助理制片所指派。 助理制片（associate producer）：负责协调冲印厂或技术人员。 编剧（screenwriter） 制片主要负责财务及组织上的工作。如果是独立制片，则要去发掘拍片计划，并说服制片公司或赞助者出资，也可能雇佣制片人去整合项目计划。在编剧的过程中，制片还要照顾整个拍片计划、筹募资金、安排人事等。在拍摄及剪辑期间，制片往往是编导和出资者之间的桥梁。在电影完成后，制片通常还要安排发行、宣传、营销、以及监督成本的回收。单一制片或许可以接管所有这些工作，但一般不会这么做。\n剧本的完成会经历几个阶段。\n大致交代主要情节（action）的大纲（treatment） 一份货多份完整脚本 最后的拍摄脚本（shooting script） 有的电影，可能会有好几个编剧一起编写，或者制片直接换编剧写剧本，例如《异形：普罗米修斯》，其实换了好几个编剧。如果直拍呢货导演不满意某一个作者的剧本，可以雇其他做和加以修改。\n准备阶段（The Preparation Phase） 核心人物\n导演（director） 制片（producer） 选角总监（casting supervisor） 场景组（set unit）/ 制作设计组（production design unit）：场景的建筑与色调，绘制草图并进行规划。 设计总监（production designer）：以他为首，负责电影场景的视觉设计。 美术指导（art director）：负责监督场景的建造与与油漆。 陈设指导（set decorator）：通常具有室内设计的专长，负责根据特定拍摄需要而调整陈设，并监督找寻道具的人员。 布景人员（set dresser）：在拍摄时摆设道具。 服装设计（costume designer）：负责电影中所有戏服的设计与制作。 绘图师（graphic artist）：画分镜表（storyboard）类似于漫画，将每场戏的镜头绘制成草图，并就服装、灯光、摄影机运动做出提示。大部分导演并不要求所有场景都有分镜表，但是，关于需要特效或有复杂摄影机运动的情节段落与镜头，则需要有详细的分镜表。有了分镜表，摄影组和特效组便能初步了解完成后的镜头会是什么样子。分镜影像以拍摄剪辑的方式制作，并且配上音效协助场景的影像化，这就是一种动态脚本（animatics）。《曼达洛人》每一集后面都会有每个场景的绘图，很精致的草图，就是分镜表。 预视化团队（previsualization team） 这个阶段，导演其实是核心人物，当然制片也很重要。\n拍摄阶段（The Shooting Phase） 核心人物\n导演组（directors\u0026rsquo;s crew） 导演：知道演员表演，多数的导演会话许多时间讲解如何念台词或做动作，提醒演员这一场戏在全片当中的地位，并协助演员保持前后一致的表演。 演员（cast） 主要角色（primary actor ） 配角（supporting players） 路人、群众或临时演员（extras） 特技演员（stunt artist）：由特技教练（stunt coordinator）指导 场记（script supervisor）：负责每一镜头的连续性细节，还必须检查演员的外表，以及道具、灯光、动作、摄影机位置，与每一个镜头的时间。 第一助导（first assistant director，AD）：通常要负责与临时演员沟通，并调度群众场景。是万事通类型的人，与导演计划每日拍摄进度。根据导演指示，为每个镜头做拍摄前准备，并掌控演员、监督安全设施，以及维持拍片的士气。 第二助导（second assistant director）：担任第一助导与摄影组、电工组之间的协调工作。 第三助导（third assistant director）：担任导演与行政人员之间的传达工作。 对白员（dialogue coach）：为演员提词，或扮演不在镜头内的角色与镜头内演员对话。 第二组导演（second unit director）：在主要拍摄点的远距离外，负责拍摄特技动作、外景镜头与打斗动作等。 摄影组（photography unit） 摄影师（cinematographer）/摄影指导（director of photography，DP）：摄影师必须是摄影、灯光及掌镜专家。摄影师与导演会沟通每一场戏的灯光及拍法，以及负责监督以下人员。 摄影机操作员（camera operator）：负责开机、换片、对焦及跟焦、推轨等等。 场务领班（key grip）：领导场务助理（grips）搬运及放置设备、道具等场景及灯光器材。 灯光师（gaffer）：监督灯光位置与架设。 麦克风操作员（boom operator）：负责操控吊杆式麦克风（boom microphones），以及把无线麦克风藏在演员身上。 声效控制员（third man）：负责安置其他的麦克风，铺设音效电缆、控制环境音。 音效设计师（sound designer）：在前期制作便开始参与，为全片设计适当的声音风格。 视觉特效组（visual-effects unit） 视觉特效总监（visual-effects supervisor）：指挥视觉特效组，负责准备及执行枪击、模型、画面合成、计算机合成影像与其他技术镜头。在规划阶段，导演与制作设计总监会决定需要哪些特殊效果，而视觉特效总监则要随时与导演及摄影师沟通。 Model maker Matte artist 总务组（miscellaneous unit） 化妆师（makeup staff） 服装师（costume staff） 发型师（hairdresser） 在线制片（line producer）：负责管理日常性组织事务，如安排食宿等。 制片会计（production accountant; production auditor）：监督开销 制片秘书（production secretary）：协调单位与制片间的电话联系 制片助理（prduction assistants，PAs）：负责跑腿。一般而言，电影产业的新进人员通常由制片助理做起。 司机 组合阶段（The Assembly Phase） 后期制作（postproduction）\n剪辑师（editor）/剪辑指导（supervising editor） 声音剪辑师 作曲 导演 电影作曲者 电影类型 音乐歌舞片 喜剧片 西部片 武侠片 电影批评 将理论批评与创作批评结合，文本批评与审美批评结合，从叙事学、作者等层面较为全面的讲授电影理论的相关内容。\n电影流派 欧洲先锋派电影 苏联蒙太奇学派 意大利新现实主义电影 法国新浪潮电影 日本东方美学电影 香港新浪潮电影 台湾新电影 电影工业与电影产业 分别以好莱坞电影工业和中国电影产业为核心，介绍电影 “制作” “发行” “放映” 等环节在工业、产业体系中的发展与特点。\n光 通常称电影的拍摄为摄影（photography），电视的拍摄为摄像。\n摄影即用光来描绘和表现。\n魔术时刻\n是指日落前后约半小时左右，此时天空变成深蓝色或者红色（蓝移和红移），但是仍然可以清楚地照映出大地上景物的轮廓，此时所能够形成的电影画面效果，就仿佛是从天空架设了灯光照射到地面上。\n功能 外部引导功能 空间引导功能 空间光线的明暗变化，来进行叙事空间的转换\n时间引导功能 电影常常使用不同的时间光的变化，表示时间的流逝，从而形成光的时间引导功能。\n内部引导功能 光对电影情绪和氛围的影响 电影中的 “光” 可以分为 “高调光” 和 “低调光”。\n以 “高调光” 为主进行拍摄的影片中，往往场景的亮度充足，光影反差较小。因而多用于喜剧片、音乐歌舞片等情绪比较积极的电影类型中。\n例如大话西游，光线充足，人和物体都基本没有光影反差。\n以 “低调光” 为主拍摄的电影中，往往场景的亮度不足，光影反差也比较大。因此多用于黑色电影、犯罪片及类似风格电影。\n例如《教父》\n光作为电影中戏剧冲突的元素 通过光影的反差来表现人物与环境之间的冲突，人物之间的冲突或是人物自身的冲突等。\n光的种类 根据电影中光的方向可分为\n主光 背光 补光 主光 主光是最重要的光源，它会直接影响到电影画面的色温和亮度等，因此也常常被称为造型光或是基调光。\n对于同一场戏中的各个镜头而言，不论景别怎样变化，也不论实际拍摄的时间和地点有何不同，“主光” 的方位必须是统一的，而不能随意变化。\n在电影拍摄时，主光一般位于主体事物的斜前方。其主要作用是呈现电影画面中事物的基本面貌。\n背光 背光又称轮廓光，在进行电影拍摄时，一般处于主体事物的后上方，背光的主要作用是区分电影画面中的主体与背景，勾画被摄对象的轮廓并突出主体，从而使电影画面的影调层次更加富于变化，增加画面的美感。\n补光 补光又称辅助光，辅助光的光源可以是柔和的散光灯，也可以是反光板，在电影拍摄时，一般处于主体事物的正前方，且靠近摄影机的位置。\n主要作用是弥补主光的不足，照亮主光所不能照亮的侧面，控制画面中亮处和暗处之间的层次与反差，从而显示阴影部分的质感。即 “补光” 是帮助 “主光” 完成形象塑造的光线。\n“补光” 不能强于 “主光”，也不能干扰 “主光”。\n总结 这三种光的方式，被称作三点布光法，也是好莱坞最经典的布光原则。作为一种最简单且最为常见的布光方法，三点布光可以满足基本的电影拍摄要求。同时很多复杂的电影布光方法，也都源于三点布光。\n”三点布光“ 是构成电影布光的基石。\n色彩 色彩在电影中最初是作为一种虚构的视觉呈现，用来展示梦幻的感受，从而彰显出电影所独有的视觉表现手法。\n色彩的功能 信息功能 构图功能 情绪功能 信息功能 是指可以通过画面中的不同色彩来辨识事物。\n绿色的草地是春天的象征，金色的麦田代表着丰收，人体覆盖着白布则意味着死亡。\n构图功能 是指通过色彩在电影画面中的面积大小及其亮度的不同，所形成的艺术效果。\n情绪功能 “色彩的情绪功能” 与 “光对电影情绪和氛围的影响” 相仿。鲜艳明亮的色彩和 ”高调光“ 类似，多用于喜剧片、青春片、音乐歌舞片等类型的电影中。\n暗淡阴沉的色彩也与 “低调光” 类似，多用于黑帮片、侦探片等类型的电影中。\n色彩的种类 红色（刺激色） 红色对于人们的视觉来说，是一种刺激的颜色，它既能够激活生命力和激情，又能让人变得焦虑。同时红色也象征着权力，它既可以赋予好人权力，也可以赋予坏人权力，这取决于故事的需要。\n黑客帝国中的红蓝药丸，《天能》中的红蓝门，正时间和反时间。\n黄色（矛盾色） 黄色除了是热情与火热的象征，电影中的黄色也是一种矛盾的颜色，既可以提供线索，也可以进行警示。\n同时，黄色作为太阳的颜色，还能够让人们感受到强烈的生命能量。\n蓝色（知性色） blue 忧伤\n忧伤能使人思考。\n蓝色离知性最近，离感性最远。\n灰蓝色是色谱中最难引发欲望的颜色，绿蓝色显得更为活泼有激情。\n靓丽的蓝色可以代表广阔的天空，灰暗的蓝色则是压抑的象征。\n绿色（分裂色） 既代表希望生存与希望，也代表死亡与危险。尤其是在战争题材电影中，绿色作为分裂色的特点得到了最充分的诠释与应用。\n绿色是自然界常见的颜色，它的涵义也是丰富多元的。尤其是绿色作为矛盾色在电影场景中的恰当使用，就既可以增强画面的视觉冲击，又能够引发人们对色彩更多的思考。\n紫色（虚无缥缈） 在电影中，紫色作为一种虚无缥缈的颜色，紫色往往与非物质联系，预示着某人某事要发生变化或者是变异等。也就是说，电影中的紫色大多有着消失和逝去的意思。\n暗示幻想的破灭。\n电影构图 “电影构图”，是指为了表现一定的思想情感或意境氛围，在电影的空间范围内运用审美的心理形象，符号的位置关系等，而组成具有说服力的艺术整体。\n画面构图 镜头构图 画面构图 电影画面构图借鉴了许多绘画构图的表现手法，然而两者最大的差异，就是绘画构图的边框是丰富多元的，可以根据具体的画面内容和创作者的艺术理念进行不同形状的边框设计。\n《我不是潘金莲》，这个在刚开始看的时候，很奇怪，电影不能全部覆盖屏幕。\n采用了圆形画幅的边框设计，并以圆形和正方形交替出现的画面构图，来表现中国文化中的方圆理念。\n天圆地方，铜钱也是这个概念。\n电影画面包括\n主体 陪体 环境 空白 主体 主体并不一定要在画面的正中间，例如《大话西游》的至尊宝。《布达佩斯大饭店》是以绝对对称的画面构成。\n这里也借鉴了，黄金分割率的概念。\n电影画面中的顶部、底部或是左侧、右侧等边缘，往往是观众最容易忽视的区域。如果画面中的人物处于这些区域，一般是导演想故意造成某种隐喻，旨在暗示人物的软弱无力或无足轻重。\n《黄土地》画面中，都是在这些区域。\n线条 地平线 电影画面中的地平线具有烘托主体，加强视觉冲击和平衡画面的作用。\n处于画面下方的地平线则可以产生一种辽阔感，形成较强的主管视觉效果。\n处于电影画面上方的地平线，则能够产生一种纵深感，形成较强的宏观视觉效果。\n空白 “空白” 作为画面的重要组成部分，在具体电影画面中往往体现为“留白”。\n电影画面中的留白具有营造影片意境的作用。 电影画面中的留白还具有表现人物内心世界的作用。 电影画面中的留白还能够突出主体，增加视觉冲击力，并体现不同对象之间的呼应关系。 镜头构图 景别 景深 角度 运动 还有大全景、大特写、中远景、中近景等\n景别 “景别” 是指由于摄影机与被摄物体之间的距离不同，从而形成被摄物体在电影画面中的大小不同。电影中的景别主要有 “全景” ”中景“ ”近景“ ”特写“ 这四种最基本的类型，以及由这四种基本类型所延伸出的多元景别。\n全景\n“全景” 是指人物的全身或场景的全貌都在电影画面中。其主要作用就是交代环境。\n电影开场的全景镜头也可以称作 “建构镜头”。例如《阿甘正传》就是以全景镜头开始的。\n特点：既能够完整呈现人物的形体动作，又能够清楚的展示人物与环境之间的关系。\n中景\n“中景” 是指人物的大半身，即膝盖以上都在电影画面中。通常所说的 “膝上髋下” 镜头就是中景镜头。其主要作用是不仅可以让观众看清楚画面中人物的表情，而且有利于展示人物的形体动作。\n特点：能够有效增强画面的纵深感，表现出相应的环境与氛围，同时可以通过镜头的组接，平稳的叙述剧情。\n近景\n“近景” 是指人物的胸部以上，或者是物体的局部在电影画面中。主要作用是传达人物的内心世界，因此就成为刻画人物性格最有力的景别。\n特写\n“特写” 是指人物肩膀以上的头像或物体，动作的细节占据整个电影画面，环境和背景淡化。其主要作用是强调造型的渗透力，或形成某种心理暗示。\n特点：能够表现人物细微的情绪变化，使观众在视觉和心理上都能够收到较强的感染。\n景深 “景深” 是指电影画面所能够表现的前后左右的距离，即一个画面内部所反映的空间大小。\n大景深 小景深 “大景深” 是指电影画面纵深的清晰范围大（都是清晰的）。\n“小景深” 是指电影画面纵深的清晰范围小（突出主体，虚化陪体/环境/空白）。\n影响景深的因素： 摄影机镜头的光圈、焦距等。\n焦距越短，景深越大；焦距越长，景深就越小。\n角度 “角度”，就是指电影镜头的拍摄角度，通常包括 “平视角度” “仰视角度” “俯视角度“ 三种。\n平视角度 俯视角度 仰视角度 一般体现人物强弱关系，会用仰视角度拍摄强势的人，用俯视角度拍摄弱势的人。更具体的，可以参考博然讲电影的 “让子弹飞” 的拉片。\n平视角度 “平视角度”，是指摄影机处于人眼等高的位置。\n为了达到某种特殊的艺术效果，使用压低“平视角度”的高度，以儿童或者小动物的视角进行拍摄。\n俯视角度 “俯视角度”，是指摄影机处于视线的上方，即形成 “往下看” 的视觉效果。\n特点：使景物的层次分明，并且容易形成压迫感。\n凸显弱势\n仰视角度 “仰视角度” ，是指摄影机处于视线的下方，即形成 “抬眼看” 的视觉效果。\n仰视角度常常用来表现主体的力量感。\n如果是表现正面角色，则会有称赞、赞颂之意。\n如果是表现反面角色，则通常会形成一种威胁感或者是压迫感。\n电影镜头的运动 镜头的角度决定了电影的视点，镜头的运动则是电影的视觉呈现能够丰富多样充分彰显电影艺术表现力的重要因素。\n推 拉 摇 移 升 降 甩 跟 升、降、甩（基本没人用了）这几个是《电影批评》中补充的。\n推 “推” 是指沿摄影机光轴方向向前移动的接近式拍摄，其特点是电影画面由大景别连续过渡变小。\n主要作用：突出电影画面中心和细节，并强化视觉冲击。\n拉 “拉” 是指沿摄影机光轴方向向后移动的远离式拍摄；其特点是指画面的范围越来越大，被摄体也由单一变为多元。\n主要作用：让观众在看清主体的基础上，扩大所呈现的空间以便使更多的信息入画，从而有利于观众了解主体与环境，局部与整体的关系。\n摇 “摇”，是指摄影机的位置不动，只是角度变化；可以是 “左右摇” 或者是 “上下摇”，也可以是 “斜摇” 或者是 “旋转摇”。其特点是改变拍摄角度或拍摄对象，自由度和灵活性较强。\n主要作用：介绍环境，突出人物的行动目的和意义。\n移 ”移“ 是指摄影机沿水平的各个方向移动并同时进行拍摄。其特点是镜头的方向不变，而只是移动摄影机。\n主要是通过铺设轨道来实现移。\n主要作用：展示空间，因为它能够产生巡视的视觉效果，同时还可以把一些事物连接起来从而表现复杂的空间环境。\n跟 “跟” 是指摄影机始终跟随被摄主体进行拍摄。其特点是运动着的主体始终在电影画面中，从而可以连续且详尽的表现其活动情形。\n长镜头？手持摄像机？\n主要作用：能突出运动中的主体，又能交代运动的方向、速度和周围环境等。\n总结 推、拉、摇、移、跟这五种形式在电影的具体拍摄中，往往都是根据导演的叙事目的或者是艺术表现的需要等而混合交替地使用。\n声音 基本特性 类型 功能 基本特性 《视听》\n我们孕育于声音之中，诞生于视觉世界。\n电影孕育于视觉世界，诞生于声音之中。\n声音出现之后，电影才真正成为视听合一的艺术。\n声音作为进入电影的最后一个至关重要的元素，对电影艺术的成熟和完善有着决定性的作用。\n从物理学的角度来看，声音有三个基本特性\n音调 音色 音高 音调 🈯️声音频率的高低。\n音调高：轻、短、细\n音调低： 重、长、粗\n儿童声音的音调要比成人的音调高，女性声音的音调要比男性声音的音调高。\n音色 也称 “音品”，是指声音的特质和色彩。\n每一个人，每一种乐器和所有能够发出声音的物体的音色都不相同。\n音高 也称 “音量”。指人耳对听到声音大小、强弱的主观臆断感受。\n人们把对声音的感受量化为可以监测的指标，单位为 “分贝”（DB）。\n电影中，通过不同音高来变现不同叙事情景或是人物心理等。\n类型 人声 音效 音乐 人声 即指人的声音。\n电影中的 “人声” 分为 “对白” 和 “旁白”。\n“对白” 也称 “台词”，是指两人或多人之间的对话。\n“旁白” 则是指由电影画面外的人声对故事情节，人物心理等进行叙述或抒情议论，以传递更为丰富的信息。\n音效 也称 “声效”，是指由声音所制造的听觉效果。\n电影的 “音效” 包括 “环境音效” 和 “动作音效”。\n“环境音效” 指电影中自然环境的声音；\n“动作音效” 则是指人物动作或者物体所发出来的声音。\n音乐 “音乐” 作为电影声音的重要组成部分，是诠释影片的一把钥匙，好的音乐甚至可以助力一部影片的成功。\n”电影音乐“ 可分为 ”电影乐曲“ 和 “电影歌曲”。\n电影乐曲\n主题音乐 “主题音乐” 往往是一段完整的音乐，其能够表达一定的思想，感情和主题，同时能够贯穿剧情并统一电影风格，是电影的核心音乐。\n如《阿甘正传》的主题音乐 “在风中飘” （FORREST GUMP）。\n背景音乐 也称 “配乐” 或是 “伴乐”，是指在电影中作为背景衬托的音乐。\n作用：增强影片的情感表达，让观众有身临其境的感受。\n主题曲 指在一部电影中反复出现，表现主题思想或者概括影片基本内容的歌曲。\n如《亲爱的》结尾主题曲 “亲爱的小孩”。\n插曲 指穿插在电影中的短小乐曲，具有贯穿剧情的作用。\n总结\n电影音乐具有确立场景、突出感情色彩、增强故事流畅感、强化影片高潮的作用。\n功能 信息功能 内部引导功能 外部引导功能 信息功能\n指通过声音传达特定影片或故事信息。\n内部引导功能\n声音的内部引导功能，指声音在电影中对人物内心及情绪等的表现。\n电影声音的处理原则\n声音层次\n声音透视\n音桥\n画外声音\n声音蒙太奇\n首先，要根据声音在电影画面中的重要程度来处理声音的层次。\n处理好 “对白” “音乐” “音效” 之间的关系。\n如在人物对话中音乐的声音不要超过人声等。\n其次，在进行电影声音处理时还要主要声音透视的问题。\n“声音透视”，是指电影画面中相应的声音呈现要符合日常生活中，人们对声音的普遍感知经验。\n例如，人物靠近或远离时，声音要相应变大或者变小。\n进行电影声音处理时的一个特殊的手段：建立 “音桥”。\n有源声音 无源声音 有源声音\n指声音与电影画面中的一个声源互相联系。\n无源声音\n某种声音的声源没有出现在电影画面中，那就是 “无源声音”。\n“音桥” 即利用声音与画面中声源的关系形成镜头之间的连续性，从而使声音具有一种 “桥梁” 的功能。\n电影的声音处理还要注意 “画外声音” 的运用。\n“画外声音” 是指声源没有出现在电影画面中的声音。\n“画外声音” 可以使电影画面得以延伸。与音桥类似，可以表达出更多的信息。\n“声音蒙太奇” 即声音的剪辑。\n通过声音的排列或是组合表现特定的情感，产生更多的意义。\n剧作 一部电影的创作过程，大致要经历\n前期剧本写作 中期拍摄 后期剪辑 完成 剧作、导演、表演、拍摄、剪辑等。完成时间也从几个月到几年不等。\n剧本 电影文学剧本 电影分镜头剧本 电影完成台本 电影的基本组织结构 电影的最小单位：镜头\n镜头 —— 场 —— 情节段落 —— 剧本。\n电影文学剧本 即我们日常最容易接触到的电影剧本类型。\n作为电影创作的第一步，由编剧完成。\n“电影文学剧本” 要以 “场” 为单位进行写作。\n要明确标出每一场的 “场次” 及相应的 “场景”。\n具体文字表述，则与小说的语言比较接近，即要写出故事的详细发生发展过程和人物对话等。\n电影分镜头剧本 也称 “导演台本”，是在电影开始拍摄之前，由导演根据 “电影文学剧本” 创作完成。\n“电影分镜头剧本” 要以 “镜头” 为单位进行写作。\n不仅要详细标明 “第几场” 的 “第几个镜头”，而且要明确写出每一个镜头的 “景别”。\n《罗生门》第一个镜头讲解。\n电影完成台本 也称 “镜头记录本”，是在电影拍摄结束之后，由场记完成。\n电影剧本的运作方式 有两种\n先确定选题，然后再找编剧编写剧本。 制片商或导演看中了某个小说或是剧本的创意，便就出资购买相应版权，然后邀请原作者或其他编剧来创作剧本。 改编 改编是电影剧本的一个重要来源，根据相关数据全世界每年至少有一半的电影剧本都是改编而来的。\n总体来看，电影剧本的改编，主要有\n忠于原著 节选 复合 取意 颠覆 忠于原著 指电影改编保留原作的故事和人物，力求忠实于原著的内容。\n特点：将抽象的文字转化为具象的视听语言。\n节选 指将原著中最精彩的部分，或是相对完整的一段，提炼后进行改编创作。\n从其中抽出来一部分，删除多余的线索和人物，化繁就简的进行电影剧本创作。\n因为电影的时长有限，很多鸿篇巨制的文学作品不可能在 2 个小时左右的电影中完全呈现。\n如根据经典革命小说《林海雪原》截取了精彩片段，改编成了《智取威虎山》。\n复合 指将原本独立的两个或多个故事整合，从而形成一个新的作品。\n《罗生门》就是将日本作家芥川龙之介的两部小说《罗生门》和《筱竹丛中》进行复合。\n《皮绳上的魂》也是融合藏族作家扎西达娃的两部小说，《西藏，系在皮绳结上的魂》和《去拉萨的路上》\n取意 仅保留原作的人物关系活基本的故事框架，而进行新的剧本创作。\n《满城尽带黄金甲》就是取意自曹禺先生的经典话剧《雷雨》，只是将故事的背景改为五代十国，而人物设置和人物关系则与《雷雨》如出一辙。\n颠覆 指对原作进行彻头彻尾的改编，虽然有的仍然是用原作的名字，或是使用原作中人物的名字，但故事内容已经面目全非。\n《大话西游》这种系列，就是对西游的彻底的颠覆。\n导演 导演：电影的 “总工程师”\n导演需要参与的阶段\n前期筹备\n中期拍摄\n后期剪辑\n前期筹备阶段 首先就是对一部电影进行最初的构思，即在开拍之前形成自己的想法，并与编剧沟通修改剧本。\n建立剧组，即通常所说的 “建组”。\n通常会选用与自己有过合作的工作人员，旨在减少磨合的时间、提高工作效率。 如：王家卫与摄影师杜可风，侯孝贤与摄影师李屏宾。\n演员的挑选工作，根据影片中的角色设置和相关的剧情需要，挑选那些符合电影中的人物气质或是有过类似人物演出经验的演员。当然，某些导演也会经常会与某位演员合作，例如冯小刚的喜剧片中总会有葛优。宁浩的喜剧片中也总有黄渤的身影。\n中期拍摄阶段 中期拍摄是一部电影创作过程中持续时间最长的时期。\n导演在中期拍摄阶段身兼数职，是电影拍摄工作的主要组织者。指导摄影机前的演员表演，指导摄影、美术、录音等。\n后期剪辑阶段 与剪辑师一起进行影片的后期剪辑。即在剪辑师将素材按照 “分镜头剧本“ 进行 ”粗剪“ 的基础上，由导演参与进行 ”精剪“，并在历经多次的反复修改之后，最终完成一部电影的创作。\n后期剪辑师导演一次再次创作的过程。 因为可以根据所拍摄的素材和新的思考，对影片内容进行适当的调整。\n表演 目前全世界有两大表演艺术体系。\n斯坦尼斯拉夫斯基表演体系 布莱希特表演体系 还有观点将中国戏曲的表演艺术体系，即梅兰芳演剧体系列为世界上第三种表演艺术体系，指一种高度程式化的表演。\n斯塔尼斯拉夫斯基表演体系\n也称 “体验派”，创立者是苏联人斯塔尼夫拉夫斯基。\n其核心观点就是要求演员 “化身为角色”，并 “要有真正的情感体验”。\n《演员的自我修养》是真的有这本书，而且还是斯塔尼斯拉夫斯基写的。在全世界都影响非常的深远。\n**布莱希特表演体系 **\n也称 “间离派”，创立者是德国人贝托尔特·布莱希特。\n核心观点：要求演员与角色保持一定的距离，演员要高于角色、驾驭角色，要表现剧中的人物而不是融入人物之中。\n一部电影会有数量不等的演员参与演出，少则几个多则成百上千。\n演员 演员的分类，大致可以分为\n主角 配角 群众演员 客串演员 替身 特技演员 电影的发展之初，是借鉴了戏剧的表演手法，随着电影的发展成熟，其表演也与戏剧产生了明显的差异。\n电影表演的特点 电影的表演风格是生活化的 绝大部分电影都要求演员的表演要真实自然，同时随着现代科技发展出现的愈发细致入微的特写镜头等，更加要求演员的表演要真实自然。\n电影表演是 “导演的艺术” 戏剧表演是 “演员的艺术”，因为导演的所有构思都要由演员来完成。\n电影演员的表演，则更多的被掌握在导演的镜头语言中。\n电影表演呈现出一种 “镜头之美” 一方面因为电影演员面对的不是观众而是摄影机，于是就打破了舞台的封闭，另一方面蒙太奇等电影语言，也促成电影表演突破时空的限制。\n电影演员对作品具有不可支配性，同时表演过程还具有被迫中断性。\n在戏剧表演中，演员是主导，因为戏剧作品要依靠演员在舞台上的一气呵成；\n电影演员则需要根据实际情况在摄影机前不断的重复表演，并且随时可能被迫中断。\n拍摄 拍摄：电影语言的实现 。\n电影拍摄是以 “场” 为单位进行的，发生在同一场景中的要集中拍摄。以一部90分钟的电影为例，一般会有一百多“场”。如果把重复的场景合并计算，一部电影大概要拍摄三十至五六十场不等。\n一部电影的拍摄顺序，是先拍外景再拍内景。\n因为室外的天气复杂多变的，并且拍外景的时候，可以顺便搭内景。\n电影的拍摄顺序并不是按照故事的发生，发展过程，也不是按照电影剧本的顺序，而是遵循 “先外景后内景” 的拍摄原则。\n电影拍摄方式 电影的拍摄还有几种非常规的方式\n顺序 无剧本拍摄 偷拍 顺序 是指完全按照故事的发展顺序进行电影拍摄。\n受制于演员的档期、天气的变化、场地的租用等限制。\n无剧本拍摄 指导演在没有剧本的情况下进行电影拍摄。\n《重庆森林》《堕落天使》等都是无剧本的情况下拍摄完成的。\n偷拍 偷拍在电影创作中并不十分常用。\n也有导演采用偷拍的方式，以实现电影场景的真实与原生态。\n如张艺谋的《秋菊打官司》。\n场记 是电影拍摄过程中非常重要的一项工作。\n主要人物是在电影拍摄的同时，记录现场的一些注意事项；\n电影画面相关信息。\n如道具摆设人物站位等。\n演员的服装配饰。\n人物对话的改动。\n剪辑 剪辑过程 一般来说，一部电影要经历三次创作过程。\n第一次\n是编剧编写剧本，即以文字塑造电影的视听形象。\n第二次\n是导演执导拍摄，是用摄影机把文字幻化为影像，并以胶片或者数字的形式进行保存。\n第三次\n剪辑师剪辑素材，是让电影真正成为可以放映的影像。\n剪辑的过程一般来说分为下面几步：\n选择镜头 制定剪辑方案 初剪 复剪 精剪 综合剪 选择镜头 一部 90 分钟的电影，往往会拍摄几百甚至上千个镜头。 而所有的素材累积在一起，至少也有十多个小时，因此，剪辑工作的第一步就是对镜头进行选择。\n制定剪辑方案 结合之前所选择的镜头，根据剧本制定剪辑方案，从而完成剪辑工作的蓝本。\n初剪 也称 “粗剪”，是指根据 “分镜头剧本” 完成剪辑初稿，形成电影的雏形，即一个没有特效和音乐的版本。\n复剪 复剪是在初剪基础之上进行的更为精细的剪辑，进而使影片逐渐定型。\n精剪 即在复剪基础上的再次查漏补缺。\n综合剪 主要就是调整、增加镜头或者片段，最终完成一部可供放映的电影。\n也是导演和剪辑师在影片创作过程中的最后冲刺。\n蒙太奇 原为法国建筑学名词，意为 “组装、装配 ”。\n指把电影所要讲述的故事分为若干个场景拍摄，然后再进行组接，从而形成一个具有逻辑顺序的艺术整体。\n蒙太奇的发展 卢米埃尔时期 梅里爱时期 格里菲斯时期 卢米埃尔时期 在电影刚刚出现时，还没有剪辑的概念。\n当时的一个镜头就是一部电影，时间长度大约在一分钟左右。\n梅里爱时期 电影引入了许多戏剧的创作理念，剪辑也是针对没有景别转换的固定取景。\n格里菲斯时期 电影摆脱了戏剧观念的束缚，成为一门真正独立的艺术。\n首次使用了分镜头。\n让摄影机运动起来。\n首创了叙事蒙太奇。\n剪辑的艺术功能 表现电影的叙事和时空 表现电影的思想和情感 表现电影的运动和节奏 表现电影的叙事和时空 故事时间 电影时间 故事时间：指电影中所讲述的故事的实际发生时间。\n可能是一天、一年，或者是许多年。\n电影时间：是指电影讲述这个故事所需要的时间。\n即电影的时长，一般 “电影时间” 都在 2 小时左右。\n《敦刻尔克》天上一天，地上一年。\n“故事时间” 和 “电影时间” 有下列三种关系：\n第一种：故事时间 \u0026gt; 电影时间。最常见\n第二种：故事时间 \u0026lt; 电影时间。《罗拉快跑》\n第三种：故事时间 = 电影时间。非常少见，例如《正午》\n任何一部电影都离不开剪辑，是剪辑形成了电影的戏剧冲突，强化了电影的艺术表现。\n音乐歌舞片 电影类型片\n“类型片” 是指按照不同类型的规定而生产出来的影片。作为好莱坞大制作厂标准化生产的产物，“类型片” 以 “制片厂制度” 为基础，以追求经济利益最大化为目的。\n类型片有三个最基础的元素\n公式化的情节 定型化的人物 图解式的视觉形象 在世界百余年的发展历程中，主要形成了\n音乐歌舞片 喜剧片 犯罪片 战争片 科幻片 等电影类型。\n概念 “音乐歌舞片” 是指以音乐舞蹈作为一部影片的观看中心，音乐和舞蹈共同进入叙事并成为叙事核心的电影类型。\n也是好莱坞历史最悠久，特征最明确的类型片。\n主要模式 第一种电影的叙事时空完全舞台化。\n人物和故事情节等都处于虚构的环境中。\n如\n《雨中曲》《西区故事》《红磨坊》等。\n第二种是影片有着较为写实的叙事时空，音乐歌曲是主人公的表演展示。\n歌舞表演与电影叙事之间有着较为明晰的界限，音乐歌舞只是构成电影叙事的一部分。\n《红菱艳》《名扬四海》等。\n第三种是上述两种模式的并存。\n既有随性而起的歌舞表演作为电影叙事的一部分，又有明确的歌舞表演段落。\n《音乐之声》\n发展 20 世纪 30 年代 音乐歌舞片的 “黄金时代”。\n特点：“后台” 歌舞片\n以 后台 矮星故事为核心，主要讲述年轻女孩成名的故事。\n代表作品是 1933 年的《第四十二街》\n该片表现了正统爵士、踢踏舞的节奏韵律和动作美感，成为音乐歌舞片 “黄金时代” 的标志。\n音乐歌舞片之所以在上世纪 30 年代的好莱坞迎来黄金时代，主要有几方面原因：\n社会原因 当时美国社会刚刚经历过前所未有的经济大萧条，社会矛盾激化，而音乐歌舞片中的歌舞升平，则能够为观众提供高质量的娱乐。\n“海斯法典” 的颁布 1930 年著名的 “海斯法典“ 颁布后，电影中性和暴力的内容受到严格限制，于是音乐歌舞片的数量便开始剧增。\n20世纪 40-50 年代 特点：\n受第二次世界大战的影响，观众对音乐歌舞片的兴趣降低，影片的数量也随之减少。\n呈现出以乐观叙事为主的特点。\n代表作\n《一个美国人在巴黎》《雨中曲》\n20 世纪 60 年代的音乐歌舞片 进入 60 年代之后，由于电视强烈冲击，好莱坞为了留住电影观众，便投入更高的成本拍摄场面豪华、明星云集的音乐歌舞巨片，于是一批根据百老汇歌舞剧改编的影片便应运而生。\n如《窈窕淑女》《音乐之声》《西区故事》\n20 世纪 70-80 年代的音乐歌舞片 背景：\n西方社会的大变革时期：“嬉皮士运动” 的影响不断蔓延，“迪斯科” 也风靡全世界。\n特点：\n“青春派” 音乐歌舞片便在这一时期开始繁荣；更加突出镜头的跳跃与连接。\n代表作 1982 年的《迷墙》\n真人动画的超现实音乐歌舞片。\n20 世纪 90 年代以来的音乐歌舞片 特点：\n类型杂糅、风格多样。\n《舞出一片天》以芭蕾和嘻哈，演绎白人和黑人之间的爱情故事。还有《红磨坊》《芝加哥》等反映美国社会问题的音乐歌舞片。\n西部片 “西部片” 是指以美国西部拓荒为背景，以美国西部的荒野、小镇、牛仔和马尾主要视觉场景，反映文明与蛮荒、个人与社会、本民族与异域文明之间冲突的影片。\n作为美国文化的典型代表，西部片产生于美国并主要在美国拍摄。其故事大多来源于美国西部文学或相关历史事件。作为典型的电影类型片西部片具有明确的类型片三要素：\n公式化的情节 西部片的情节几乎都是警察、牛仔等孤胆英雄对抗印第安人、匪徒等恶势力，并最终取得胜利。\n定型化的人物 正面人物：牛仔、淑女\n反面人物：亡命歹徒、印第安人\n中间人物\n图解式的视觉形象 山谷、沙漠、荒凉的小镇或印第安营地，是西部片不变的外景；\n简陋的驿站、酒馆、小木屋则是西部片不变的内景。\n左轮手枪、马匹、皮裤、牛仔帽等也是西部片反复出现的道具。\n西部片色彩和画面构图特点：\n大量使用黄色调。\n画面构图风格粗狂，多使用广角镜头，并讲究地平线的使用。\n“意大利西部片” “通心粉西部片”\n特点：\n印第安人的形象销声匿迹。\n美国西部片往往在影片中大量呈现雄伟壮丽的美国西部自然风光，且以全景和远景镜头居多。\n相比之下，意大利西部片由于大多没有在美国拍摄，因此就较少呈现自然景观。\n多以变焦镜头和景深镜头为主，同时大量使用特写镜头。\n还有配乐方面\n美国西部片习惯使用传统的管弦交响乐，旨在呈现一种磅礴的气势，并使影片具有一定的史诗气概。\n也有的使用民谣风格的插曲，旨在给影片增加一种忧郁的气质。\n意大利西部片的配乐则更为强烈，极富抒情性和感染力。\n美国西部片代表作《荒野大镖客》《黄昏双镖客》《黄金三镖客》\n意大利西部片代表作《姜戈》\n暴力美学《被解救的姜戈》\n西部片发展史 20世纪 30 -60 年代\n《关山飞渡》改编自莫泊桑的《羊脂球》\n《红河》\n20 世纪 60-70 年代\n日薄西山了\n《安邦定国志》、《小巨人》\n《狼城脂粉侠》、《虎豹小霸王》\n20 世纪 70-80年代\n被遗忘\n《天堂之门》\n20 世纪 90 年代\n重现辉煌\n1990 年，由科斯特纳自导自演的《与狼共舞》，以一种正确的态度面对历史，并为印第安人正名，该片获得奥斯卡 7 项大奖。\n《不可饶恕》\n21 世纪之后的西部片\n特点：传统的西部片的类型元素减少、新类型元素不断增加的特点。\n《狂风沙》\n中国西部片 概念 以展示自己国家西部独特的历史文化、讲述西部故事为主要特征，具有鲜明的地域特色。\n美国西部片的主体几乎都是征服于占领，而中国的西部片的主题则是发展与进步。\n美国西部片的主角大多是英雄，而中国的西部片的主角则多为生活在西部的普通人，影片也主要关注个体的生命际遇。\n美国西部片属于商业类型片，中国西部片则属于现实主义电影。\n集中出现在新时期以后。\n主要类型有四\n讲述中国西北黄土高原和黄河沿岸人们生活的影片。 《人生》《老井》《黄土地》《秋菊打官司》等 反映西部少数民族生活和相关宗教题材的影片。《猎场扎撒》《盗马贼》《黑骏马》《东归英雄传》《静静地嘛呢石》《冈仁波齐》 讲述我国西部沙漠戈壁传奇故事的影片。《新龙门客栈》《双旗镇刀客》 演绎西部地区的故事，并带有强烈商业色彩的影片。《红河谷》《黄河绝恋》《天地英雄》 发展 奠基期 徘徊期 发展期 成熟期 《大红灯笼高高挂》\n《可可西里》（巡山队）\n《三枪拍案惊奇》（是真的无聊）\n《无人区》《一个勺子》\n喜剧片 概念 所谓喜剧片，是指以产生笑的效果为特征的电影类型。\n特点：\n多元的 “笑”。\n有的讽刺丑恶落后，有的歌颂光明美好。\n其目的都是为了让观众在笑中得到愉悦，或是在笑中获得启发。\n类型 主要类型\n浪漫爱情喜剧 讽刺喜剧 闹剧 轻喜剧 浪漫爱情喜剧 《一夜风流》《罗马假日》\n都是通过误会、巧合等演绎出令人难忘的浪漫爱情故事。\n《风月俏佳人》《西雅图未眠夜》《四个婚礼和一个葬礼》\n《北京遇上西雅图》（？？？？？深受观众喜爱吗？）\n讽刺喜剧 “讽刺喜剧”，是指以尖锐的讽刺和嘲笑，揭露、抨击现实中不好的事物。\n喜剧外表下潜藏着的讽刺，则是对社对人生更深层思考。\n《淘金记》《摩登时代》\n《驴得水》（确实是近代国内的上乘之作）\n闹剧 “闹剧” 往往采用大量的插科打诨，具有荒唐意外的情节，人物形象也是高度夸张或是十分滑稽。\n《憨豆先生》囧系列电影\n轻喜剧 虽然喜剧味道不是很浓，但却会让人感到温馨，同时能够反映某些社会现实。即让观众在发出会心笑声的同时进行思考。\n**《甲方乙方》《私人订制》**针砭(bīan)时弊\n1997 年过去了，我很想它。\n地主家也没有余粮了啊。\n西方喜剧片的发展 启斯东电影公司。\n《启斯东警察》\n一 20 世纪 30 年代：“社会喜剧” 特点：\n具备较为强烈的社会意识，强调电影的戏剧结构和文化品位。\n刘别谦《少奶奶的扇子》\n二 20 世纪 50 年代：“两性喜剧” 特点： 强调两性意识和现实感。\n《热情似火》\n三 20 世纪六七十年代的个性喜剧 特点：\n强烈的个性化\n《安妮·霍尔》《发条橙》。。。\n《毕业生》、《斯卡布罗集市》《寂静之声》\n四 20世纪 80 年代以来的喜剧片 特点：\n更加符合时代发展和社会语境。\n中国喜剧片的发展 一、第一部喜剧片 现存最早的一部中国电影：1922 年 “明星电影公司” 出品的喜剧片《劳工之爱情》。\n二、1949 年之前的中国喜剧片 特点：\n呈现出抨击社会黑暗，批判封建礼教，追求个性解放和婚恋自由的主题。\n《月老离婚》《四月里底蔷薇处处开》《呆中福》\n三、“十七年” 讽刺喜剧 歌颂喜剧 轻喜剧 《五朵金花》《今天我休息》\n《大李、小李和老李》《锦上添花》《魔术师的奇遇》\n四、新时期以后：多样化的喜剧片 改革喜剧——主要反映改革开放之初的新生活和新状态。《车水马龙》《赵钱孙李》《愁眉笑脸》《生财有道》等 荒诞喜剧——以黄建新导演的 “赵书信两部曲” 为代表。《黑炮事件》《错位》《顽主》。1988 年的《顽主》 是中国喜剧电影从传统走向现代的标志。传统喜剧片以辛辣的讽刺和滑稽的情趣为特点；而现代喜剧片则渗透着悲凉、绝望和黑色风格。 系列喜剧 ——陈佩斯和陈强父子主演的 “二子系列”《二子开店》，以及上海导演张刚创作的反映社会问题的阿满系列《面目全非》、《笑出来的眼泪》 动作喜剧——代表作品：成龙的 “功夫+喜剧” 电影。特点：喜剧和动作在影片中占有同等重要的位置。《醉拳》《警察故事》《快餐车》 无厘头喜剧——代表人物：周星驰。特点：以无限夸张的喜剧桥段表现社会的冷漠或人性的丑陋，通过刻画底层小人物的遭遇让观众在笑中带泪。《喜剧之王》《食神》《少林足球》等 。 贺岁喜剧—— 代表人物：冯小刚。特点：采用市民文化策略表现普通百姓的悲欢。《甲方乙方》《不见不散》《没完没了》《私人订制》等。 侦探喜剧——融合了悬疑、喜剧、推理、惊悚、爱情等各种商业元素。代表作：宁浩的疯狂的系列，王宝强主演的唐人街探案系列。《疯狂的石头》《疯狂的赛车》《唐人街探案1》《唐人街探案2》。唐人街探案系列当让你爽的电影看就好了。 武侠片 概说 一、概念 “武侠片” 又称 “功夫片” 或者 “武术片”，是指以中国功夫和武侠传奇为主要表现对象的电影类型。\n作为唯一一种由中国首创，并主要由中国拍摄的电影类型，武侠片以其独有的艺术魅力和娱乐风格。在中国电影发展史中具有无法取代的历史地位和现实意义。\n二、“武侠片” VS ”动作片“ ”动作片“ 是指以人或机械的动作为主要形式，表现基本的社会价值观，满足大众相关审美需求的电影类型。\n《极速飞车》《速度与激情》等。也就是说 “动作片” 包括 “武侠片”，“武侠片” 是一种以人的动作为主的 “动作片”。\n三、中国第一部武侠片 1925 年由 “天一电影公司” 出品的 《女侠李飞飞》 是我国第一部武侠片。\n还创造了一个行当：武术指导。\n二 武侠片关键词：“武术指导”\n几乎所有的电影行当都是由外国人创立的：制片、编剧、导演、摄影、美术、服装、道具等。\n代表人物：刘家良、袁和平 、程小东。\n《杀死比尔》袁和平\n《忍者神龟》刘家良\n“武术指导” 也称 “动作指导” 或 ”武术设计“。\n最早出现： 1928 年的《火烧红莲寺》 确立：第一次创作热潮，即 1928-1931 年间，“武术指导” 开始作为固定的职务确立下来。 发展：上世纪 50 年代，几乎每一部武侠片中都有 “武术指导”。 成熟：60 年代，得益于 “邵氏” 武侠片的繁荣，“武术指导” 的作用愈发凸显。 快速发展：70 年代之后，由于武侠片客观的经济效益，“武术指导” 的待遇也水涨船高。 武侠片的分类 神怪传奇类武侠片 人物传记类武侠片 古装刀剑类武侠片 功夫技击类武侠片 谐趣喜剧类武侠片 魔幻神话类武侠片 神怪传奇类武侠片 神怪传奇类武侠片的历史最为悠久，其以我国民间的神圣武侠文学为原型，且主要依赖特技技术。\n1982 年的《火烧红莲寺》\n《倩女幽魂》《青蛇》\n人物传记类武侠片 人物传记类武侠片与我国历史上的多位武术家密切相关。\n《方世玉》《霍元甲》《黄飞鸿》\n在百余年的历史上，截至目前共拍摄了 105 部 “黄飞鸿电影”，创造了世界电影史的一个记录。\n《叶问》《一代宗师》（念念不忘，必有回响）\n古装刀剑类武侠片 古装刀剑类武侠片繁荣于 20 世纪 60 年代，并形成了中国武侠电影的第二次创作高潮。\n《独臂刀》《碧血剑》\n《龙门客栈》《大醉侠》《侠女》\n功夫技击类武侠片 功夫技击类武侠片是最接近中国功夫的武侠电影类型，其特点是以真功夫折服观众，并强调武侠和武德。\n李小龙\n《唐山大兄》《精武门》《龙争虎斗》《猛龙过江》\n谐趣喜剧类武侠片 20 世纪 70 年代，随着中国电影的商业化发展，最具商业价值的喜剧元素开始进入武侠片，并形成了将喜剧夸张表演与武打动作结合的谐趣喜剧类武侠片。\n成龙\n《蛇形刁手》《醉拳》\n魔幻神话类武侠片 是在电影技术发展的前提下，以虚拟数字技术为特征，以虚构故事为内容的武侠电影类型。\n《蜀山：新蜀山剑侠》《蜀山传》\n武侠片的经典场景 盘肠大战 竹林大战 飞檐走壁与凌波微步 客栈大战 舞狮大战 盘肠大战 最早出自于中国古典戏曲《界牌关》。后来被武侠片借用，其中以张彻的 “阳刚电影” 为主要代表。\n《大刺客》\n（暴力美学）\n竹林大战 《侠女》《白发魔女传》《青蛇》《卧虎藏龙》\n《十面埋伏》不是也是么。\n《英雄》对竹林大战进行了改造，“胡杨林大战”。\n飞檐走壁与凌波微步 吊威亚来实现。\n“威亚”，即英文单词 “钢丝” 的音译。“飞檐走壁” 和 “凌波微步” 都采用 “吊威亚” 的方式，只是通过不同的落点来形成不同的视觉效果。\n客栈大战 客栈大战作为一种极具中国文化特色的电影场景，体现了武侠电影创作对中国传统戏曲空间表现手法的借鉴，即突出空间的舞台化。\n《大醉侠》《龙门客栈》《卧虎藏龙》\n舞狮大战 由于早期的 “武术指导” 多为 “龙虎武师”，于是就促成了舞狮与武侠电影创作的结合。\n体现了武侠片对中国传统文化的借鉴与汲取，从而彰显出中国武侠电影的民族文化气质。\n本文分析：电影的视听语言与叙事形式 电影造型性、运动性与节奏 电影批评的职能 认识影片物质形态，提示影片价值要点；\n呈现电影知识系统，辅助未来创作改进；\n促进影人与社会互动，提升观众审美能力。\n如 安德烈·巴赞\n电影批评的专业素养 能够运用专业知识、审美经验和批判意识打开观众视野。\n如何获得专业素养。\n解读电影视听语言与叙事形式的本文分析是非常重要的一种批评方法。\n重点：探讨电影的造型、运动性与节奏。\n镜头的内部元素：\n色彩 光线 画面构图 声音 都具有造型的功能。\n运动又有：\n被拍摄物体的运动 摄影机的运动 综合运动 《修女艾达》\n黑白色彩赋予影像一种理性，让观众思考艾达的选择。\n在构图上，艾达往往处于画框右侧或左侧底部，这是在表明人物尚未摆脱历史与现实的束缚。\n“阴阳脸” 高反差布光象征她在宗教和尘世之间犹豫徘徊。绝大部分镜头是固定镜头，这是在象征表达艾达还没有确定自己的未来。但在电影的结尾，当艾达确定了自我追求后，电影是一个运动的长镜头结束故事，电影由此展现出一个修女自我意识的觉醒。\n电影节奏 内部节奏 外部节奏 内部节奏\n由多种因素综合而成，如事件和情节的安排，以及场面调度。\n外部节奏\n主要指向镜头的剪接。它受到镜头的长度和幅度两个元素影响，长度指镜头时长以及镜头所表现内容的时间延续感，幅度则指的景别。\n1966 年《一个男人和一个女人》《这个杀手不太冷》\n《这个杀手不太冷》在杀手出场的时候，用了 19 个镜头，这 19 个镜头全部都是特写镜头固定镜头，并且每个镜头的时长都比较短，从而营造人物的神秘和迅捷。\n《你从未在此》 关注一个男人如何走出童年暴力与战争所带来的心理创伤。\n电影片名出来之前，电影开始的这个部分，安排了三场戏。\n蒙太奇与场面调度 特写与全景 固定于运动 跳接：\n跳接指的是两个镜头内的主体相同，而摄影机距离及角度上差距不大，当两个镜头连接在一起时，在银幕上便会明显地跳一下。\n喜剧之王在向柳飘飘表白，也是用的跳接， 用了两个周星驰的特写镜头，来表明主人公忐忑不安的心理。\n电影作者论与文本细读 电影作者论 时间上追溯到 1948 年 3 月 30 日。地域上追溯到法国。\n摄影机——自来水笔：新先锋派的诞生。\n它意味着电影必将逐渐挣脱纯视觉形象、绝画面、直观故事和具体表象的束缚，成为与文字语言一样灵活、一样精妙的写作手段。\n—— 阿斯特吕克\n《糟糕的相遇》\n后来女演员又主演了《一个男人和一个女人》\n巴赞《论作者策略》\n其实一个导演的作品时参差不齐的，比如导演奥逊威尔斯，他的《公民凯恩》开启了美国电影的新时代，《阿卡丁先生》只是一部二流作品。\n王家卫的家和卫 按时间排序\n《旺角卡门》 《阿飞正传》 《东邪西毒》 《重庆森林》 《堕落天使》 《春光乍泄》 《花样年华》 《2046》 《蓝莓之夜》 《一代宗师》 王家卫电影的秘密就在他的名字当中，家与卫有着先锋前卫的影像，注重日常生活细节的叙事，从而给人以奇异而熟悉的感觉。\n《阿飞正传》\n拒绝与逃离，沉迷与顿悟。\n《春光乍泄》\n跳接\n《花样年华》\n情调与母题的集合体 《2046》\n用不同的背景音乐来配合人物出镜。\n越轴，预示不好的场景。关于越轴，在《电影批评》中有介绍。\n天台的镜头。带花的和不带花的，表现得不一样。\n类型成规与现实经验 电影的范式与革新 安德烈·巴赞把类型电影称为一种寻找内容的形式， 可以从以下三个维度来理解。\n制作者 影片 观众 类型电影一般具有\n公式化的情节 定型化的人物 图解式的视觉 基本的价值理念和道德观念 《侠骨柔情》\n《青少年警队》反警匪类型的创作踪迹 淡化类型惯例，放大现实生活经验从非写实转向写实，这是很多反类型电影的一种创作方法。\n1994 年《这个杀手不太冷》的饰演的风尘女子的角色，麦温。当时是导演吕克贝松的女友，后来自己也成为了导演。《青少年警队》就是她的作品。\n正如巴赞所指出的：\n电影好比女引座员拿着的小手电筒，那摇曳的灯光像闪烁不定的彗星，划过我们醒着做梦的黑夜，那是银幕周围向四面扩展的漫无边际的空间\n叙事学理论与英雄冒险历程 电影叙事学的两种走向 借用格雷马斯的理论探讨对影像中的叙事结构。 借用热内特的叙事角度学说，探讨水在叙述的问题。 普罗普《民间故事形态学》\n对民间故事的叙事功能进行研究，提炼出七种行动范畴和六个叙事单元。\n格雷马斯则提出六个动素和一个意义矩阵。\n《第五元素》《功夫熊猫》《银河护卫队》都可以按照这个理论来解读。\n准备单元 纠纷单元 转移单元 抗争单元 归来单元 接受单元 《罗生门》举例\n王牌特工·特工学院 受到普罗普的影响，神话学家坎贝尔在他的著作《千面英雄》 对神话传统进行了分析，得出了一种叙事模式。\n一个从平凡世界召唤出来，并踏上冒险旅程的英雄，他进入到一个既有盟友也有敌人并且充满磨难的世界，最后英雄要到达一个隐秘的洞穴，这样一个接受终极考验的场所，胜利之后英雄回归到发生改变的日常生活中。\n很多电影都是这样的一个叙事。\n例如《王牌特工·特工学院》\n特工电影分为两类：\n一、非写实的戏剧情节\n007《谍影重重》系列\n二、类型片融入大量现实经验，毫无高科技与绚丽的动作。\n英国 70 年代《义普克雷斯档案》。\n母题\n电影里任何有意义且重复出现的元素。\n母题可能是物品、颜色、地点、声音，也可以是打光法或摄影机的位置。\n欧洲先锋派电影 欧洲先锋派电影运动 概说 欧洲先锋派电影运动是指上世界 20 年代出现在欧洲的一次实验电影运动，其以法国和德国为中心，同时涉及意大利、英国、法国等多个欧洲国家。\n欧洲先锋派电影运动的发展阶段\n第一先锋派电影 第二先锋派电影 第三先锋派电影 第一先锋派电影\n即印象主义阶段，主要以 “法国印象主义电影” 为代表，从 1917 年到 1929 年贯穿 “欧洲先锋派电影运动” 的始终。\n印象主义\n设法忘掉你前面的物体，准确地画下你所观察到的颜色和形状，直到达到你最初的印象为止\n——莫奈\n第二先锋派电影\n即超现实主义阶段，主要以 20 年代的 “法国超现实主义电影” 和 “德国表现主义电影” 为核心。\n第三先锋派电影\n即记录电影阶段，主要活跃于 1927 年至 1930 年间，指由卡瓦尔康所创立的 “记录电影流派”，以他在 1926 年拍摄的记录电影《只有几小时》为标志。\n背景 出现于 20 世纪 20 年代，与当时的科技发展、文化思潮、社会背景，以及电影自身的变革需求等紧密相关。\n电影技术的进步 从第一次世界大战结束到 1929 年资本主义世界爆发的大规模的经济危机之前，欧洲国家经历了一段相对稳定的和平发展时期，这一时期的科技进步，为电影的发展奠定了良好的物质基础。\n摄影机、胶片、灯光设备等都取得了长足的进步。\n现代主义思潮 第一次世界大战在欧洲思潮文化界引发了巨大的反应，人们开始怀疑甚至否定以往的社会观念和精神文明成果，于是现代主义思潮在 19 世纪末快速发展。\n以弗洛伊德的精神分析学说影响最大，其间接促成表现主义电影和超现实主义电影的出现。\n工业革命的冲击 工业革命使现代机械逐渐取代了人在社会生产中的地位，人们越来越深的感受到工业化的压抑与制约，因此追求个人化的表达，也就成为了一种新的社会发展趋势。\n“欧洲先锋派电影” 也是电影自身发展所必然要经历的一个阶段。 第一次世界大战之后，欧洲大多数国家的电影市场都被好莱坞占据，欧洲电影在艺术上几乎停滞，并呈现出较为严重的商业化倾向。\n卡努杜与 “第七艺术”。\n可以说，欧洲先锋派电影运动在一定程度而言，就是努力将电影发展为一门独立艺术的探索与实践。\n第一先锋派 “印象主义” 与 “印象主义电影” 第一先锋派是指以法国为中心的 “印象主义电影”。\n“印象主义” 最早出现于绘画，由法国画家莫奈的《日出印象》为代表的绘画流派。\n“印象主义” 绘画主张以色调的分离、色彩的闪烁等手法来表现对大自然的主观印象，反对当时思想保守、题材僵化和手法老旧的学院派绘画，提倡革新与突破。\n法学电影史学家朗格卢瓦首先在电影中使用 “印象主义” 一词。\n德吕克、杜拉克、莱皮埃、冈斯为代表的电影流派。\n特点 电影表现内容 “印象主义电影” 认为，电影作为艺术家表达自我的情感场所，要描写人物的内心细微变化。\n1919 年德吕克和杜拉克联合创作的电影《西班牙的节日》\n电影的摄影技巧 “印象主义电影” 的导演们在创作实践中积极使用各种新的摄影技巧，旨在以新的摄影手段表现人物的心理状态。\n代表作 1922 年冈丝拍摄的电影《车轮》\n科技的进步也带来了电影器材的发展 “印象主义电影” 的导演们在创作实践中积极使用各种新的摄影技巧，旨在以新的摄影手段表现人物的心理状态。\n1927 年，冈丝的《拿破仑》就使用了最新的摄影机镜头和宽格画面。\n评价 以 “印象主义电影” 为核心的 “第一先锋派”，在电影的心理表现、摄影镜头的运用、后期剪辑等方面的探索和实践，极大丰富了电影的表现能力，这些创新也成为了当时法国电影与好莱坞抗衡的手段。\n1924 年德吕克去世后，“印象主义电影” 开始逐渐解体：其中一部分人转向拍摄商业电影，另一部分则选择与商业电影彻底决裂的先锋派道路。\n到 1929 年，“印象主义电影” 基本停止创作。\n第二先锋派（理论基础） 主要特点\n超现实主义\n相关概念\n“立体主义” “未来主义” “达达主义” 立体主义\n最早出现于绘画领域，其特点是反对传统的写实主义，注重形式，强调表现人对外界事物的主观印象和感受。\n先有作品而后进行理论归纳。\n纯电影\n抽象电影\n未来主义\n先有理论的提出，然后由理论指导创作实践。\n出现于 1909 年的 “未来主义”，反对传统的艺术主张，强化运动之美和速度之美。\n1916 年，“未来主义电影宣言” 发表，提出电影要发挥能动性，超越对现实的简单机械复制。\n达达主义\n兴起于第一次世界大战时期的瑞士，最早也是出现在绘画和文学领域，后来被引入到电影中。\n以婴儿的发音为命名，直接表达了旨在婴儿呀呀学语期间对周围事物的纯生理反应，进而指出文艺创作应该像婴儿学说话那样，排除思想干扰，只是表现感官的印象 。\n总体看来，“立体主义” 和 “未来主义” 反对传统艺术的观点，“达达主义” 对传统艺术观念的颠覆，都与 “先锋派电影” 有着内在的一致性。\n纯电影 “纯电影” 反对叙事，主张将电影从其它艺术的束缚中解放出来，强调通过剪辑凸显电影画面的节奏感，即让画面压倒电影中的其它元素，主宰一切并单独起作用。\n如莱谢尔在 1923 年的《机器的舞蹈》\n《纯电影的五分钟》\n抽象电影 “抽象电影” 作为一种追求最纯粹的电影形式的先锋电影，深受抽象主义绘画的影响，强调为形式而形式，为艺术而艺术；认为电影不仅是视觉节奏的艺术，还应该是光的艺术。\n1921 年 《车轮》 1924 年 《对角线交响乐》，\n1921 年《第二十一号节奏》1926 年《电影习作》等。\n杜拉克\n1928 年《958 号唱片》1929 年《阿拉伯花饰》。\n达达主义电影 深受 “达达主义” 影响的 “达达主义电影”，继承和发展了 “未来主义电影” 的创作特点。\n1923 年《回归理性》\n1924 年 《幕间休息》\n促进了法国超现实主义电影的出现。\n第二先锋派 法国超现实主义电影 兴起于 20 世纪 20 年代，主要是将绘画和文学中的 “超现实主义” 创作方法用于电影。\n经典作品，主要有达利的《记忆的永恒》、《内战的预感》等。\n秉承超现实主义文学家安德烈·布列松的相关理论主张：强调真实的无理性行为、梦幻的重要意义，以及不协调的形象所产生的情绪力量等。\n深受弗洛伊德精神分析学说的影响，以探索对人物意识的表现为重点。\n开山之作，杜拉克在 1927 年拍摄的《贝壳与僧侣》\n布努埃尔 1928 年 《一条安达鲁狗》\n后来的电影研究者有关变态心理和无理性行为等的呈现，都归结为 “超现实主义” 在电影中的具体体现。\n《爱德华大夫》《眩晕》《西北偏北》《群鸟》等。总体来说 ”法国超现实主义电影“ 不再像之前的 “纯电影” 和 “抽象电影” 那样，过分关注物体的线条与图形，也不再具有过于强烈的节奏感，而是转为关注人物的内心深处。\n德国表现主义电影 时间：1919-1926 年\n特点：将文学、戏剧和绘画中的表现主义手法用于电影创作，电影布景呈现出失真和变形的状态。\n罗伯特·维内在 1919 年拍摄的影片 《卡里加里博士》\n第三先锋派 欧洲先锋派电影运动中的 “第三先锋派”，是一个记录电影流派。\n其创作深受苏联电影眼睛派导演维尔托夫的两部影片《电影真理报》《电影眼睛》的影响和启发，在创作中拜托了之前先锋派电影对现实的逃避，而更多去关注现实生活。\n第三先锋派创作出了一批被称为 “城市交响乐” 的纪实电影。\n《柏林：城市交响曲》 《雨》《持摄影机的人》《尼斯印象》\n拉不孔在 1928 年拍摄影片的 《贫民窟》，这部电影开创了反应社会问题的记录电影的创作先河。\n“纪录片教父” 格里尔逊在 1929 年拍摄的纪实电影片《漂网渔船》，也是 “第三先锋派” 的代表作品。\n三个阶段的共同点\n不以商业盈利为目的，不以讲述故事为宗旨；\n以探索无声电影的纯粹视觉表现和美学特征为主要使命。\n背景\n20 世纪 20 年代末，在资本主义世界全面爆发经济危机的社会背景下，同时伴随着有声电影的发明与普及。“欧洲先锋派电影运动” 逐渐走向终结。\n影响\n“印象主义电影” 对电影光线的处理和对电影影调的整体把握，以及对各种运动镜头的探索与实践，尤其是高速摄影和低速摄影的发明等，一直被沿用至今。\n“表现主义电影” 中的场面调度和灯光、场景布置的方法等，也深刻的影响了后来的电影创作，尤其是恐怖电影和黑色电影受其影响最为深刻。\n除了在电影视觉表现方面的探索和实践，“欧洲先锋派电影运动” 还提供了一种新的用电影观察世界的方法，提出了电影与世界、与社会发生联系的新的可能。\n苏联蒙太奇电影学派 概说 “苏联蒙太奇电影学派”，形成于 20 世纪 20 年代中期的苏联，以库里肖夫、爱森斯坦、普多夫金等人为主要代表。\n致力于探索新的电影表现手段以表现新时代的革命电影艺术。\n通过对 “蒙太奇” 的实验和研究，“苏联蒙太奇学派” 创立了 “电影蒙太奇” 的系列理论，并将理论运用于电影的创作实践。\n《战舰波将金号》《母亲》\n“苏联蒙太奇学派” 出现于 20 世界 20 年代的苏联的原因：\n新生的苏维埃政权为 “蒙太奇学派” 奠定了意思形态的基础。\n好莱坞的 ‘平行蒙太奇“ 仅仅是将电影片段进行组接，只具有叙事学意义；而苏联电影则将蒙太奇变为具有比拟隐喻、双关等意味的概念，从而以 ”影像的革命“ 同步苏联 ”革命的影像“。 ——爱森斯坦\n20 年代盛极一时的俄国形式主义思潮也为 “蒙太奇学派” 提供了方法论。\n先锋派意识，马雅可夫斯基的未来派诗歌，康定斯基的未来派绘画。\n当时电影创作的物质匮乏也在客观上促使苏联电影人对残存电影胶片进行更为细致、微观的探索。\n对电影胶片再次剪辑。\n“苏联蒙太奇学派” 对电影蒙太奇技巧的全面运用，使苏联电影在当时拥有了最为强劲的节奏感和冲击力，并影响了后来的好莱坞商业电影拍摄，尤其是动作片中快速、凌厉的画面剪辑。\n著名电影史学家大卫·波德维尔曾经利用统计学原理分析指出\n20 世纪 20 年代 的苏联电影通常包含 600 到 2000 个镜头，镜头的平均长度为 2 到 4秒。\n1919 年到 1928 年间的好莱坞电影，所包含的镜头数量则是 500 到 1000 之间，镜头的平均长度为 5 到 6 秒。\n1967 年的《邦妮与克莱德》的镜头的平均长度为 3.8 秒。\n意义与影响 ”苏联蒙太奇学派“ 对电影蒙太奇类型的探索，至今仍然是许多电影创作的灵感来源。\n维尔托夫所拍摄的《持摄影机的人》。\n代表人物与主要观点 库里肖夫、维尔托夫、爱森斯坦、普多夫金。\n库里肖夫不仅是苏联电影导演和电影理论家，作为一名老师，他还培养了爱森斯坦、普多夫金等苏联蒙太奇学派中坚力量。\n一、库里肖夫效应实验 关键字：男演员、面无表情、特写镜头。与一盆汤、一口安放死者的棺材、和一个小女孩三个不同的镜头剪辑在一起。\n结论：\n造成观众情绪反应的不是单个镜头的内容，而是画面剪辑的结果。\n二、维尔托夫与 “电影眼睛理论” 《持摄影机的人》\n将统一天内苏联几个不同城市的场景剪辑在一起，从而形成一部展示苏维埃政权城市生活和电影眼睛巨大力量的纪实影片。\n电影眼睛理论：\n摄影机是人眼不能所比拟的电影眼睛。 电影工作和要记录现实生活，出其不意的捕捉现实生活中的细节。 零散的素材可以通过剪辑表现出一定的主题和意义。 三、爱森斯坦 库里肖夫的土地，继承并发展了老师对电影镜头组接的研究，并指出\n镜头之间的冲突会产生最大的张力。 任意两个片段并列在一起必然结合为一个新的概念，即 “镜头 A + 镜头 B = 新的意义 C”。 1925 年《战舰波将金号》\n观念：\n通过电影画面的剪接能够形成丰富的影像元素，并具有强烈的理性隐喻。\n《辛德勒的名单》在这部电影的结尾手工染色的红旗🚩得到启发，红色衣服的小女孩。\n四、普多夫金 电影镜头之间的组接是产生意义叠加的手段，每一个镜头就像是建筑物的每一块砖头，整合起来就能够构成一个有机整体。\n即 “镜头 A + 镜头 B”组合生成的是 “镜头 AB” 意义的加成。\n蒙太奇是要为电影叙事服务的，并将其分为\n“平行蒙太奇” “对比蒙太奇” “隐喻蒙太奇” “交叉蒙太奇” “复现蒙太奇” 五种类型；并强调蒙太奇不仅能够表现戏剧冲突，而且具有抒情的特性，从而拓展了蒙太奇对电影主题的表现。\n高尔基的小说改编的电影《母亲》鉴赏。\n意大利新现实主义电影运动 20世纪四五十年代，意大利新现实主义电影是第二次世界大战结束后最重要的电影现象。作为继欧洲先锋派电影运动之后，世界电影史上第二次大规模的电影运动，意大利新现实主义电影运动在多维度多层次都构成了新的电影现象与电影文化 。\n当时的意大利电影人有感于二战后严峻的社会现实，就拍摄了一批具有进步意义的纪实影片。电影创作者们将摄影机搬到城市的大街小巷。以贫穷、失业、犯罪等社会问题为切入点，将普通人的生活呈现在大银幕上，反映战争带给人们的伤害，从而表达反法西斯战争的主题。\n从 1945 年到 50 年代奠定了 “新现实主义电影” 的创作风格，影响深远。\n背景 一、得益于意大利政府的支持 为了与好莱坞电影相抗衡，抢占本土市场，建立意大利的民族电影工业，也是为了发挥电影的意识形态宣传功能。\n1934 年创办了威尼斯电影节。\n1937 年建立了罗马电影城，不仅是世界上最大的电影制片厂之一，而且至今还在意大利电影的发展中发挥着重要作用。\n第二次世界大战之前，意大利已经发展成为欧洲的电影大国。\n二、受到二战期间现实主义创作的影响 纪实风格的盛行。 电影的叙事，拍摄技巧日趋成熟。 意大利电影人提出 “把摄影机扛到大街上去” 的口号，以纪实性的手法进行电影拍摄。\n《罗马十一时》\n《偷自行车的人》\n“意大利新现实主义电影“ 的镜头语言特点也比较突出，其普遍采用长镜头作为表现真实空间的一种手段，同时几乎每个长镜头都能够成为相对完整的一段。\n特点 实景拍摄能够实现一种电影化的真实空间表现，同时也避免了舞台观念的戏剧用光。采用非职业演员的做法既是对明星制的否定，也更为突出了电影的真实性。\n还惯以去戏剧化的结构进行叙事，即不使用倒叙闪回等复杂的叙事手法，只是按照自然的时间顺序展开故事。从而形成情节松散，结局开放的特点。\n还有方言的使用。例如 CIAO 有很多意思，在《我的天才女友》剧中，经常用到，意大利语，有是你好或者再见的意思。\n代表人物 三位大师\n罗西里尼 德·西卡 维斯康蒂 罗西里尼 通常认为 1945 年拍摄的影片《罗马，不设防的城市》，是 “意大利新现实主义电影” 的开山之作，也是罗西里尼 “战争三部曲” 的第一部。\n另外两部是 1946 年的《战火》（被称为欧洲版的《公民凯恩》）1938 年的《德意志零年》\n描述的二战时期，意大利地下反抗组织和法西斯斗争的故事。\n从《罗马，不设防的城市》开始，“意大利新现实主义电影运动” 就开始形成比较明确的纪实风格与现实主义特点，以及精妙的电影叙事技巧与英雄神话结合的创作思路。\n德·西卡 1948 年拍摄的电影《偷自行车的人》是 “意大利新现实主义电影” 的经典之作，也是世界电影史上**十大不朽影片之一**，该片集中代表了新现实主义电影的美学特征。\n也深刻影响了我国第六代电影导演王小帅的创作《十七岁的单车》\n《孩子们注视着我们》、《擦鞋童》 、《温别尔托·D》等。\n维斯康蒂 1942 年编剧并导演的电影处女作《沉沦》，而被称为新现实主义之父。《沉沦》改编自詹姆斯凯恩斯的侦探小说《邮差只按两次铃》，影片通过对社会中下层百姓的关注和对意大利贫苦生活的展示，成为意大利新现实主义电影运动蓬勃开展的前奏。\n1948 年编导的《大地在波动》。\n《大地在波动》是 “意大利新现实主义电影运动” 的重要代表作品，维斯康蒂也正是凭借这部影片，成为与罗西里尼和德·西卡齐名的 “意大利新现实主义电影” 的三位大师之一。\n德·桑蒂斯 《罗马十一时》、《橄榄树下无和平》\n评价 “意大利新现实主义电影运动” 的出现与发展，首先是建立在作为当时时代任务的基础之上，因此当战争逐渐远去，社会主要矛盾随之转移、变化后，即 “意大利新现实主义电影运动” 进入 20 世纪 50 年代，便开始逐渐走向衰落。\n另一个原因是其美学基础在时代变革语境下的变化。客观而言，意大利电影的美学基础，并不是新现实主义的朴素风格和严肃，恰恰相反其美学基础是深受意大利即兴喜剧和歌剧影响的电影，宏大浮夸的史诗巨片以及庸俗的电影情节剧等。\n“意大利新现实主义电影运动” 的影响力不容小觑，尤其是作为电影纪实美学的成功典范，“意大利新现实主义电影” 彰显了电影作为大众传播媒介的使命和意义。\n法国新浪潮电影运动 概说 是世界电影史上继 20 世纪 20 年代的欧洲先锋派电影运动，40 年代的意大利新现实主义电影运动之后，第三大规模的电影运动。\n20 世纪 50 年代末至 60 年代初，在法国突然涌现出由一些不知名的年轻人竞相拍摄电影的现象，人们将其称为 “法国新浪潮电影运动”。\n深受意大利新现实主义电影纪实风格的影响，尤其是对社会现实和对普通人的关注等，作为第二次世界大战之后全世界规模最大，影响最深的电影运动。法国新浪潮电影运动在短短几年的时间里，在思潮崛起的法国掀起了汹涌澎湃的电影浪潮，并形成了三个影响深远的创作团体。\n第一个团体：\n是以《电影手册》杂志为阵地，由资深影评人领衔的 “《电影手册》” 派。\n第二个团体：\n是居住在巴黎塞纳河左岸的职业电影导演，以及一些其他领域的文艺工作者转向拍摄电影的 “左岸派”。\n第三个团体： 是以直接记录手法为基本特征进行电影创作的 “真实电影派”。\n背景 （一）战争的影响和好莱坞电影的冲击\n第二次世界大战结束后，战争的破坏和好莱坞的大量倾销，使法国电影深入重重危机之中。面对这样的状况，同时为了对抗好莱坞电影，法国电影人提出发扬 “优质电影传统” 的口号。\n一方面将大量的名著改编为电影，另一方面讲究高成本制作，在电影中强调布景的华丽和陈设的精美，同时推崇明星制。这样拍摄出来的电影，虽然在一定程度上挽救了濒临崩溃的法国电影业，但是僵化的创作模式也使电影丧失了原创价值。以及法国诗意现实主义所特有的清新写实传统。\n（二）西方人文主义思潮的蔓延\n（三）“法国电影资料馆” 对 “新浪潮电影运动” 的出现起到了决定性的作用\n1936 年成立的法国电影资料馆。\n再次讲解《罗生门》。\n罗生门是日本京都罗城的城门，后来通常被借指人世与地狱之界门，事实与假象之别。\n我甚至听说过住在罗生门这儿的鬼，因为害怕人类的凶残而逃走。——《罗生门》电影\n背景很重要，《罗生门》是日本作家芥川龙之介1915年创作的短篇小说，情节取材于日本古典故事集《今昔物语》百度百科。那时的日本，资本主义高速蓬勃发展，同时又是一个天灾人祸的乱世。社会动荡，经济萧条，民不聊生，处于京都的罗生门附近都已经是格外的荒凉来自知乎。\n你让一个极度贫穷的人，去遵守道德，以及触及了人的利益时，你让他去维持本性，这是很难的。\n已经看完罗生门，其实就是一故事，经由了三个人讲述，每个人都美化了自己的行为，最后一个人讲出的事情的真正过程。人心是这样，尤其是在所谓的鬼附身，由死人讲出的话，更是荒唐。和尚代表着一种圣母的存在吧，开始就像太宰治一样，对人充满了失望，太宰治失望的是自己，和尚失望的是他人。就是摆烂，不做行动，懦弱，但怀着一颗 “善良” 的心。\n倒数第二场镜头，樵夫那笑容，有点诡异，我觉得应该是后面会把这小孩给卖了，和卖匕首一样。\n最后一个镜头是拍到了罗生门那块牌匾，点个电影名字吧。\n电影手册派 是法国新浪潮电影运动中，最重要的一个团体。其代表人物有阿斯特吕克、巴赞、特吕弗、戈达尔等。\n阿斯特吕克：“摄影机——自来水笔” 1948 年第 144 期的《法国银幕》杂志上，发表了《新先锋派的诞生：摄影机——自来水笔》一文，提出摄影机——自来水笔的观点。\n指出电影已经成为一种拥有自己的语言、可以自由表达思想情感的工具；正如作家用笔写作一样，电影导演可以用摄影机 “写作” 并表达个人意念。\n“摄影机——自来水笔” 成为了 “法国新浪潮电影运动” 的理论先驱。\n我的补充（源自《电影批评》）：\n法国著名的电影理论家、当代电影理论的奠基人克里斯蒂安·麦茨精当的论断：并非由于电影是一种语言，它才讲述了如此精彩的故事；而是由于它讲述了如此精彩的故事，才使自己成为了一种语言。\n意大利著名电影导演、理论家帕索里尼在他的电影论文《诗的电影》一文中指出：电影本质上是一种新语言。他认为电影使用的是某种 “表情符号系统”，这一副好系统先于语法而存在，因为 “世界上没有一部形象词典”。以为电影导演必须首先创造他所需的词汇，即选取他的拍摄对象，将其创造为自己的形象符号，尔后方才进入美的创造。\n电影语言不通于自然语言。\n自然语言是一种任意的、无理据的、约定俗成的符号系统，而电影语言是一种有理据的 “短路” 符号，其能🈯️约等于其所指。 电影语言没有最小单位。即使最单纯的影像，也有内涵表意的现象发生。 由于 “世界上没有一部形象词典”，电影语言始终只是一种语言，而非语言系统。因此，电影叙事更多地依赖着诸多成规和惯例。 巴赞：“电影是现实的渐近线” 1951 年法国著名的《电影手册》杂志创办，巴赞在第一期杂志上刊文提出，电影是现实的渐近线的观点，并指出杂志社要以挖掘和扶持电影作者为己任。这些使得《电影手册》很快声名鹊起。巴赞也成为了杂志的核心人而无，还被誉为 “法国新浪潮电影运动” 的精神之父。\n特吕弗与 “作者论” 时任《电影手册》杂志编辑的特吕弗发表了《法国电影的某种倾向》一文，他在文章中。\n批判和抨击当时的法国电影制度。 首次提出 “作者论”，指出电影的真正作者不应该是编剧，而应该是在一系列电影中坚持题材和风格一贯性的导演，即导演应该是自己作品的作者。 1958 年，特吕弗拍摄了短片《顽童》，该片和电影《通往绞刑架的电梯》《漂亮的吉尔塞》 等都成为了法国新浪潮电影运动的先声之作。\n1959 年特吕弗拍摄的影片《四百下》获得戛纳国际电影节的最佳导演奖，为法国电影赢得了荣誉，也成为 “新浪潮电影运动” 的标志性作品。\n戈达尔 在 1960 年拍摄的影片《筋疲力尽》可以说是石破天惊。\n这部影片从 20 世纪 40 年代的美国黑帮片中吸取灵感，从内容到形式都毫无规律可循，随意的拍摄方式完全无视好莱坞电影的经典模式，然而却开启了一个更为自由和个人化的电影创作路径。尤其是戈达尔的电影美学观念，还为场面调度与蒙太奇学派的对立，找到了一条新的出路。以至于法国电影资料馆馆长朗格卢瓦都心悦诚服的认为电影史可分为戈达尔之前和戈达尔之后。\n左岸派 在《电影手册》派创作繁荣的同时，当时生活在巴黎的另外一批电影艺术家，还拍摄出了多部与传统电影叙事技巧大相径庭的影片。由于这些人都居住在巴黎塞纳河的左岸，因而得名左岸派。\n下面内容来自维基百科。\n在法国巴黎地区，左岸（法语：La Rive Gauche，法语发音：[la ʁiv ɡoʃ]）指流经市区的塞纳河南岸地区，塞纳河北岸地区则称右岸。“左岸”具有文化和意识形态意味，并衍生出左岸公社、左岸文化、左岸咖啡等词汇，以及房地产广告中也常用左岸彰显文化品味。\n使用情况\n在法国，自东向西流动的塞纳河穿过首都巴黎，将巴黎分隔为左右两边。塞纳河以北称为右岸，有许多的精品店及大宾馆。在塞纳河以南的部分称之为左岸。在这里有许多的学院及文化教育机构，以年轻人居多消费也较便宜。拉丁区即是位于左岸。\n如图塞纳河南岸即为左岸\n巴黎左岸包含了巴黎的六个区：\n巴黎第五区，万神殿区(quartier du Panthéon) 巴黎第六区，卢森堡区(Luxembourg) 巴黎第七区，波旁宫区(Palais Bourbon) 巴黎第十三区，戈博兰区(Gobelins) 巴黎第十四区，天文台区(l\u0026rsquo;Observatoire) 巴黎第十五区，沃吉哈赫区(Vaugirard) 塞纳河畔，左岸的咖啡？\n”左岸派“ 的出现 代表人物有阿伦·雷乃、阿涅斯·瓦尔达、玛格丽特·杜拉斯等。其实左岸派并没有形成一个学派或是团体，他们只是有着长久的友谊，艺术趣味也比较相投，并且在创作上经常互相帮助的一群艺术家。\n代表人物 ：阿仑·雷乃 1959 年《广岛之恋》与特吕弗的《四百下》同时出现在戛纳国际电影节上，虽然只是一部参展影片，但在当时的影响力却非常大。并成为法国新浪潮电影运动的重要代表作品，这不影片根据法国女作家玛格丽特·杜拉斯的同名小说改编。讲述一位法国女演员与日本建筑师之间的爱情故事。阿仑·雷乃在影片中没有正面描写战争的残酷，也摒弃了传统的线性叙事，而是将战争隐藏在爱情故事的背后，在剪辑上也是打破过去、现在、未来的时空界限，以无技巧闪回3的叙事结构淡化了故事的时间界限。\n电影《广岛之恋》既具有创作者的独特风格，又带有浓厚的文学气息，被称为是 “西方电影史上从传统时期进入现代时期的一部划时代的作品”。\n阿仑·雷乃尝试以无连贯性的情节和意识流的时空跳跃，作为电影表达自我观念的方式。并在 1961 年拍摄出影片《去年在马里昂巴德》，这部充满文学味道的电影，依然是通过拼贴的电影语言，探索真实与虚幻之间的关系，并试图从潜意识层面表现主人公的行为举止。同时，这部现代主义的电影文本还由于电影语言过于晦涩，也被后人不断的解读。\n“左岸派” 的特点 “法国新浪潮电影运动” 的另一个创作团队，“左岸派” 所创作的电影往往被称作 “作家电影”。\n具体来说，有以下几方面的特点：\n左岸派电影创作者在进行电影剧本选择时，不主张改编文学作品，而更愿意拍摄专门为电影撰写的剧本。 由于文学作者的身份使然，“左岸派” 导演更重视对电影中人物内心世界的揣摩与表现，而轻视对外部环境的描写。 不同于 “《电影手册》派” 轻视电影拍摄技巧的半即兴式创作，“左岸派” 在电影拍摄时非常讲究相关首发与技巧的运用。 ”真实电影“ 除了上述两种派系，还出现了以现实主义题材见长的真实电影。\n“真实电影” 作为一种源于纪录片写实主义的电影类型，在 “法国新浪潮电影运动” 时期，秉承了 “苏联蒙太奇学派” 代表人物维尔托夫的 “电影眼睛理论”，主张摄影机是记录社会生活的眼睛，要摒弃拍摄者的主观认知，从而让表现世界的真实本质。\n特点 “真实电影” 继承了 “《电影手册》 派” 即兴创作，周期短、投入低、使用非职业演员等特点。\n不同的是，“真实电影” 对现实主义题材的表现要比 “《电影手册》派” 更为彻底。\n“真实电影” 还为故事片创作提供了最大限度保持真实性的参考。\n如电影《四百下》中对街景的处理，就借鉴了真实电影的创作手法。\n影响 “法国新浪潮电影运动” 在 1961-1962 年间达到辉煌之后便迅速衰落。\n1962 年底《电影手册》杂志还出版了 “新浪潮专号”，对 “法国新浪潮电影” 进行总结。\n法国新浪潮电影特点 拍摄方面\n以外景为主，很少在摄影棚内拍摄；外景也多为实景，以凸显电影的真实感。\n推崇巴赞的 “摄影机本体论”，即注重电影的照相功能，在实景拍摄中也是利用的自然光、进行肩扛跟拍这种与新闻片拍摄类似的手法。\n电影剪辑方面\n以镜头直接切换和跳接的方式，取代了原本复杂的快速剪辑，从而淡化了蒙太奇的时空转换功能，有效控制了电影的长度和节奏。\n电影产业方面\n致力于推动 “导演中心制” 的形成，从而促成新一代法国电影人的崛起。\n法国新浪潮电影运动的影响 对欧洲的影响\n在欧洲，“新现实主义” 的诞生地意大利，在 “法国新浪潮电影运动” 的鼓舞下，迅速崛起了一批青年导演。如贝托鲁奇、帕索里尼等。\n波兰、捷克、匈牙利等东欧国家也受到影响，电影制作风格开始比之前更为简化。\n处于战后重建阶段的德国也深受其影响，一批德国青年导演在1962 年发表了著名 “奥伯豪宣言”，开始了 “德国新电影运动”。\n对亚洲的影响\n首先受到冲击的是日本。在其影响下，以大岛渚和吉田重为代表的日本电影人，先是在 “松竹电影公司” 内部掀起了一场革命，随即扩展到整个日本的电影业。\n大岛渚在 1960 年拍摄的影片《日本之夜与雾》 直接套用了法国电影《夜雨雾》的名字。\n吉田喜重（吉田喜重，又名吉田喜重）的代表作品《不务正业的人》也是完全借鉴戈达尔《精疲力尽》的电影语言，以表现迷失中的日本青年。\n同时，我过第五代、第六代电影导演的创作，也在一定程度上受到法国新浪潮电影运动的影响。\n日本东方美学电影 日本电影的发展 日本电影作为亚洲电影重要切独特的一支，以别具风格的民族美学特征和对电影艺术多样化的贡献，在世界影坛中有着不可忽视的地位。\n一、早期日本电影 早在 19 世纪末开始独立拍摄电影时，日本就将 “电影” 改名为 “映画“，从而使电影一开始就具有明确的民族文化特征。\n一定程度而言，日本电影并没有真正经历无声片时代。因为伴随着电影在日本出现的，还有一种叫做辩士的职业。\n辩士：\n指电影的旁白者，其主要的工作是朗诵电影的对白、讲解电影故事；有时甚至还会为了配合某位 “辩士” 的讲解而调整电影的放映。\n“辩士” 作为世界电影史上的一种独特现象，是深受日本戏剧影响的结果。\n日本传统的 “能乐”、“歌舞伎”、“偶人净琉璃” 等，其表演和演唱分别都由专人担任，同时还有专人负责评述剧情，即视觉和声音的表演分工明确，这种手法被借用到电影中，就出现了辩士。\n默片与 “辩士” 的组合，其实就是日本戏剧 “声画分离” 模式的延伸，因此日本观众对此十分熟悉切适应。 这种艺术形式，本质上暗合了布莱希特的间离派理论。\n我想起了一部电影《默片解说员》，算是喜剧吧。\n二、有声片时代的日本电影 20 世纪 30 年代，有声片的出现使日本电影呈现出全新的面貌：\n（一）“辩士” 遭遇到了淘汰\n（二）日本出现了有声片的创作高潮\n松竹、日活、东宝等电影公司都争先恐后的创作有声片。沟口健二、小津安二郎等在无声片时代就具有一定影响力的导演，也都积极投入有声片的创作。还有后来的黑泽明也在 40 年代初进入了日本影坛。在第二次世界大战之前的几年，日本已经发展成为了世界电影大国。第二次世界大战结束的最初几年，作为战败国的日本被美国控制，直到 1951 年美国从日本撤离后，日本电影才又开始重新开始独立发展。\n三、二战后的日本电影 ”松竹“ ”日活“ ”东宝“ 等老牌电影公司努力打造自身的类型片优势，并采用好莱坞类似的工业流水线生产。 日本影坛也迎来了大师辈出的 “黄金时代”。 不仅有黑泽明、市川昆等老牌电影导演继续活跃在影坛，他们勇于尝试新技术，寻找电影表现的突破，甚至还为了寻求资金将目光投向国外，邀请外国制片商投资。而且还有今村昌平、大岛渚、新藤兼人、筱田正浩等二战期间涌现出的新导演。他们也以多样化的创作丰富了日本电影的艺术表现。\n四、类型片的创作 战后的日本经济在美国扶植下逐渐恢复，科技进步也非常迅猛，这就给电影的发展带来了良好的契机。于是，在现代特技效果流行的背景下，日本出现了以视觉奇观为核心的商业动作大片创作热潮。\n东宝：1954 年 《哥斯拉》（教程上这里应该有出入）\n哥斯拉（ゴジラ Gojira ?，英語：Godzilla），為日本東寶株式會社製作的怪獸，日本影史上最悠久，世界影史上公認最經典最有名的怪獸角色。\n最早的哥斯拉是一部受到美國《金剛》影響的怪獸電影，描述受到輻射污染的海域中出現一隻身高達50公尺的怪獸哥吉拉。哥吉拉後來成為日本類似電影、動畫、漫畫的怪獸原型，對於日本動漫作品的怪獸形象有非常深遠的影響。\n怪兽片从此也成为日本最具特色的电影类型。\n老牌的电影公司还在不断寻求能够留住观众的电影类型。\n如松竹公司就拍摄了寅次郎的故事系列电影，并从 1969 年到 1995 年间连续拍摄了 48 部，创造了世界电影史上，由同一个演员主演系列电影的数量之最。\n此外，那些富有神秘色彩的日式惊悚片，想象力丰富且制作精良的动画片等，也都逐渐成为了极具日本特色的电影类型片。\n《你的名字》的鉴赏\n小津安二郎 日本电影人物众多，创作风格也各有千秋，而在国际上影响力最大的，是三位殿堂级的人物。\n古典大师小津安二郎 现代主义巨匠黑泽明 后现代拼贴高手北野武 小津安二郎\n最能代表日本电影民族特色的导演；\n宁静、悠远的美学风格；\n被视为真正的古典主义。\n叙事特点 大多聚聚焦普通日本人的日常生活状态，尤其擅长对家庭成员之间的关系进行细致入微的描写，故事常以传统日本家庭在现代化进程中受到的冲击为主要矛盾。\n第一种，表现父母与儿女之间的关系。\n大多是描写儿女婚姻问题所引发的情感波澜，而在实质上反映日本传统价值观中的亲情和责任问题。\n代表作品如\n《晚春》\n《彼岸花》（推荐）\n《麦秋》\n《秋刀鱼之味》（推荐）\n第二种，是表现就在社会转型过程中，随着传统大家庭的解体，儿女对父母绝对服从观念的淡化所引发的关系变化，于是年轻人变得以自我为中心，年迈父母常常陷入孤独和失落，因此影片大多充满淡淡的忧伤和凄凉。\n代表作品\n《东京物语》\n《浮草》\n《小早川家之秋》\n第三种，是表现夫妻之间的情感矛盾。\n尽管影片中的夫妻由于各种原因产生不和，但都以彼此原谅、婚姻和家庭也都得到维护为结局，即完全符合东方文化中 ”相濡以沫” 的婚恋观。\n代表作品如\n《早春》\n《茶泡饭之味》等\n这些影片大都以顺序的方式叙事，很少有闪回等时空变化，而旨在以最自然的方式将故事娓娓道来；同时台词也极其散淡平实，达到了一种 “言有尽而意无穷” 的效果。\n无论是战前还是战后，小津安二郎的电影都远离政治风云，只是通过对现实生活和市井人物的细腻描绘，即为质朴的表现出日本社会在 20 世纪的变化。尤其是传统观念与现代观念的碰撞与融合。\n《东京物语》鉴赏\n视听语言特点 首先，他惯用于使用低角度的机位，以 30 度的左右的仰视角度拍摄人物。因为这个角度既符合日本席地而坐的习惯，也体现出日本民族讲究礼仪的谦恭态度。\n其次，小津安二郎偏爱使用静止的长镜头，拒绝戏剧化的蒙太奇和复杂运动镜头。\n在拍摄人物对话时，多以正面为主，并直接切换，不刻意制造剪辑点，一切以平实为基调。\n场景多为室内，即传统的日本民居，并巧妙利用室内门窗或家具的线条来展示电影画面构图的美感。\n《秋刀鱼之味》鉴赏。\n作为古典主义大师，其电影的最大价值就是对日本传统文化内涵的准确表达，而非流于表面的符号堆砌。可以说，是小津安二郎让日本电影发出了最民族的声音。\n黑泽明 黑泽明的电影具有较强的现代性，同时电影的形式和内容，也都更具创新和国际视野。甚至开创了世界影坛的风气之先。\n题材特点 在电影选材方面，黑泽明涉猎较广，从古装时代剧到社会问题剧，甚至先锋实验性质的电影都有创作。\n1990 年，80 岁的黑泽明获得了第 62 届奥斯卡终身成就奖。成为第一位获得该奖项的亚洲电影人。也是在这一年，黑泽明自编自导了一部极具先锋实验性的影片《梦》。\n该片以\n太阳雨\n桃园\n风雪\n隧道\n乌鸦\n红色富士山\n垂泪的魔鬼\n水车之村\n八个梦贯穿了几乎人类社会的所有主题，同时黑泽明还对不同梦境中的不同场景，配合了不同的色彩。\n视听语言特点 擅长拍摄动作场面和宏大场景。 喜欢用多机位以营造单一机位难以实现的全方位视觉感受。（如电影罗生门的开头，樵夫进入森鲮的段落，就是多个机位的拍摄） 黑泽明的电影时而呈现出强烈的运动感，时而又尝试极具抽象意味的长镜头，种种变化使其影响风格与传统的日本电影有了很大的区别。黑泽明对电影视听语言的探索超越了国界，启发了全世界许多导演的灵感。\n如星球大战系列电影就深受其影响。\n艺术表现特点 黑泽明电影虽然与日本歌舞伎的叙事传统相距较远，但却更符合西方戏剧的精神内涵：表现个人对命运的挣扎与反抗。\n黑泽明的多部电影都改编自西方名著，如\n莎士比亚的《麦克白》-\u0026gt;《蜘蛛巢城》 《李尔王》-\u0026gt;《乱》 黑泽明的电影还渗透着西方的 “现代性” 思想。\n电影《罗生门》就通过几位当事人对同一件事情的不同叙述，表现出人对世界认识的相对性及所谓真相的不可知。\n这种结论与伯格曼，费里尼等欧洲现代主义电影作者所传达的理念有很多相似之处。\n黑泽明还拍摄了多部反映社会现实问题的影片。\n如《生之欲》《八月狂想曲》等。\n这些影片具有高度概念化的抽象意味，除了少数流露出悲观的情绪之外，大多是以慈悲和宽容的胜利告终。这种价值观具有一定的国际视野，也是黑泽明被世界影坛推崇的原因之一。\n评价 黑泽明电影虽然与纯粹的日本电影有所不同，但又绝不是对西方电影的简单模仿。\n北野武 20 世纪 90 年代，北野武的横空登场震动了平静许久的日本影坛。其特立独行的影响风格，别具一格的剪辑手法，虽然让评论一时哑然，但都不得不认可他的才华与创造力。\n《菊次郎的夏天》里面的坏大叔，就是北野武。\n题材特点 题材来源非常广泛。警匪片《凶暴的男人》《花火》黑帮片《奏鸣曲》《大佬》青春片《坏孩子的天空》古装片《座头市》等 在电影创作体现出一种自由和游戏的态度。《那年夏天，宁静的海》《玩偶》《菊次郎的夏天》《双面北野武》 视听语言特点 多用蓝色作为多部电影的基调，以表现人物的特殊心理状态，并成为了他独特的个人标志。\n北野武特别热衷于表现暴力，同时这种暴力又都是突如其来的发生，不带有任何美化和温情的处理；在处理打斗动作时，电影画面往往突然定格，以突出动作的震撼力。\n北野武的电影镜头经常也是随心所欲的移动，跟随主人公漫无目的的闲逛。\n有时甚至还会在一系列的连续动作中突然切换到另一个画面。\n与此同时，绘画、文字、照片等也都经常随意出现在北野武电影画面中，被用来构成叙事。\n叙事特点 在北野武的电影中看不到日本传统歌舞伎表演的影子，但是随处可见驾轻就熟的黑色幽默与尖锐深刻的讽刺。\n北野武电影中的人物往往是孤独与茫然的，故事中也很少有人道主义的精神胜利，主人公看待世界的眼也常常是冷酷、悲观的。如《菊次郎的夏天》\n北野武的电影还有着明确的当代日本文化体现。\n虽然游戏式的拼贴掩盖了那些外在的日本电影特征，但对情感的收敛表达，对死亡的迷恋，以及日本传统文化符号，深受日本漫画影响的电影桥段等，都能够让观众联想到混杂了多种文化基因的当代日本文化。\n日本电影美学：矛盾性 矛盾性 特点：“唯美与残酷” 的相伴而生。\n这种矛盾既体现在单独的影像文本中，也体现在导演的个人创作中。\n如女性电影大师沟口健二的多部影片\n《西鹤一代女》《雨月物语》《近松物语》总是将美好的主人公残忍的推向不幸，而似乎只有在施虐和折磨中，才能凸显出主人公的外表美和人性美。\n日本受自然条件等影响，地震等灾害频发，于是那些美好的事物很容易在瞬间被毁灭。正如日本电影中频繁出现的樱花的象征意义。瞬间的绚烂和霎那的凋谢。\n《你的名字》鉴赏\n也正是这种绝望之美，使日本电影中的唯美总是与残酷相伴，尤其是在爱情片中，电影创作者往往在用尽笔墨刻画男女主人公的情感之后，总会有突如其来的离别或是死亡，这一模式在电影中多次出现。\n如《伊豆的舞女》《雪国》《失乐园》等。\n特点：“含蓄与直露” 并存的情感表达。\n日本导演总是通过对男女主人公表情神态的准确把握，巧妙的通过镜头设计来含蓄的传达人物情感。与含蓄的情感表达相对，日本电影并不忌讳对暴力的直接呈现，尤其是在武士题材的电影中，暴力元素已经深深扎根。如北野武的代表作《座头市》等。\n与世界其他国家的电影相比，日本电影的抒情性非常强烈，十分重视自然景物在电影中的作用，如四季的更迭，气象的变化等都在电影中得到了充分的体现。\n许多日本电影直接以自然景物或四时季节命名，如《浮草》《麦秋》《八月狂想》《那年夏天，宁静的海》《细雪》等。\n与中国的古装片类似，日本电影还从本国文学作品文学和民族剧中吸收了很多素材，“古装时代剧” 作为日本一种长盛不衰的电影类型，其服装、道具、台词、表演等都具有浓重的民族文化特色。\n民族性 究其原因，虽然日本的生活方式已经相当西化，但日本人的行为举止却保留了很多传统特色，如鞠躬、点头、跪坐等；这些程式化的繁琐礼节深刻影响着日本电影在世界影坛的形象，并成为日本电影名族性的基本表现。\n《战国英豪》《椿十三郎》\n香港电影新浪潮电影 概说 1896 年，“电影之父” 卢米埃尔兄弟派几名技师来远东地区放映电影并拍摄一些风光素材，第一站便到了香港。\n随后，美国人在上海创办的亚细亚影戏公司也来到香港。1909 年拍摄的由香港那人梁少坡导演并主演的故事片《偷烧鸭》，开启了香港本土电影的制作历史，同时，也开启了“警匪片” 的制作历史。\n1913 年出现了完全由香港人创作、香港公司出品的第一部影片《庄子试妻》是香港电影史的正式开端。\n黎民伟编剧并主演，由黎北海主导。\n香港电影的各个时期\n三十年代——成长期 四十年代——沦陷期和复苏期 五、六十年代——繁荣期 出现了一批实力雄厚的电影制片机构：长城、凤凰、邵氏、中联、电懋等。\n代表性导演：朱石麟、李翰祥等以及一批艺术水准颇高的电影佳作。如\n《一板之隔》《貂蝉》《江山美人》《故园春梦》 这些作品大多取材于历史，且常与戏曲等传统艺术形式相结合，体现出一种华丽精致的戏剧式风格。\n四十年代作为亚洲四小龙的香港，经济空前繁荣，成为极具规模的现代商业都市，西方文化观念经由各种传播媒介，大量涌入香港人的视野，逐渐被香港大众，尤其是新一代香港人所接受。香江文化和西方文化的碰撞，触发了香港新浪潮运动。\n香港新浪潮运动 原因 一大批热爱电影的年轻人在国外接受了正规的电影教育。\n就读伦敦电影学院的严浩，就读于美国德州大学奥斯丁分校电影专业的徐克，就读于南加州大学电影专业的方育平等，谭家明也曾于1975年被派往美国旧金山进修电影制作，他们把在海外学到的先进的电影理念和新颖的叙事技巧引入香港本土电影题材。创作出一批令人耳目一新的影片，开创了香港电影前所未有的新局面，这成为新浪潮电影运动强有力的思想支柱和人才保障。\n电视机构对创作人才的锤炼\n方育平、徐克、严浩、谭家明、许鞍华等曾在电视机构担任编导，一方面通过电视剧、电视电影等创作技巧，另一方面广泛而深入地了解香港当代社会的形态和心态，为新浪潮电影运动的到来作了艺术和题材上的准备。\n电影杂志《电影双周刊》的摇旗呐喊，也是新浪潮电影运动得以兴起的重要推手。\n该杂志，通过对年轻电影人及其作品的评介鼓励，促进了社会各界对新浪潮电影运动的关注和认同。 该杂志海创办了香港电影金像奖。第一届到第四届的最佳影片奖，全部由新浪潮电影运动的作品包揽。\n分别是《父子情》《投奔怒海》《半边人》《似水流年》，这对新浪潮电影运动的其他年轻导演，无疑是巨大的鼓舞 。\n在以上几个原因的推动下，香港新浪潮电影运动应运而生，并成为当代香港电影史上最重要、最具国际影响力的电影革新运动。\n代表人物及作品 严浩 1978 年，“无线” 电视台的严浩和余允抗与电影导演陈欣健合组 “影力公司”，拍摄了被公认为 “新浪潮” 电影运动开山之作的《茄哩啡》。\n茄哩啡是粤语俗是“跑龙套”，kelefe是广东话的说法。\n小人物，误打误撞变大明星，喜剧方式呈现。\n《夜车》《公子娇》《似水流年》成为香港新浪潮电影运动的代表人物。\n方育平 在 1981 年执导的《父子情》，1983 年执导的 《半边人》 分别夺得香港电影金像奖第一届、第三届最佳影片奖，同时也是香港新浪潮电影运动的代表作品。\n《父子情》一改传统香港电影华丽精致的戏剧式风格，代之以自然平实的叙事和清新恬淡的影像风格，在娓娓道来的凡人琐事中，展现香港平民生活的真实质感，体现出法国新浪潮电影运动的影响。\n徐克 1979 年到1980 年，徐克拍摄了《蝶变》、《地狱无门》、《第一类型危险》三部风格奇诡的影片，成为新浪潮电影中最特别的代表作。\n这三部影片表面上都有一个商业类型片的外壳，但在叙事及拍摄手法上却是对类型片的颠覆。\n《蝶变》刻画了一个混乱的武林世界，颠覆了香港传统武侠片中的侠义江湖。\n《地狱无门》则刻画了一个“吃人”的世界，充满当时对当代香港社会的影射和隐喻。令人不免想到鲁迅先生的狂人日记。\n许鞍华 1979 年《疯劫》，用创新的艺术手法，讲述了一桩扑朔迷离的杀人案件。其中，大量使用的自然光效，心里化叙事手段等现代电影技巧，赋予传统惊悚类型片一个全新的面貌。并传达出导演对当代香港社会女性出镜的思考。\n之后，相继执导了《撞到正》、《胡越的故事》、《投奔怒海》等经典影片。\n除了以上代表人物以外，章国明、谭家明、冼杞然、翁维铨、于仁泰 、卓伯棠等年轻（当时年轻）导演们也推出了新作，他们的作品迅速在香港影坛掀起了一股奔涌的浪潮。以新颖独特的艺术成就，影响着香港电影的整体创作态势。\n艺术成就和意义 艺术成就 题材选择\n“新浪潮” 电影与传统商业电影逃避现实的态度不同，而是选择直面香港社会现实问题，注重对香港本土风貌的展示，注重对个人经验和集体回忆的书写，也关注女性命运，对国家、民族、海外华人等重大议题也并不回避，在思想内容上极大提升了香港电影的内在品质。\n电影类型\n“新浪潮” 电影打破了此前香港电影的类型藩篱，大胆地对不同的类型元素进行重新组合，翻新了一些旧有的类型片，创造了一些新的类型片，使香港电影呈现出类型丰富、形式多元的新格局。\n艺术风格\n新浪潮电影导演特别重视电影叙事模式的革新和电影语言的重建，他们把从西方现代电影中学习来的新浪潮电影叙事手法和视听语言技巧完美地融入本土题材，创造出与传统商业电影迥然不同的艺术新风格。\n艺术 香港 “新浪潮” 电影运动从整体上提高了香港电影的思想性和艺术性，带动了香港本土电影的复兴，提供了艺术与美学上的新观念，客观上完成了从粤语片传统的伦理套路到现代电影关于人性、生命、社会等普世价值观的过渡。\n同时，也为香港电影业输入了大量的人才，并促成了电影机构的新兴和调整，改善了香港的影视文化环境，堪称香港电影史上最重要的一次电影革新运动。\n台湾新电影运动 概说 1925 年出现了台湾人自己拍摄的第一部影片《谁之过》 从 1925 年到 40 年代末，是台湾电影草创时期，银幕上依然以日本电影占据主流，本土电影发展缓慢。 20 世纪五、六十年代，由于台湾地区经济的发展，台海局势的相对稳定，台湾当局反共抗俄的制片方针有所松动。台湾电影出现了短暂的繁荣，出现了以李行、白景瑞为代表的 “健康写实主义” 电影。代表作《蚵女》《养鸭人家》等。 民营电影公司则大量制作以 “言情片” 和 “武侠片” 为主的商业电影公司。《婉君表妹》、《烟雨濛濛》持续了二十年的琼瑶热。武侠片则以1967 年的《龙门客栈》为潮头，迅速风行台湾。 到了 20 世纪 70 年代末期，台湾电影陷入商业电影的畸形繁荣之中。犯罪、赌博🎲、打斗:facepunch:、青少年嬉闹、滑稽胡闹以及噱头集锦式的电影以及老套的爱情文艺片、流于教条的军教片充斥于银幕之上。引发了人们对于台湾电影艺术前途的担忧。 1983 年，琼瑶推出了《昨夜之灯》后解散巨星公司，爱情文艺片年代就此告一段落。 同年（1983 年），三位大师导演胡金铨、李行和白景瑞联合执导神怪武侠片《大轮回》，企图挽救濒死的电影市场，可惜票房成绩依然不如人意。 这两大事件标志着台湾电影陷入低谷期，亟(jí)待新的血液。\n背景 欧洲电影的影响 青年导演的崛起 香港新浪潮电影的影响 欧洲电影的影响 1965 年创刊的《剧场》杂志，1917 年创刊的《影响》杂志，都曾用大量的篇幅介绍欧洲电影，为 80 年代台湾电影的出现奠定了理论基础和人才基础。\n1979 年第 16 届金马奖开始增加国际影展部分，不但使青年电影人获得更多接触欧洲电影的机会，而且还培养了一批高素质的观众。\n青年导演的崛起 20 世纪 60 年代是台湾商业电影的黄金年代。吸引了很多年轻人到欧美国家攻读电影专业，如就读于美国加州大学的电影科的杨德昌，就读于美国纽约州雪城大学电影研究所的柯一正，就读于美国哥伦比亚影艺学院系的万仁等。他们在七十年代学成归来，为台湾电影带来新的观念和方法。\n在六、七十年代进入电影界、曾追随过健康写实主义电影导演的本土新生代，如陈坤厚、侯孝贤、张毅等，也组成了新的电影创作阵营。他们经过台湾媒体对欧洲电影的评介，以及金马奖国际影展对新电影的知识，技巧的普及，与海外归来的新导演在电影创作理念的沟通上毫无隔阂。\n1983 年，“中影” 公司大胆起用年轻作家小野、吴念真组成 “二人小组” 负责选报题材，并审核或参与别人创作的题材。使战后成长的一代，第一次有机会进入电影体制的决策层，对新电影的产生和发展也起到重要作用。\n香港新浪潮电影的影响 1980 年 10 月，在金马奖活动期间，台湾 “新闻局” 在电影图书馆举办了 “香港新锐导演作品观摩座谈” 活动，邀请徐克、谭家明、许鞍华、严浩、梁普智等 7 位 “新浪潮“ 导演携作品参加，与台湾影人进行交流，大大鼓舞了年轻电影人。\n过程 1982 年夏，杨德昌、柯一正、陶德辰、张毅联合执导了四段式集锦片《光阴的故事》成为新电影的滥觞之作。四个短片分别为《小龙头》《指望》《跳蛙》《报上名来》，通过讲述四个人生不同阶段的故事，表现人的成长，人际关系的演变，和过去三十年里台湾社会形态的变迁。这部影片奠定了新电影运动的基本特色。\n低成本的投资 “成长与历史” 的主题 写实清新的影像风格 1983 年，曾壮祥、侯孝贤、万仁联合执导了三段式集锦片《儿子的大玩偶》，成为新电影运动的另一部代表作品 。三个短片分别涉及三个主题，\n《小琪的那顶帽子》\n以美丽女孩小琪帽子下丑陋的疤痕影射台湾经济繁荣的背后遭受到来自日本的经济侵略。\n《儿子的大玩偶》\n通过男青年坤树为电影院做活动广告人的故事，展现台湾从农业社会向工业社会转型之际小人物艰难谋生境遇。\n《苹果的滋味》\n则以一个充满荒诞感的故事展示了朝鲜战争爆发之后台湾对美国经济援助的依赖以及这种依赖对普通台湾人心理的影响。\n在台湾新电影运动中的诸多代表人物之中，有以侯孝贤和杨德昌成就最高，影响最大，堪称运动的两大旗手。他们分别从乡村和城市两个角度，记录了台湾社会的沧桑巨变。\n侯孝贤 侯孝贤生于广东，1948 年移居台湾。1972 年毕业于台湾 “国立艺专” 影剧科。\n他的创作以乡土台湾为起点，对于台湾自身的 “根性” 和历史性发出追问，是 “台湾意识” 强烈外现的重要历史标尺，被称为 “记忆与乡土的书写者”。\n代表作有：书写个人成长记忆的 《冬冬的假期》《童年往事》对于乡村文明与现代都市文明进行比较的《风柜来的人》、《恋恋风尘》（推荐）、《尼罗河女儿》。构筑族群历史记忆的《悲情城市》、《戏梦人生》、《好男好女》等。\n其中《悲情城市》以 二·二八事件为背景，讲述了台湾林氏兄弟四人的遭遇和生活，获得威尼斯电影节最佳影片金狮奖。\n滥觞，是一个汉语词语，读音为làn shāng，本谓江河发源之处水极浅小，仅能浮起酒杯， [1] 后比喻事物的起源和发端。 [2] 出自《孔子家语·三恕》：“夫江始出于岷山，其源可以滥觞。”\n杨德昌 杨德昌出生于 1947 年，逝世于 2007 年。大学期间学习控制工程，后到美国学习电脑并获得硕士学位，1981 年回到台湾。\n代表作品\n八十年代《海滩的一天》《青梅竹马》《恐怖分子》\n九十年代《独立时代》《麻将》《一一》\n杨德昌的电影大多立足于都市，聚焦于现代人物质生活丰富和精神空虚的矛盾、人性的 “异化” 之痛和疏离之悲等主题。\n他试图通过电影戳破现代人伪善的面具，发掘那些纯粹天真的东西，因此被称为 “现代都市文明的省思者”。\n拍摄于 1991 年，被称为台北三部曲前传的《牯岭街少年杀人事件》，代表杨德昌电影事业的高峰。这部影片改编自 20 世纪 60 年代初的一起真实杀人事件。讲述了家世良好，学习优秀，性格温顺的乖乖仔小四，因为爱上了社会关系复杂的女孩小明，因此陷入到鱼龙混杂的帮派斗争之中。最终沦为杀人凶手的故事，表面上来看这只是一部少年犯罪的影片，但实质上揭示的却是台湾经济起飞时期，社会的动荡、政治的残酷、人性的异化。最终获得金马奖最佳影片和最佳原创剧本两个重量级奖项。\n艺术成就和意义 台湾新电影运动在追求电影的思想性和艺术性时，却忽略了电影的大众性、娱乐性、商业性和观赏性。导致台湾观众对于本土电影的反感甚至厌恶，转而投向好莱坞大片的怀抱。这种情况不仅导致了新电影运动在80年代中后期逐渐衰微，而且导致了观众对本土电影失去信心。\n“新电影” 的衰微 自 1985 年起，台湾产量与发行量较多的电影公司产量不断萎缩，本土电影的票房一路下滑，所以有批评者认为 “新电影运动害惨了台湾电影”。\n1998 年，台湾电影产量不到 20 部。2006 年台湾电影的市场占有率仅有 1.62%，而美国好莱坞电影则占据了 95% 以上的电影票房。\n“新电影” 的艺术成就 台湾新电影运动以其鲜明的内容和形式特色在华语电影史上写下浓重一笔。\n在题材上，台湾新电影运动不再像言情片和武侠片那样逃避现实，而是努力从日常生活细节或事既有的文学传统中寻找素材，以无比诚恳的态度为当代台湾人的历史、生活及心境塑像。\n《儿子的大玩偶》鉴赏\n在形式上，不强调完整的戏剧结构和情节，善于用散文方式结构剧情，注重用声、光、影像来表达内涵，通过平凡普通的生活细节和场景片断抒发情感，表现出一种清淡、雅致的艺术风格，给观众留下充分的思索空间。\n主要体现在\n长镜头和景深镜头的大量使用； 对白中方言的使用； 大量起用非职业演员 大量采用实景、外景；偏爱自然光效。 《童年往事》鉴赏（推荐）\n片断：整体中的一部分，零星而不完整。如：「对于老家，仅剩片断模糊的记忆。」也作「片段」。\n台湾新电影运动与大陆的第五代影像革命、香港新浪潮电影运动并称当代华语电影史上最重要的三次电影革新运动。\n经典好莱坞的“大制片厂制度 背景 所谓电影工业，是指 “制片”，“发行”，“放映” 的工业体系。\n电影产业则不仅拥有经济属性，而且拥有社会文化属性。\n电影工业与电影产业 世界电影工业形成了以美国好莱坞为中心，印度宝莱坞和你离日亚的尼莱坞等为中间梯队的格局。\n好莱坞电影工业的发展主要经历了 20 世纪三四十年代的 “经典好莱坞时期” 和六七十年代的 “新好莱坞时期”。\n虽然这两个阶段的电影工业有着不同的发展背景，亦呈现出不同的面貌。但在制作、发行、放映三个环节都有这强烈的好莱坞电影工业风格。从而不仅称为美国社会经济的重要支柱，而且深刻影响着其他国家的电影生产。\n地理学上的好莱坞诞生于 1908 年初，当时导演弗兰西斯鲍格斯为拍摄电影《基督山伯爵》和摄影师来到洛杉矶郊外的这个荒凉村落，建立了第一座摄影棚。当时出售这块土地的人随口命名为其好莱坞。\n1905 年，美国第一家专门放映电影的剧院在宾夕法尼亚州的匹斯堡开张，因其入场费只需一枚五分的镍币而得名 “镍币影院”。\n凭借着低廉的价格，镍币电影院开创的早期电影放映模式大获成功。并推动美国电影放映业的快速发展。直到 1910 年，镍币影院才被更大更豪华的电影放映厅逐渐取代。\n1908 年，美国第一个电影 “托拉斯” 组织，爱迪生的 “电影专利公司” 成立，该公司由美国爱迪生公司（就是那个搞发明的爱迪生，排挤特斯拉的那位）和沃格拉夫公司等七家公司和法国的百带梅里爱两家公司联合组成。\n“电影专利公司” 从各种电影技术发明者那里取得了 16 项专利权，获得了电影胶片唯一生厂商 “柯达公司” 的专卖权。\n关键还在于，电影专利公司还借助法律对相关行业进行控制与垄断。\n同时，该公司在 1910 年成立了专门负责发行的通用影片公司，从而全面控制了美国的电影业。\n“电影专利公司” 这种将制片、发行、放映通过合并、兼并或是购买股权、签署协议等方式集中在一起的垂直整合方式，有效的形成了一种 “纵向垄断”。\n夺笋啊。\n然而，这种垄断却引发了美国独立制片商和发行商的极大愤恨。而当时的好莱坞不仅拥有四季宜人的气候，价格低廉的劳动力和复杂奇特的地形等。关键是，远离纽约和芝加哥又临近墨西哥边境，即电影专利公司一旦提出诉讼，他们很快就可以逃离美国。\n在这样的背景下，众多电影公司便纷纷涌进好莱坞。\n“电影专利公司” 从 1912 年开始丧失在美国电影市场的优势，直到 1917 年彻底消失。究其原因：\n为了降低制作成本，尽量进行标准化的生产，但是并没有将生产流程推向规模化，仍然是 “手工作坊式” 的生产。 “电影专利公司” 生产的影片主要在当街店铺、杂耍场和 “镍币影院” 放映，观众也以下层民众和移民为主，因此经济效益就可想而知。 “电影专利公司” 的最大失误，在于企图通过垄断 “制片业” 来垄断整个电影行业，然后事实证明，垄断 “发行业” 和 “放映业” 才是最有效的途径。 后面好莱坞的八大电影公司，最初都是从放映业开始逐渐扩大影响力和控制范围。\n1913 年，卡尔·莱默尔在好莱坞建立 “环球影城”，标志着好莱坞电影从 “手工作坊” 转变为 “工业化生产”；随后影响遍及全世界的 “八大电影公司” 逐渐形成。这八大电影公司包括 “五大” 和 “三小”。三小。。。。\n五大\n派拉蒙（山峰）\n华纳兄弟（WB）\n米高梅（🦁️狮子头的那个）\n福克斯（20th 的那个）\n雷电华（在1930年代和1940年代，雷电华出品了许多著名影片，如《公民凯恩》《美人计》《白雪公主》《风云人物》《金刚》等。1950年代开始衰退，逐渐退出了电影界，最终转向了电视方面的发展。）\n这五家公司不仅控制了制片业，而且拥有最具吸引力和最高票房的影院。它们在美国各大城市争夺观众，并划分了各自的影院势力范围。\n三小\n哥伦比亚（图标类似自由女神🗽的那个） 联艺 环球（UNIVERSAL 环绕🌍地球） 是指制片和发行规模都比五大公司要小的。\n在 20 世纪 30 年代，好莱坞遭遇经济危机时，摩根和洛克菲勒两大财团，控制了除华纳兄弟之外的七家定影公司，也正是由于两大财团的介入，使得八大公司之间的关系盘根错节，即根本不可能展开真正意义上的竞争，也不可能彻底垄断市场 。于是在互惠互利的情景下，八大公司逐渐形成了，制片、发行、放映的横向联合。\n总体来说，由于这种严密的 “纵向垄断” 与 “横向联合”，使得好莱坞在 20 世纪三四十年代不仅包揽了美国电影 90% 的产量，而且有效排挤了独立制片公司和外国电影公司，其产量占据当时全世界的 60%。\n制片特点 20 世纪 20 至 50 年代，大制作片厂制度在好莱坞逐渐形成，其囊括了流水线的生产方式、制片人中心制、明星制度、学徒式的人才培养机制，和以海斯法典为核心的审查机制等基本要素。\n关于海斯法典的，上面提到过，1930 年颁布的。\n电影制作守则（Motion Picture Production Code）是1930年至1960年适用于美国电影的行业道德规范，由于时任美国电影制片人与发行人协会主席为威尔·海斯，该守则又被称为“海斯法典”（Hays Code）。在海斯的领导下，美国电影制片人 与发行人协会，即后来的美国电影协会于1930年采纳了该守则并从1934年开始严格执行。该守则详细说明了在美国面向公众，什么样的电影可以接受，什么样的电影不可接受。1968年，电影制作守则被美国电影分级制度代替。\n大制片厂的最大特点是流水线（Pipeline）的生产方式。1908 年美国人福特开创性以流水线生产方式，通过组装配件进行汽车生产，从而极大降低了成本，也使大规模的批量生产成为可能，被誉为现代大机器生产的代表。\n1913 年，美国独立制片人兼导演托马斯·英斯意识到这种生产方式的价值，便建立了类似的电影生产模式，从此 “流水线的生产方式” 就成为了好莱坞电影工业的标志。\n随后，在好莱坞的鼎盛时期，这种方式不断成熟。从而既保证了片源的丰富与稳定，又催生了电影类型片的出现。在这种流水线的生产方式中，导演对电影的整体把控权被剥夺了，取而代之的是强化了制片人的控制权，即形成了制片人中心制。\n制片人中心制\n“制片人中心制“ 突出了制片人在实现电影商业价值过程中的关键性作用，因为制片人可以根据电影的市场状况，随时更换演职人员，甚至还可以任意更改剧情。\n好莱坞制片人中心制的经典案例，就是在 1939 年拍摄电影《乱世佳人》时，制片人塞尔兹尼可就曾经先后撤换了三、四位导演。在制片人中心制下，制片人不仅可以撤换导演，也可以随意更换演员。因为大制片厂制度中的演员是获得电影票房、赢得商业利益的重要保证。于是这就意味着制片人既可以发现和捧红某个明星，也可以在一夜之间毁掉某个明星，即形成了好莱坞独有的明星制度。\n明星制度\n好莱坞的 ”明星制度“ 有两个方面含义：\n一是 ”明星签约制“，指通过签订合约使用明星隶属于某个制片公司，而当时明星的签约年限一般都在七年以上，因此明星往往就成为了某个公司的财产。\n二是指大制片公司在进行某些重要的电影创作及宣传时都要围绕明星展开，而旨在使明星成为电影的品牌。\n特点\n“大制片厂制度” 下的好莱坞以 “学徒制” 作为培养电影人才的主要模式。从本质上来看，这种人才培养机制只是教会这些人如何快速融入好莱坞的 “大制片厂制度”，其同时促成了好莱坞电影类型片产生与繁荣。\n“学徒式的人才培养机制” 很容易造成电影人创造力的枯竭，因此好莱坞总是想方设法从欧洲和其他国家挖掘成熟的导演，或是成名的演员等，以补充自身人才培养的缺陷，从而既能够保证好莱坞电影工业的延续，又能够使电影创作不断获得新的灵感与资源。\n好莱坞大制片厂生产的电影，在上世纪三十至六十年代深受《海斯法典》为核心的审查机制的影响。\n海斯法典\n是美国在 1930 年颁布的限制电影内容的审查法规；该法规由时任 “美国电影制片人和发行人协会” 主席的威尔·海斯执行，所以被称作 “海斯法典”。\n《海斯法典》主要有 3 项基本原则和 12 大项禁止的内容。如遵守禁酒令、不得宣扬烧酒、不可详细描述谋杀、盗窃、抢劫的方法等。\n著名的《海斯法典》案例，就是希区柯克在 1946 年拍摄电影《美人计》时，鉴于法典规定吻戏不能超过三秒，于是就让男女演员吻三秒停一下再吻。最后电影中的加里格兰特就抱着英格丽褒曼，连续并间断的吻了两分半钟。\n《海斯法典》在当时对美国电影的影响极大，从 1930 年到 1960 年的每一部影片都要严格遵守其规定。\n1966 年伊丽莎白·泰勒主演的《灵欲春宵》上映，这部获得 13 项奥斯卡提名的影片由于有大量的粗口，第一次明确标出：“18 岁以下观众需要父母陪同观看”。\n以《灵欲春宵》这部电影为节点，《海斯法典》在 1966 年正式废除，取而代之的是美国 “电影分级制度”，从此美国电影翻开了全新的一页。\n值得一题的是，好莱坞大制片厂制度还引进了观众学研究。\n20 世纪 40 年代，由于海外市场的丧失等原因，好莱坞电影的整体市场份额有所下降，为了继续保持对电影市场的控制优势，好莱坞的大制片公司便引入了观众学研究。最早进行电影观众学研究的关键人物是乔治·盖洛普。\n盖洛普在 1938 年底到 1939 年初针对电影《乱世佳人》的观看兴趣分析中，发现了一个问题，很多人都读过《乱世佳人》的小说，但其中绝大部分都没有打算去观看这部改编电影，同时还有约三分之二的人不知道影片主角的扮演者是费雯丽 。基于观众调查的情况，盖洛普告诉这部电影的制片人，一方面要把《乱世佳人》拍成彩色片，另一方面要将宣传重点放在女主角费雯丽身上。也正是得益于盖洛普的观众学研究，《乱世佳人》才创造出了世界电影史上的票房奇迹和艺术奇迹。\n上述这些大制片厂的特点，共同促成了好莱坞电影类型片的出现与繁荣。其实，好莱坞大部分类型片在上世界 20 年代末就已经初具规模，到 30、40 年代更是占据了统治地位。\n当时最经典的类型片有：\n喜剧片 西部片 犯罪片 幻象片等 关键在于好莱坞还采用热潮更替的方式进行电影类型片的生产，即在观众厌烦了某一种类型之后，会及时更换为另一种类型，如此周转不息的反复轮换，从而保证好莱坞电影一直都是观众的观看热点。\n发行特点 大制片厂制度下的好莱坞电影工业，在发行发面针对国内市场和国外市场采用了不同的策略，以保证其电影发行的长盛不衰。针对国内的电影发行，好莱坞首先以垄断的方式打击独立制片商和外国电影势力。\n当时好莱坞八大电影公司主要有三种方式操纵电影发行：“成批订片” “盲目订片” 和签订有利于发行商的租片合同。\n成批订片 是指放映商要想购买某部由大明星主演的影片，就必须同时购买一部由一般演员主演的影片。即使明知道这些电影会亏本，但为了获得明星主演电影的发行权，就不得按照制片公司的要求去批量购买。\n最早出现于 1916 年的派拉蒙公司，后来发展为好莱坞的一种电影发行惯例。尤其是大制片公司都会利用明星的影响力，强制搭售一般的影片。\n盲目订片 要求放映商在没有看到电影之前，就必须签订放映合同。\n“成批订片” 和 “盲目订片” 作为好莱坞 “大制片厂制度” 的产物，能够有效保证制片这个最不稳定、风险最大的行业获得稳定的收入，刺激制片公司将更多的精力用于制片而不是发行和放映，从而保证 “大制片厂制度” 的稳定运行与经济效益。\n然而这种一揽子交易也在相当程度上损害了独立放映商的利益，同时也限制了外国电影进入美国。\n针对国外的电影发行，早在第一次世界大战期间，好莱坞就以低价销售的策略，轻而易举的占领了外国市场。\n低价销售 指好莱坞大制片公司通过海外代理机构，以低于竞争对手的价格将电影租给当地放映商，从而控制其它国家电影发行的策略。\n为了保护本土电影市场，20 世纪 20 年代的欧洲不断开展抵抗好莱坞电影的运动。\n好莱坞当然不会示弱。\n一、美国政府对其全力支持，不仅帮助好莱坞制定合理的出口政策，还通过贸易谈判等为电影出口进行辩护。\n二、”八大电影公司“ 也通过设立办事处等进行国外的电影发行，并以投资的方式控制其它国家的电影企业。\n三、美国民众也抵制外国电影的进入。\n1922 年德国表现主义电影的经典之作《卡里加里波士》在洛杉矶举行首映时，美国民众就因为担心电影市场落入德国手中，而展开了强烈的抗议活动。关键在于，好莱坞还不断挖走其它国家的优秀电影人才。\n如对德国电影人才的引进，20 年代中期，弗里兹·朗、刘别谦等优秀的德国电影人相继离开德国去了好莱坞。到 30 年代，更多的欧洲电影人为躲避法西斯的迫害纷纷前往好莱坞，这样虽然给好莱坞带来了全新的艺术理念和创作资源，但是确使本国的优秀电影人才流失，从而不再可能与好莱坞形成竞争。\n放映特点 除了在制片和发行发面特点鲜明。\n好莱坞 “大制片厂制度” 中的 “放映” 也形成了自己独特的方式，主要有 “映轮——映区——轮空” 和 “双片放映 ”。\n映轮——映区——轮空，是指在一部电影拍摄完成之后，首先以较高的票价在地段和设施都比较好的 “首轮影院” 放映，一般来说这次首轮这次放映的收入最多。然后在相隔一段时间之后，再进行影片的 “第二轮放映”，而影院的豪华程度、所处的地段和电影票价也都比首轮放映时要低，同时收入也会相应减少。首轮放映和第二轮放映之间的时间间隔期，就被称为 “轮空”。\n事实证明，好莱坞大制片厂制度的这种 “映轮——映区——轮空” 机制，非常有效的控制了电影的放映业，同时成功排斥了独立制片和外国电影。当然也不可避免的损害的广大电影观众的利益。\n双片放映，是指每次都放映两部影片：第一部是正片，即通常所说的 “A 级片”，第二部是 “加片”，即 “B 级片”。\n一般来说，“加片” 既有大制片公司生产的影片，也会有独立制片公司生产的影片，但是这些电影在制作成本和质量等方面都无法与正片相比，而采用 “双片放映” 的目的，就在于招揽观众和加速大制片公司的资金周转。\n值得一提的是，B 级片在相当程度上为电影新人提供了机会，也为电影的艺术创新留下了难得的空间。因为 B 级片没有 A 级片那么严格，很多难以获得 “A 级片” 拍摄资格的青年电影导演，就可以利用拍摄 “B 级片” 的机会，充分发挥自己的才能；同时 “B 级片” 导演也拥有更多的创作自主权，因此可以在电影的创作中进行创新。\n事实证明，后来的新好莱坞电影的出现，就与 昆汀·塔伦蒂诺、蒂姆·伯顿等当时一大批 B 级片导演的努力密不可分。\n总结 总体来说，大制片厂制度下的制片、发行、放映都成了好莱坞的电影工业体系，从而保证了好莱坞电影的稳定生产与在世界范围的影响力。\n从“经典好莱坞”到“新好莱坞” 背景 社会背景 从稳定繁荣到动荡不安。\n经典好莱坞电影繁荣的三四十年代，是美国社会的平稳上升期，而六七十年代的美国社会各方面矛盾激化：不仅有第二次世界大战带给人们的心理创伤，而且战后的冷战格局，以及美国奴隶制的历史遗留问题等，都使人们出现了强烈的危机感。\n1963 年 “肯尼迪遇刺” 和同年爆发 “越南战争” 为直接导火索，美国国内开始了大规模的 “反战游行” 和 “民权运动”。\n在文化领域，青年一代的反传统狂潮。如嬉皮士运动，迷恋摇滚乐等也一发不可收拾。在这样的背景下，经典好莱坞电影那种单一闭合的叙事表达，已经不能够满足人们的观影需要，于是便激发了新好莱坞的出现。\n其次，二十世纪美国的娱乐形式也经历了从电影主宰到电视分流的发展过程。1905 年的第一家镍币影院出现后，电影很快就取代马戏团、歌剧院等成为最大的娱乐业。随后八大电影公司通过在制作、发行、放映环节的扩张，在三四十年代达到顶峰。\n原因 然而从六七十年代开始，电视成为了美国人最主要的娱乐方式。同时电影的观众群体也发生了变化。\n由于电影以更加通俗大众的方式分流了普通平民阶层的大量观众，那些文化层次较高、收入也较高的人们就成为主要的电影观众，而这些观众都有着一定的反思意识和社会文化参与意识，于是他们期待在电影中看到更多的社会批判内容。\n另一方面，二战后的生育高峰使 12 至 29 岁的青年人成为新的电影观众群体，并且占到观影总人数的 90%。作为在电视机前长大的一代，他们惯于用眼睛思维，而要想将吸引这部分受众，就必须进行电影语言的创新。\n经典好莱坞电影的制作、发行、放映完全被八大电影公司垄断；后来美国最高法院判定了八大电影公司的垄断行为，于是它们便放弃了这三个环节中利润最低的放映，同时开始重视利润更大的发行：每年除了制作十几到几十部数量不等的影片之外，也开始自主发行独立生产的影片——这实际上为 “独立制片” 的兴起和电影人摆脱大制片厂制度提供了机会。\n文化转型：从美国中心 到 “欧洲旨趣” 。\n第二次世界大战结束之后，欧洲电影开始复兴，并且形成了与好莱坞风格迥异的文化表现与艺术特征，而 “意大利新现实主义电影运动” “法国新浪潮电影运动” 等都深深吸引并影响了好莱坞的年轻电影人，于是他们便邀请欧洲电影到美国讲学、交流电影的创作经验。\n1967 年的两部影片 《邦尼和克莱德》、《毕业生》为标志，美国正式进入 “新好莱坞电影” 的发展时期。\n其中 《邦尼和克莱德》由舞台和电视出身的导演 阿瑟·佩恩 执导。故事取材于 30 年代美国一对银行抢劫犯的真实经历。他们的犯罪行为被影片呈现为个人反抗社会的壮举。因为电影工作者希望通过这雌雄大盗，进行一种批判性的社会反思。\n影片的类型属于传统的 “强盗片”，但又明显受到 “法国新浪潮电影”，尤其是戈达尔的影响。这部影片的出现在当时引起了全世界的关注：美国《时代周刊》称其是 “美国新浪潮电影” 的化身；英国《女王》杂志称 “1967 年是《邦尼和克莱德》年”。\n相比于《邦尼和克莱德》的传奇色彩，麦克尼·科尔斯执导的《毕业生》（是的，就是那个逃婚后坐到公交上，迷茫眼神的那个），则将目光投向当代美国青年人的生活。准确把握了青年人初入社会时的迷茫，受到青年观众的普遍喜爱与共鸣，同时还留下了《斯卡布罗集市》、《寂静之声》等传唱至今的经典电影歌曲。\n随后，新好莱坞电影便开始快速发展，相继出现了\n丹尼斯·霍珀的《逍遥骑士》 罗伯特·阿尔特曼的《陆军野战医院》 乔治·卢卡斯的《美国风情画》 马丁·斯科塞斯的《穷街陋巷》和《出租车司机》 等经典之作。\n其中电影《逍遥骑士》受到战后垮掉一代的代表人物，杰克·凯鲁亚克的名作《在路上》的影响。以公路片的形式讲述了两个嬉皮士的漫游经历，影片有着明显的纪实风格，从中可以窥见上世纪六七十年代，美国光怪陆离的社会图景，以及青年一代的梦想迷惑和反抗。\n嬉皮士和朋克相关的内容，甚至可以看看窺探未來：全面瞭解賽博朋克Cyberpunk【就知道玩遊戲31】\n新好莱坞的青年导演群 新好莱坞对世界电影发展的最大贡献，就是出现了一批至今仍然活跃在影坛，颇具实力与影响力的导演。这些导演在 20 世纪六七十年代，刚刚迈出大学校门后不久，就有了独立拍摄电影的机会，并在当时形成了影响力极大的青年导演群。\n这个青年导演群的主要成员有：弗朗西斯·科波拉、马丁·斯科塞斯、乔治·卢卡斯、史蒂芬·斯皮尔伯格等。\n弗朗西斯·科波拉 新好莱坞青年导演群的领军人物，非弗朗西斯·科波拉莫属。\n“教父” 系列电影，是传统类型片中的 “黑帮片” 与导演个人风格完美结合的典范之作。\n《教父》根据马里奥·普佐的小说改编，以美国黑手党柯里昂家族三代人的生活为主线，突破了传统黑帮片以犯罪故事为主的叙事陈规，而是深入人物内心深处，反映他们置身多重人生角色矛盾旋涡中的艰难抉择。影片不仅有着严谨的叙事结构和鲜明的人物形象，而且具有深厚的历史感和悲剧感。\n此后，科波拉创作的《对话》、《现代启示录》等影片，都愈发远离了经典好莱坞的类型片原则，而更为突出和强调个性化色彩。\n马丁·斯科塞斯 新好莱坞青年导演群的重要人物之一，马丁·斯科塞斯在 1973 年拍摄的《穷街陋巷》是他电影生涯中的第一部重要作品，影片通过对意大利移民后裔在曼哈顿下东区艰难生活的细致描绘，体现出明显的导演个人风格，而这种个人风格在他 1976 年拍摄的另一部电影片《出租车司机》中得到了进一步的延续与发展。关键在于影片《出租车司机》还以强烈的悲剧气息，展示了越战后美国社会的迷茫，并将斯科塞斯推向了大师级电影导演的行列。\n此后，马丁·斯科塞斯还导演了《愤怒的公牛》、《基督最后的诱惑》、《纽约黑帮》、《无间道风云》等影片。\n乔治·卢卡斯 与其他青年导演相比，乔治·卢卡斯有着更为多重的身份。\n作为导演，他拍摄了科幻电影的杰出作品，星球大战系列影片。 作为制片人，他监制了斯皮尔伯格导演的冒险片经典之作《印第安纳·琼斯》系列三部曲。 作为老板，他在 1972 年成立的 “卢卡斯电影有限公司”，至今仍然是全世界规模最大的独立电影制片公司。 客观而言，乔治·卢卡斯对电影类型片的兴趣比较单一，并主要集中在拍摄科幻片上，而他创作的唯一一部非科幻电影《美国风情画》，作为其在新好莱坞时期的代表作品，讲述上世纪 60 年代几位刚步出高中校园的加州少年，即将因为不同的人生选择而各自发展，通过详细描绘他们在小城一夜间的经历，反映出越战前夕美国青年人的思想感情等。其中大量运用了 50 年代的流行摇滚音乐，从而使影片充满了浓厚的怀旧气息 。\n史蒂芬·斯皮尔伯格 后来成为了世界电影史上最具影响力的导演之一，他在新好莱坞时期拍摄了职业生涯中的第一部成功的作品——1974 年的《大白鲨》。作为一部恐怖片，《大白鲨》展示了斯皮尔伯格对观众心理的卓越把握能力，以及对电影节奏的准确掌控。\n斯皮尔伯格是 “青年导演群” 中最具类型意识、题材选择也是最为广泛的导演。后来拍摄了科幻片《E.T》《人工智能》等，还富有开创性的将科幻片与恐怖片融合创作出《侏罗纪公园》以及寻宝冒险片的经典之作——印第安纳·琼斯系列。\n斯皮尔伯格在上世纪 80 年代之后拍摄的《辛德勒的名单》、《拯救大兵瑞恩》、《慕尼黑惨案》等影片都展示了他对历史对人生思考的深度和广度，体现出其将类型片的商业元素与导演的个人风格结合的高超能力。\n新好莱坞电影的特点 与其说新好莱坞是对经典好莱坞的革命，是新与旧之间的对抗，不如说是好莱坞是在尊重经典好莱坞基础之上的丰富发展与重组进步。\n客观而言，新好莱坞继承了经典好莱坞的生产方式和类型片的工业传统，同时借鉴并融合了欧洲电影的艺术表现，从而给美国电影带来了深远的变化，并呈现出新的特点，主要体现在 “类型意识的突破” “作者风格的确立” 和 “镜语体系的革新” 三个方面。\n1. 类型意识的突破 将电影类型片带入了一个新的时代，经典好莱坞时期的电影类型片是狭义的，每种类型自成体系结构闭合，且类型之间也少有交叉。\n20 世纪六七十年代，美国社会充满了激烈的矛盾冲突与文化碰撞，经典好莱坞类型片那种稳定、闭合的结构便开始与观众的观影期待之间产生距离。于是，新好莱坞不再以单一的类型模式进行创作，而是将各种类型作为电影元素进行使用，从而促成了 “类型融合” “超类型” “反类型” 等的出现。\n2. 作者风格的确立 “法国新浪潮电影运动” 提出的 “电影作者” 观点在新好莱坞时期被引入美国，主要用于反抗标准化的电影制作；同时法国《电影手册》杂志还评选出了在好莱坞商业体制内创作，但并不随波逐流，具有鲜明导演个人风格的 “电影作者”。\n如奥逊·威尔斯、希区柯克、霍华德·霍克斯、约翰·福特等。记住这几个导演，都是顶级导演，如果看过《电影艺术：形式与风格》的话，里面会经常提到。\n3. 镜语体系的革新 一方面，新好莱坞电影抛弃了经典好莱坞搭镜拍摄的习惯，采用实景拍摄，从而增加了影片的真实性；\n另一方面，新好莱坞电影打破了经典好莱坞电影线性叙事的闭合结构，对故事情节进行一种非戏剧化的处理。\n此外，在人物设置上，新好莱坞电影偏好以充满反抗意识、但寻找不到出路的成长中的青年人为主角，着力刻画他们复杂的内心世界和面对现实时的迷惘与无奈，注重对人物个性的展现。\n好莱坞的扩张极大促进了美国电影工业的发展，并确立了其在世界影坛的霸主地位。\n据相关统计，从上世纪 90 年代开始，好莱坞每年约有一半的电影票房都来自海外市场，而相比之下，外国电影在美国市场份额却不足 10%，其实各国对好莱坞称霸都充满了焦虑，一些国家的电影人还行动起来抵制好莱坞。如在 1995 年 12 月 28 日，即世界电影诞生 100 周年的纪念日，法国影星阿兰德龙就在巴黎协和广场进行了一次反抗好莱坞的行为艺术，将一盒好莱坞电影的拷贝当众销毁，从而发出法国作为世界电影诞生地的一声怒吼。1998 年韩国国民导演林泽权也和许多韩国电影人一起，开展了声势浩大的光头运动，抗议美国在韩国自由放映电影，并以胜利告终。\n虽然这些运动体现出各国电影人对本民族电影的热情与坚守，但是到目前为止，好莱坞的霸主地位始终没有动摇。\n置身当前的时代语境，好莱坞电影工业呈现出 “电影创作兼收并蓄” “数字技术主导世界” “电影工业发展全球化” 的特点。\n电影创作兼收并蓄 好莱坞自建立之初就十分重视吸收利用其它国家的电影资源，如直接聘用国外知名导演到好莱坞拍摄电影。德国导演刘别谦， 英国导演希区柯克都是在好莱坞实现的事业巅峰。同时还对其它国家的优秀电影作品进行改编再创作。如重拍了日本电影《谈谈情跳跳舞》《午夜凶铃》香港电影《无间道》（有内鬼，终止交易！！）等。好莱坞还选取其它国家的典型时代事件，或是民族色彩强烈的神话传说，作为基本素材进行电影创作。如拍摄了《埃及艳后》《特洛伊》《花木兰》《指环王》等。关于指环王的详细解析，可以看青蛙刀圣的解说视频。\n此外，好莱坞还吸收其它国家最具民族特色的文化元素，将其与各种类型片融合，创作出具有多元文化背景的电影作品。如将中国功夫融入好莱坞动作片的《杀死比尔》《功夫熊猫》等。还有今年的《Raya and the Last Dragon》中文名《寻龙传说》，公式化的情节、定型化的人物、图解式的视觉形象。这就是类型片，上面说过了。说实话，这个电影对东南亚文化理解只是浮于表面的，只是各个文化的堆砌，大杂烩，我是不会买账的，浪费我在腾讯视频上买这电影的钱。如果你希望从这电影中感悟什么，获得什么，你将会浪费 108 分钟。\n全球化时代好莱坞电影工业的第二个特点是 “数字技术主导世界”。从 2005 年以来，约 80% 以上的好莱坞电影都是通过数字技术制作画面，同时几乎所有的电影声音也都是由数字处理的。尤其是《侏罗纪公园》中逼真的恐龙，《终结者》中的液态机器人，还有《泰坦尼克号》中规模巨大的灾难场景等，可以说好莱坞的数字技术的发展令其它国家望尘莫及。\n全球化能够带给电影更多的投资和跨国产权，从而有效分担电影拍摄日益攀升的成本与相应的投资风险。除了充分吸纳各国的资金，与主要经济大国进行电影生产的合作，好莱坞各大电影公司还纷纷在其它国家建立子公司。\n2003 年中国电影产业发展的初期，美国华纳电影公司就以参股 49% 的方式与上海永乐电影城合作。\n2004 年华纳再次与广州金逸合作，投资建设具有世界一流水准的多厅影院。\n总体来说，如今的美国好莱坞继承着经典好莱坞确立的类型片传统，发扬着新好莱坞对电影观念和工业体制不断改革的优势，同时利用最先进的数字技术，并牢牢把握着全球化的时代特点，继续占据着世界影坛的霸主地位。\n新生态与新格局：中国电影产业 前奏：中国电影开始全面改革 1993 年中国电影拉开了全面改革的大幕，随后在港片合作片中分账制度被引入内地，于是从 1994 年起，我国开始了以分账大片的形式，引进世界各地的优秀影片。进入新世纪以后，以 2001 年我国加入世界贸易组织为契机，中国电影改革十年之后的 2003 年，真正开始了产业化发展，并在当下呈现出新生态与新格局，成为社会文化生活的重要组成部分。\n一 改革之前的中国电影产业 上世纪 80 年代我国改革开放之初的电影产业，是在新中国学习苏联电影的基础上发展而来的。\n特点：\n“生产 ” 与 “发行、放映” 的政企合一。\n生产：电影生产以指令性的计划指标进行；\n发行、放映：发行放映实行从中央到地方的垂直管理体制。\n中央——“中国电影发行放映公司”\n地方——“电影发行放映公司”\n这种模式在计划经济年代保证了电影的经济效益，也保证了电影能够在全国放映，但是中影公司作为唯一拥有独立电影发行权的公司，全国所有制片厂生产的电影，都要交给中影公司统购统销，这种行政性和非市场化的电影产业机制，经过计划经济年代的辉煌之后，其弊端随着改革开放的深入而逐渐显现。\n弊端：\n由于制片机构没有经营自主权，影片就不能直接面向市场，这样就对形成统一开放、竞争有序的电影市场形成了阻碍。 由于发行环节过多，各电影厂的收入早已不能维持生产，于是地方电影公司要求 “自主经营、独立核算” 的呼声日益高涨。 二 改革的开始 1993 年 1 月 5 日，时国家广电电影局颁布了《关于当前深化电影行业机制改革的若干意见》，旨在改变之前计划经济下电影的统购统销，调整制片、发行、放映经济效益分配不合理的状况。\n然而，新的问题出现了，尽管中影公司的垄断经营被打破了，但是各个省级电影发行放映公司，却依然在自己的行政区域内独家经营，垄断发行。这样意味着，过去制片厂只需要面对中影这一家垄断经营者，而现在则要面对全国 32 家地方垄断经营者。\n1994 年 8 月 1 日电影局再次下发文件：《关于进一步深化电影行业机制改革的通知》，明确指出拥有电影发行权的机构，可以直接向除 11 个老少边穷省区之外的 21 个省区各级发行单位，直接进行电影发行。\n这些文件的出台，使电影的经营自主权在政策方面得到了认可。\n三 1994 年引进 “十部大片” 1994 年的 “全国电影发行放映工作会议” 提出：每年要引进十部 “基本反映世界优秀文明成果和基本表现当代电影艺术、技术成就的影片”，即开始了引进电影 “大片” 的时代。\n当你就有一批好莱坞和香港大片，以分账的形式进入内地影院。其中有哈利森·福特主演的《亡命天涯》，作为引进的首部分账大片，以 2500 万的票房成绩创造了内地第一个票房奇迹。\n1995 年，引进十部大片的工作有条不紊的进行着，虽然当年只引进了八部影片，但部部都是经典。\n《红番区》\n类型：港美合作的喜剧动作片 导演：唐季礼导演 主演：成龙、梅艳芳 荣誉：荣获了香港电影金像奖 也是成龙打入美国主流电影市场的里程碑。1995 年 1 月 31 日在内地上映后，很快就以 3500 万的成绩，刷新了内地的电影票房记录。\n《红番区》给内地观众带来了 “贺岁片” 的概念，甚至改变了一直以来春节期间电影院放假关门的状况。\n《真实的谎言》\n导演：詹姆斯·卡梅隆\n主演：阿诺·施瓦辛格\n影片从隐藏身份的 FBI 特工与妻子琐碎的家庭矛盾入手，在不断的误会和意外下展开正邪的对抗 。作为施瓦辛格的硬汉动作片的巅峰之作，该片场面宏大，气度非凡，且不乏喜剧元素。\n《狮子王》\n类型：动画电影\n荣誉：奥斯卡 “最佳配乐\n​\t奥斯卡 “最佳原创歌曲”\n影片的脱胎于哈姆雷特，除了波澜壮阔的情节和成功的人物形象塑造，还有获得奥斯卡最佳配乐、最佳原创歌曲等多首经典电影歌曲。\n《阿甘正传》\n主演：汤姆·汉克斯 特点：电脑特效的运用 荣誉：奥斯卡 “最佳影片奖” 影片讲述了一个智商只有 75 的低能儿不断奔跑的故事，将真伪历史杂糅于一体，其中对电脑特效的运用堪称经典，这部电影还打败了《肖生克的救赎》获得当年奥斯卡最佳影片奖。\n《廊桥遗梦》\n导演、主演：伊斯特伍德 这部改编自同名爱情小说的电影，讲述了一段艳而不淫、哀而不伤、既宣泄了激情又照顾了道德的浪漫邂逅。\n《勇敢者的游戏》\n类型：奇幻家庭喜剧 主演：罗宾·威廉斯 特点：电脑特效 影片对电脑特效的运用深受《侏罗纪公园》的影响，同时阖家欢乐的定位也非常讨巧。\n《纽约大劫案》\n主演：布鲁斯·威利斯 警察形象被评为 “电影史上最棒的警察”。\n《玩具总动员》\n是为皮克斯动画打下江山的首功之臣，这也是全世界第一部完全使用电脑技术的动画电影。\n玩 3 也是我认为这个系列电影的 “最终章”，玩 4 只是给了一些 “惊喜”。\n十部大片的引进在活跃中国电影市场的同时，也促使中影公司和各级发行放映公司的改革，并在实行现代企业制度、扩大经营规模、实现院线制等方面都进行了有益的探索。于是中国电影市场终于在 90 年代中期开始复兴，并且也吸引了境内外的大量资金，从而为中国电影的全面产业化发展奠定了必要的基础。\n开启：中国电影的全面产业化 引进 “大片” 加入 WTO 后，我国引进电影大片的数量由 10 部增加到 20 部。同时为了限制美国电影的市场占有率，还在 2004 年明确规定引进的这 20 部电影中，必须有 6 部是非美国生产的影片。\n2012 年，引进大片的数量由 20 部增加至 34 部，其票房分成比例也由 13% 调调整到 25%。\n最新的引进进口大片的 “配额制度” 谈判，也从 2017 年就已经展开。\n中国电影 “大片” 2002 年张艺谋导演的影片《英雄》上映，标志着中国大片时代的到来，伴随而来的还有内地电影市场近十年低靡的终结。\n影片《英雄》讲述战国末期三大刺客欲杀秦王的故事，其从筹备策划到拍摄制作，再到宣传发行都采用了不同于以往的市场化模式，最后《英雄》也以内地票房 2.5 亿元的成绩，创造了国产电影的票房神话。\n随后，张艺谋还拍摄了《十面埋伏》《满城尽带黄金甲》《金陵十三钗》等电影大片，也都票房成绩斐然。2004 年的《十面埋伏》，以《英雄》所开创的 “大明星、大投资、大宣传、高回报“ 模式，让中国电影大片走向了品牌化的时代，从而掀开了中国电影产业发展的新篇章。\n同时，这部电影还与当年王家卫的《2046》冯小刚的《天下无贼》周星驰的《功夫》一起，引发了新世纪中国电影市场的一次高潮。\n中国 “电影院线” 中国电影在 2002 年开启大片时代的同时，也开始了电影的院线制改革。\n概念：\n电影院线简称 “院线”，是指以影院为依托，以资本和供片为纽带，由一个电影发行主体和若干影院组成的电影发行，放映的经营机制。\n特点： 对旗下影院实现统一排片、统一经营、统一管理。\n2002 年我国有 35 条院线正式挂牌营业，这 35 条院线共有影院 1019 座，银幕 1834 块，而在十年后的 2012 年，中国电影院线的银幕数量就已经达到了 13118 块，从 2012 年至今更是发展迅猛，银幕数量也呈爆发式增长。2017 年的银幕总数已经达到了 50776 块，稳居世界第一。\n从 2004 年《关于加快电影产业发展的若干意见》提出 “深化院线制改革” 之后，这种 “统一品牌、统一供片、统一经营、统一管理” 的院线制，就成为了中国电影发行放映的主要方式。而改革后的电影院线，也彻底摆脱了事业单位的属性，成为身份明晰的市场主体。\n目前我国形成了以十大院线为核心，各省级院线为补充的发展格局。同时全国大多影院都在十大院线的旗下，这十大院线包括：\n万达 上影联和 中影星美 大地 中影南方新干线 广州金逸珠江 浙江时代 背景新影联 浙江横店 中影数字 与 2002 年院线制改革同时进行的，还有影院的建设与改造，主要是多厅化和数字化。\n我国第一家五星级影院：“北京华星影城” 也在 2002 年 7 月 12 日盛大开业。\n随后上海永乐影城、广州中华广场电影城、深圳新南国影城等多家五星级影城，也纷纷在各大城市出现。\n发展：2003-2013 年的中国电影产业 在此时期，中国电影产业发展呈现出了一些新的特点\n一 电影市场规模不断扩大，电影投资多元化 从 2003 年中国电影开始产业化发展以来，电影市场一直就保持着较大幅度的增长。\n以 2008 年为例，在当年总额 40 多亿的票房成绩中，国产电影就贡献了 25 亿多元，超过总数的 60%。\n《长江七号》《画皮》《功夫之王》《大灌篮》《赤壁》《非诚勿扰》《梅兰芳》等 8 部影片的票房总额就接近 20 亿。\n其中吴宇森导演的《赤壁》，国内票房收入：3亿多元，全球票房收入： 7 亿元人民币\n同时 2008 年上映的国产电影中，有约一半以上都由民营资本参与了投资，关键是之前根本不会考虑对电影行业贷款的银行，也从 2008 年开始将注意力投向中国电影产业。如《画皮》《非诚勿扰》等影片，就是以 “版权抵押” 的方式向银行贷款，从而拓宽了我国电影的融资渠道。\n二 电影产量和票房持续增长 自中国电影开始全面产业化发展以来，产量和票房的持续增长已经成为了一种常态化的状态。\n三 中小成本电影异军突起 中国电影进入产业化时代以来，许多中小成本电影也另辟蹊径，以关注社会现实问题的题材优势异军突起。许多影片还取得了出人意料的票房成绩。\n2011 年改编自鲍鲸鲸同名人气小说的 《失恋 33 天》就以 1400 万的投资获得了 3.5 亿元的票房收入，成为中国电影产业发展过程中，中小成本电影异军突起的典型案例。这部影片以亲切不失幽默的方式，讲述了女主角从遭遇失恋到走出心理阴霾的 33 天，作为我国内地首部为光棍节量身打造的治愈系爱情电影，在 2011 年 11 月 8 日上映后 4 天后，票房就突破了亿元大关。\n四 单片票房 过亿的电影频繁出现 2010 年中国电影的全年票房首次突破百亿元大关。随后，亿元电影俱乐部的会员不断增加，其中不仅有商业大片，还有很多中小成本的电影也开始拥有过亿的票房。\n如 2012 年的贺岁片《人在囧途之泰囧》，总投资不足 8000 万，票房收入 12.6 亿元。\n2013 年票房排行前十的电影《致我们终将逝去的青春》《北京遇上西雅图》《中国合伙人》（陈可辛导演）等，单片投资都没有过亿，但都轻而易举的获得了过亿的票房收入。\n五 3D 和 IMAX 电影也在快速发展 2010 年 1 月 21 日，国务院办公厅颁布 “关于促进电影产业繁荣发展的指导意见”，明确指出中国电影产业在 2010 年的发展重点：是大力繁荣创作生产、积极培育新型企业、加强数字影院和电影院线的建设。于是，3D 和 IMAX 就成为了我国数字影院发展的核心。\n2009 年詹姆斯·卡梅隆执导的《阿凡达》作为第一部在我国上映的数字票房赶超胶片票房的影片，不仅展示了 3D 带给了中国电影产业的变化，而且反映出中国电影市场的巨大容量与需求。\n2012 年，“巨幕数字放映系统” 在我国正式开始运营，从而打破了美国电影 IMAX 格式的垄断。此后，我国 3D 数字和 IMAX 巨幕放映设备的普及率不断提高，国产 3D 和 IMAX 电影的制作水平也在不断攀升。仅在 2012 年，就有 12 部国产 3D 电影上映，同时还有《十二生肖》《一九二四》等影片尝试以 IMAX 格式与观众见面。\n可以说得益于中国电影的全面发展，中国电影产业呈现出蓬勃向上的态势。\n成熟：2013 年至今的中国电影产业 2013 年至今的中国电影产业不断发展成熟，并在制片发行放映等环节，呈现出更具时代性的特点。\n首先要强调的是，中国电影产业的发展正是得益于国家相关政策的保障，上世纪 90 年代中国电影开始市场化改革之初，正是依赖当时的政策才能够有条不紊的展开。\n在如今产业化发展的新阶段，以 2016 年 11月 7 日颁布的《中华人民共和国电影产业促进法》为代表，这些政策的出台都对我国电影产业的健康发展、电影市场化的规范与完善等起到了基础性的制度保障。\n中国电影产业整体都深受互联网的冲击，电影制片业在这样的背景下，逐渐形成了传统电影公司、互联网电影公司，以及与互联网公司合作的众多中小型电影公司并立的格局。\n”传统电影公司“ 主要以 “中影” “华谊” “光线“ ”博纳” “万达” 等为代表。\n“互联网电影公司” 主要以 “阿里” “腾讯” “爱奇艺” 等为代表。这些公司都是近年活跃在中国电影制片业中的主力。\n互联网不仅深刻的影响着电影制片，而且在相当程度上颠覆了传统的电影发行，长期以来，我国电影发行都只是依靠推广宣传扩大营销的覆盖范围。但这种方式的弊端，大城市进行宣传相对容易，在数量庞大的中小城市则相对比较困难。\n“互联网+” 电影：充分利用互联网无处不在覆盖范围与影响力，在中小城市实现比较充分的营销渗透。甚至近年的中国电影中还出现了一种被称为自来水的现象。\n“自来水”，意为 “自发而来的水军”，最早出现于 2015 年的电影 《西游记之大圣归来》。\n当初，影片上映时，有数万名网友自发形成了自来水，为这部国产电影摇旗呐喊，给影片带来了高口碑和高票房。该票最高单日票房为 4000 万，即打破了国产动画电影的单日票房记录，最终总票房也高达 9.56 亿元，是我国票房最高的动画电影（在当时是，《哪吒》改变了这个，是 50亿）。\n近年中国电影的放映情况来说，呈现出观看电影成为常态，电影放映高峰频繁出现的特点。\n一方面，看电影已经成为国人的一种日常行为与消费习惯。\n另一方面，目前中国电影放映的高峰期不仅有传统的 “贺岁档”，全绝大部分时间的放映都比较稳定，同时春节、国庆等假期在家庭观影的推动下，也已经成为电影消费的集中爆发期。\n暑假期间还由于大量学生的观影群体，使得每年七八月份亦成为电影放映的高峰。\n2018 年 “暑期档” 我国电影总票房就高达 173.8 亿元，超越 2017 年同期，票房超过了 10 亿。\n其中《一出好戏》《巨齿鲨》《侏罗纪世界2》等口碑较好的影片，票房都超过了 10 亿。\n而《我不是药神》和《西虹市首富》两部影片的票房，则分别高达 30.98 亿和 25.19 亿。\n总体来说，中国电影产业在近年的发展中，以 “武侠片” “喜剧片” “爱情片” 等传统优势类型片为主，同时兼顾更为多元的类型电影创作，旨在促进中国电影的全面健康发展。\n尤其是长期以来受编剧水平和技术能力限制，一直都是进口片的主场的魔幻、奇幻、科幻的 “三幻” 类型影片，从 2014 年开始整体爆发，其中以 “三体” 为代表的中国科幻电影的横空出世，标志着中国电影产业发展的新高度。\n最后我的补充 从这些课中，推荐值得看的电影 《红气球》 《我不是潘金莲》 《大话西游》 《布达佩斯大饭店》 《阿甘正传》 《亲爱的》 《罗生门》 《重庆森林》 《敦刻尔克》 《罗拉快跑》 《雨中曲》 《名扬四海》 《音乐之声》 《被解救的姜戈》 《天堂之门》 《盗马贼》 《可可西里》 《无人区》 《罗马假日》 《驴得水》 《甲方乙方》 《不见不散》 《没完没了》 《私人订制》 《发条橙》。。。。 《毕业生》 《寂静之声》 《醉拳》 《警察故事》 《蛇形刁手》 《喜剧之王》 《食神》 《少林足球》 《疯狂的石头》 《疯狂的赛车》 《唐人街探案1》 《杀死比尔》 《精武门》 《龙争虎斗》 《猛龙过江》 《十面埋伏》 《龙门客栈》 《这个杀手不太冷》 《公民凯恩》 《阿飞正传》 《东邪西毒》 《重庆森林》 《堕落天使》 《春光乍泄》 《花样年华》 《王牌特工·特工学院》 《持摄影机的人》 《辛德勒的名单》 《偷自行车的人》 《广岛之恋》 《默片解说员》 《你的名字》 《彼岸花》 《秋刀鱼之味》 《那年夏天，宁静的海》 《菊次郎的夏天》 《似水流年》 《恋恋风尘》 《拯救大兵瑞恩》 《慕尼黑惨案》 《E.T》 《泰坦尼克号》 《红番区》 《玩具总动员》系列 《非诚勿扰》 《人在囧途之泰囧》 《中国合伙人》 《阿凡达》 《我不是药神》 《西虹市首富》 当然，这些只是课程的一部分，更多的自己去搜，自己动手。\n电影批评入门资源 《电影艺术：形式与风格》——必看\n《认识电影》\n《电影批评》——戴锦华（北京大学教授，博士生导师，Bilibili 也有很多她的课，微信读书上也有她的书，我买的是纸质版的）\n《电影语言的语法》\n周传基讲电影6套视频合集视频\n《让子弹飞》拉片——拉片的是位导演，也可以看看他的其它作品\n会持续更新的\n总结 明确一个基本事实，电影≠故事片。进行电影批评，需要你大量的阅片，以及相应书籍的观看，以及导演的部分背景，才能更好的进行电影批评/鉴赏。\n例如《你好，李焕英》是贾玲自导自演的一部电影，其中冯巩是贾玲的师傅，客串了一下，活跃下气氛（我想死你们了）。其中 1980年的《庐山恋》是“文革”后中国首部爱情为主题的电影，并且出现了当时罕见的吻戏，符合当时的剧情设定。你现在去庐山，那里应该还有在放，我去过庐山两次了。该片其实很大程度上和《夏洛特烦恼》类似，整体采用的高调光（往上搜高调光），喜剧片常用，没有做大的改变，整体内容和这个电影差不太多。也是贾玲作为导演的第一部作品，沿用已有成熟的框架，是最好也是最稳妥的选择。影片事件其实可以再丰富些，让部分事件紧凑些。影片做得朴实无华，但真挚真诚。\n没看过这两部电影的，可以在不忙的时候偶尔看看。\n国内的一些资源足够了，Youtube 上也是有更多资源的，等你自己搜。\n","permalink":"http://localhost:1313/films/film-mooc/","summary":"\u003cp\u003e源自于\u003ca href=\"https://www.icourse163.org/learn/HENU-1003369001?tid=1461424469#/learn/content?type=detail\u0026amp;id=1237803381\u0026amp;sm=1\"\u003e电影概论\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"一电影总览\"\u003e一、电影总览\u003c/h1\u003e\n\u003ch2 id=\"八大艺术\"\u003e八大艺术\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/zh-cn/%E5%85%AB%E5%A4%A7%E8%97%9D%E8%A1%93\"\u003e来源于 Wikipedia\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"八大艺术来源\"\u003e八大艺术来源\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e八大艺术\u003c/strong\u003e的分类来源已不可考，但有两个明显的现象是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e人们提到八大艺术时，往往目的放在想要引介不在此艺术之中之物，例如新兴的\u003ca href=\"https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%81%8A%E6%88%B2\"\u003e游戏\u003c/a\u003e设计，有人指为第九艺术。\u003c/li\u003e\n\u003cli\u003e会提到八大艺术的理论，是因为摄影的发明对以后的各项科学、艺术、媒体及商业行为有巨大的贡献，也改变了人类以往的视觉经验，并进而衍生电影的发明，故变成第八艺术。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"八大艺术列表\"\u003e八大艺术列表\u003c/h3\u003e\n\u003cp\u003e八大艺术包含：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E7%B9%AA%E7%95%AB\"\u003e绘画\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E9%9B%95%E5%A1%91\"\u003e雕塑\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E5%BB%BA%E7%AF%89\"\u003e建筑\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E9%9F%B3%E6%A8%82\"\u003e音乐\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%B8\"\u003e文学\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E8%88%9E%E8%B9%88\"\u003e舞蹈\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E6%88%B2%E5%8A%87\"\u003e戏剧\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1\"\u003e电影\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"概览\"\u003e概览\u003c/h1\u003e\n\u003ch3 id=\"电影经历过程\"\u003e电影经历过程\u003c/h3\u003e\n\u003cp\u003e基本上，一部电影会经历三个阶段：制作(production)、发行(distribution)及放映(exhibition)。后面的数字化的售卖，是比较靠后的了，比如 DVD 版，放到各大视频平台售卖之类的。\u003c/p\u003e\n\u003ch2 id=\"电影元素\"\u003e电影元素\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e光\u003c/li\u003e\n\u003cli\u003e色彩\u003c/li\u003e\n\u003cli\u003e声音\u003c/li\u003e\n\u003cli\u003e画面构图\u003c/li\u003e\n\u003cli\u003e镜头构图\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"电影创作过程\"\u003e电影创作过程\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e剧作\u003c/li\u003e\n\u003cli\u003e导演\u003c/li\u003e\n\u003cli\u003e表演\u003c/li\u003e\n\u003cli\u003e拍摄\u003c/li\u003e\n\u003cli\u003e剪辑\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e大部分的电影生产过程会经过四个主要的阶段，和上面的 MOOC 的对应了起来。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e编剧与集资（scriptwriting and founding）：电影观念开发完成，完成剧本。电影工作者也需要为拍片计划获得财务援助。\u003c/li\u003e\n\u003cli\u003e拍片准备（preparation for filming）：一旦脚本大致完成，且至少有了某些资金，电影工作就可以开始计划实体的生产过程。\u003c/li\u003e\n\u003cli\u003e拍摄（shooting）：电影工作者创造出电影的影像和声音。\u003c/li\u003e\n\u003cli\u003e组合（assmebly）：这些影像与声音组合成最终的形态，其中牵涉到剪辑图片与声音、执行特效、加入音乐或额外对白，以及加上标题名称。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这些阶段可能会相互重叠。后面会介绍，好莱坞的 “制片人中心制” 来详细介绍制片人这一角色，这里只是做个大概的介绍。总的来说，这四个阶段会产生几十种专业的分工。\u003c/p\u003e\n\u003ch3 id=\"编剧与集资阶段-the-scripting-and-funding-phase\"\u003e编剧与集资阶段 （The Scripting and Funding Phase）\u003c/h3\u003e\n\u003cp\u003e核心人物\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e制片（producer）\n\u003col\u003e\n\u003cli\u003e执行制片（executive producer）：通常负责安排财务与洽谈版权。\u003c/li\u003e\n\u003cli\u003e在线制片（line producer）：监管导演、演员与剧组的日常工作。由助理制片所指派。\u003c/li\u003e\n\u003cli\u003e助理制片（associate producer）：负责协调冲印厂或技术人员。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e编剧（screenwriter）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e制片主要负责财务及组织上的工作。如果是独立制片，则要去发掘拍片计划，并说服制片公司或赞助者出资，也可能雇佣制片人去整合项目计划。在编剧的过程中，制片还要照顾整个拍片计划、筹募资金、安排人事等。在拍摄及剪辑期间，制片往往是编导和出资者之间的桥梁。在电影完成后，制片通常还要安排发行、宣传、营销、以及监督成本的回收。单一制片\u003cstrong\u003e或许可以\u003c/strong\u003e接管所有这些工作，但一般不会这么做。\u003c/p\u003e\n\u003cp\u003e剧本的完成会经历几个阶段。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e大致交代主要情节（action）的大纲（treatment）\u003c/li\u003e\n\u003cli\u003e一份货多份完整脚本\u003c/li\u003e\n\u003cli\u003e最后的拍摄脚本（shooting script）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e有的电影，可能会有好几个编剧一起编写，或者制片直接换编剧写剧本，例如《异形：普罗米修斯》，其实换了好几个编剧。如果直拍呢货导演不满意某一个作者的剧本，可以雇其他做和加以修改。\u003c/p\u003e","title":"电影概论-Mooc"},{"content":"前言 我玩了比较久的云顶之弈，也**“间接开发”过阵容**，就是 S3 最火热的 6 暗星羊刀水银泽拉斯。最快两天从水晶之痕没有段位到超凡大师（后面排到人比较慢，不愿玩，而且段位提升只是把数的堆积）。我也是美服以及艾欧尼亚两个赛季超凡大师，最高到一区前 200 名左右吧，3 月 26 日左右（具体几号真忘了）早上8 点斗鱼、卷子的第一把，和南波儿的两个小弟的7点多到8点那一把的录播视频为证。\n只要你时间够，上个王者不成问题。后面比较喜欢玩 PBE（测试服），提前感受版本，厄加特的大招开始是没有写明无视复活甲的，也是我向官方报告的 “bug”，后面官方改了技能说明，之前的英文介绍里面没有 GA（Guardian Angel）。其他的大家都知道的 bug，我也不愿向官方反馈。\n第三个，仅需两天（一天16个小时左右），50 多把即可从零上超凡大师，多的 8 把左右是打的维护赛。\n玩游戏也是要学习的，也是要动脑子的，只有不断进步，不断精进，才能更好去玩游戏。其他的下棋类的游戏，我也玩过，其实 TFT 大多都是抄 Dota 自走棋的，做得越来越像了，只不过简化了而已。\n{% tabs content-1 %}\n{% endtabs %}\n基础 这里主要讲些基础按键，以及鼠标操作“抢”英雄，抢装备。\n按键 D D 牌，换下一轮牌。D 一次需要 2 金币，具体几费英雄概率，看右下角\nF 升级，在左下角有对应的当前经验以及升级所需经验。一次升级需要 4 金币，一级对应着可以上一人口，8 级代表至少可以上 8 人口。3-2 和 4-1 是一些快节奏的上人口搜排阵容时间。例如法师，3-2 升 6，D 牌，4-1 升7 D牌，靠质量和血量赢，这就意味着 2 阶段不能乱升级，最大化保留经济。\nE 鼠标光标对准某个英雄后，再按 E 可以卖出该英雄。\nG 按住，可以选择秀表情。\n1、3 查看对手动态。1 表示前驱召唤师，即右下角小地图你的前驱召唤师，继续按，继续是前驱召唤师的前驱召唤师，以此类推，3 则相反。后面有高级教程展示如果使用按键，来达到逆转游戏战果的玩法。\n更多 可以打开 ESC 查看对应按键。\n鼠标 移动预测 对于老手，可以不开，没必要。在 Esc 按键【控制】那里，打开移动预测。配合按键移动，你可以设置 B 键来和鼠标右键配合一起使用，再加上移动预测，开局 1-1 没人抢得过你。\n点击头像 点击对应头像可以查看其他召唤师的具体阵容摆放。\n小技巧 左键点击场上英雄，按 3 或 1 切换视角，即可实时躲掉对方灵风、射线等功能装备影响。\n进阶 **不要给单件装备！！！**除非你全部都二星英雄了，并且有思路，替换阵容，在哪个阶段替换该英雄。\n装备（Items） 为了让游戏更加 “公平”。TFT 在每局 1阶段的三回合都会至少保证你有 3 件散件（当然也有可能爆钱 +2件），这 3 件包含了选秀的一件。\n公平，公平，还是他妈的公平。—— 《让子弹飞》\n核心装备 一个阵容的核心英雄（Champion） 往往有着一至多件核心装备，才能完美地发挥它的作用。根据核心装备，从 3 阶段确定大致阵容方向，临时变换阵容，往往会付出惨痛的代价。\n例如\n阿卡丽的蓝 BUFF + 火炮 + 无尽；\n卡特的科技枪；\n莫甘娜的鬼书；\n奥拉夫的火炮 +飓风；\n霞的巨人杀手 + 正义之手 + 饮血剑。\n次选装备 非核心装备，属于可替换的类型。\n例如\n卡特的泰坦可以换成反甲； 奥拉夫的杀人剑可以换成复活甲； 莫甘娜也可以用上巨人杀手。 通用装备 任何英雄都可以装备，并且前中期有着不错的表现。一般这种装备是用来过渡的，并且后期【能用】。\n例如\n日炎 离子火花 巨人杀手 冰心 狂徒 正义之手 荆刺背心 泰坦的坚决 窃贼手套🧤（又名偷偷） 圣杯 旗子 灵风 静止法衣（卑鄙射线）多为游戏后期出奇制胜使用 功能型装备 顾名思义，是为了实现一些功能的装备。例如将地方关键性英雄 “移出” 当前对局 5 秒。其实一句话可以概括，恶心对面的装备。\n灵风 静止法衣 伏击之爪 冰心 鸟盾 救赎 兹若特传送门 最后的轻语 离子火花 前期装备 这里说的是，纯前期装备。\n有些装备前期很强势，后期伤害不高。例如日炎、灵风（是的，前期合灵风也是可以的，摆得好，可以让地方关键性英雄无法输出，进而赢下当前回合），离子火花。\n装备如何给 不同赛季，有不同打法。云顶越来越偏快节奏，所以，如果你想在前期连胜，你必须从三个散件中合成一个成装，才有可能打出连胜（当然卡的质量也十分重要）。如果你不确定是玩什么阵容，2 阶段可以暂时不给装备，但是为了稳住血量，你必须在 3 阶段给出至少 1-2 件成装，来确定你的阵容。\n当然，前期的连胜不代表你能吃鸡，或者前四。这种前期合高质量怪，给成装的【保血量打法】，只有在打比赛和赛季初的时候适用。有些时候，经济和运气决定了你的排名。\n如果你想前期连胜，又不想太早确定阵容，那么【通用装备】的合成就是你的不二选择，例如【离子火花】、【日炎】等。3-3 必须确定几个大概的阵容方向，当然，如果你血量很高，经济很好，还可以再推迟几回合确定阵容。\n【云顶是以装备为核心的游戏】。质量固然重要，合适的装备，能让质量卡提升不止一倍的战力。当然，有一种情况例外，你的质量很高，运气很好，牌很糊，装备随便给都有分。\n英雄（Champion） 英雄分类 输出型 —— 例如神射手所有，大部分法师等。 坦克型 —— 斗士、重装类英雄，还有安妮等。 功能型 —— 例如风女、蛇女、盲僧、沙皇等。 一个良好的阵容，必定有这三种英雄，每种至少一个。这是必然的，取长补短，每个英雄擅长的位置不同。任何极化的阵容，都将被版本所制裁。并且一个良好的阵容，总是有人很有用，有些英雄表现很一般，这是无法避免的。\n上面的介绍，在这个赛季稍微改了点。\n下面是 4.0 版本推荐阵容，可以看看各自对应的。来自 https://lol.qq.com/tft/#/index\n核心英雄 每个阵容，都有一些核心英雄。\n例如 6 三国中的卡特，6 天神中的狼人，忍刺中的阿卡丽。他们基本都属于输出型英雄，很少有坦克/功能型英雄能够担任核心英雄。\n核心英雄的三大特征。\n贵（贵就意味着更好的的属性，以及更大范围/高伤害的技能） 星等高 输出型英雄 所有核心英雄，必须满足其中两个及以上条件。\n可替换（打工）英雄 在一个终极阵容成型之前，一定有装备需要别人去穿戴，不然血量会掉得非常快。每个版本会尽量控制不让出现特别突出的阵容，让每个阵容都有上场的可能。\n阵容（Comps） T0 阵容 每个版本都有些其特定的非常强势的阵容，这是必然的。不然也不会说更新版本了。T0 阵容，根据装备和来的英雄来尽量往着方面来靠。这是上分的一个小技巧。\n烂分阵容 故名思义，这种阵容比较难吃鸡，但是能靠着前期的质量和血量来🐶个烂分的阵容。例如一代版本一代神，代代版本玩法师，法师永远是你烂分的不二选择。前提是比较多的基础牌和合适的装备。\n利息 云顶之弈会每回合固定给你发 5 块\n连胜 or 连败？ 能连胜就连胜，连败也可以，不过 5 连败和 4 连败进野怪，前者是 6 块起步，后者是 4 块，还不 2 阶段理财的利息。合理的权衡血量和金币。\n存 50 再 D？ 看情况的，不一定这么绝对。\n每回合情况 扣血规则 轮次（即下一轮遇到谁） 在下面的对位中有介绍，根据不同的赛季，对位规则是会变换的。但总的规则是不会变的，还是为了公平，你不会想 2-1 碰弱的，3-1 碰非常强的，2 阶段和 3 阶段碰到人完全不一样吧？这样会导致一种情况，如果碰到的人全部不一样，眉笔会一直输，直到 3 阶段结束，只剩一丝血。\n还是为了公平，每个阶段碰到的人，位置变换不会太大。只会抽选其中两个回合换人。\n小知识 为什么相同血量，别人比我先出来？ 这是规则，看你上一回合扣血的多少，决定了你先出来，还是后出来。\n一个简单的判别，就是你的正对面是血量低还是高的，如果是低的，你就先出来。最新的版本已经改了这个 “Bug” 了，你可以直接看排名来判断自己什么时候 “出圈”。\n高阶 保持血量还是优先装备？ 对位（轮次） 云顶对位机制只有两套，从 S1 到现在。现在已经变了，需要你自己玩几把摸索，就那个排法。\n第一套\n2-1，2-3，2-6，和 3-1，3-3，3-6 对位是相同的，也就是遇到的玩家是一样的。那么 2-2，2-5 和 3-3，3-5 遇到的玩家是不同的。\n如下图所示。\nF 还是 D？ 视情况而定，之后详细介绍。\n卡牌 相同英雄，在卡池里的数量。\n英雄费用 数量 1 29 2 22 3 16 4 12 5 10 这里的数量是指本局游戏，所有玩家可见这个英雄的情况。\n也就是说场上“最多”\n只可能出现 3 家同样的三星一费英雄 只可能出现 2 家同样的三星二费英雄 只可能出现 1 家同样的三星三费英雄 只可能出现 1 家同样的三星四费英雄 只可能出现 1 家同样的三星五费英雄 当然，这有例外，如果你的妮蔻之助非常多，也是可以变出来的。以前是场上没有该英雄了，用了妮蔻也会弹出来，现在更人性化一点，防止“栽种” 卡别人牌，导致英雄一直三星不了。\n一般我是不推荐这种事情的，比较 “缺德”，但是高分局必须这样，尽可能让对手难受，让自己“舒服”。外服并不是和和气气的，也有 Fu@k 别人的，上来一顿问候的，高端局也有的。\n生活就是这样，这很正常。我们在成长的过程中习得的一个责任就是，在别人使我们的生活变得更艰难前，我们不得不使他们的生活更加艰难。\n—— 那不勒斯四部曲第一部《我的天才女友》p21\n实时换位、换装备 左键选中英雄，按 1，3 切换核心英雄站位，一般该技巧用于后期决战部分。\n论坛 国内官方网站 https://101.qq.com/?ADTAG=cooperation.glzx.web\n国外比较推荐的几个 最常用 https://tftactics.gg/tierlist/team-comps\n第二常用的 https://app.mobalytics.gg/tft/set5/team-comps\n这个也可以搜索自己的外服战绩 https://lolchess.gg/tft/5.0\n不常用 https://www.leagueofgraphs.com/tft/comps/master\n设计师 设计师推特—— Mortdog\n如果觉得版本变动很烂，你知道该怎么做。\n总结 说白了，上分就是根据版本变动，利用信息差，来实现轻松上分，到了版本更新后的中期，就靠运气+运营+掌握的阵容的数量。\n只有不停的练习，不停的重复这些阵容，你才能融会贯通，任何学习也是如此，重复才是真神，当然重复的过程中也需要思考，需要跳脱当前思维的局限性，从更宏大的视角审视自己走过的路/玩过的对局。一定要边玩，边校正自己。\n只有永远在路上的人，才不会迷茫，走得更远。引申至《拿破仑》\n一开始就知道自己要去往何方的人，往往走不远 ——《拿破仑》\n","permalink":"http://localhost:1313/posts/tft/","summary":"\u003ch1 id=\"前言\"\u003e前言\u003c/h1\u003e\n\u003cp\u003e我玩了比较久的云顶之弈，也**“间接开发”过阵容**，就是 S3 最火热的 6 暗星羊刀水银泽拉斯。最快两天从水晶之痕没有段位到超凡大师（后面排到人比较慢，不愿玩，而且段位提升只是把数的堆积）。我也是美服以及艾欧尼亚两个赛季超凡大师，最高到一区前 200 名左右吧，3 月 26 日左右（具体几号真忘了）早上8 点斗鱼、卷子的第一把，和南波儿的两个小弟的7点多到8点那一把的录播视频为证。\u003c/p\u003e\n\u003cp\u003e只要你时间够，上个王者不成问题。后面比较喜欢玩 PBE（测试服），提前感受版本，厄加特的大招开始是\u003cstrong\u003e没有写明\u003c/strong\u003e无视复活甲的，也是我向官方报告的 “bug”，后面官方改了技能说明，之前的英文介绍里面没有 GA（Guardian Angel）。其他的大家都知道的 bug，我也不愿向官方反馈。\u003c/p\u003e\n\u003cp\u003e第三个，仅需两天（一天16个小时左右），50 多把即可从零上超凡大师，多的 8 把左右是打的维护赛。\u003c/p\u003e\n\u003cp\u003e玩游戏也是要学习的，也是要动脑子的，只有不断进步，不断精进，才能更好去玩游戏。其他的下棋类的游戏，我也玩过，其实 TFT 大多都是抄 Dota 自走棋的，做得越来越像了，只不过简化了而已。\u003c/p\u003e\n\u003cp\u003e{% tabs content-1 %}\u003c/p\u003e\n\u003c!-- tab 美服 --\u003e\n\u003cp\u003e\u003cimg alt=\"s2 NorthAmerica.png\" loading=\"lazy\" src=\"https://i.loli.net/2021/01/03/YzTqi82tJWLOU6S.png\"\u003e\u003c/p\u003e\n\u003c!-- endtab --\u003e\n\u003c!-- tab 国服一区 --\u003e\n\u003cp\u003e\u003cimg alt=\"国服一区.png\" loading=\"lazy\" src=\"https://i.loli.net/2021/01/03/iH3DsZJdWEwvkNh.png\"\u003e\u003c/p\u003e\n\u003c!-- endtab --\u003e\n\u003c!-- tab 国服十四区 --\u003e\n\u003cp\u003e\u003cimg alt=\"国服14区.png\" loading=\"lazy\" src=\"https://i.loli.net/2021/01/03/kQhUvrixLZ3CjKe.png\"\u003e\u003c/p\u003e\n\u003c!-- endtab --\u003e\n\u003cp\u003e{% endtabs %}\u003c/p\u003e\n\u003ch1 id=\"基础\"\u003e基础\u003c/h1\u003e\n\u003cp\u003e这里主要讲些基础按键，以及鼠标操作“抢”英雄，抢装备。\u003c/p\u003e\n\u003ch2 id=\"按键\"\u003e按键\u003c/h2\u003e\n\u003ch3 id=\"d\"\u003eD\u003c/h3\u003e\n\u003cp\u003eD 牌，换下一轮牌。D 一次需要 2 金币，具体几费英雄概率，看右下角\u003c/p\u003e\n\u003ch3 id=\"f\"\u003eF\u003c/h3\u003e\n\u003cp\u003e升级，在左下角有对应的当前经验以及升级所需经验。一次升级需要 4 金币，一级对应着可以上一人口，8 级代表至少可以上 8 人口。3-2 和 4-1 是一些快节奏的上人口搜排阵容时间。例如法师，3-2 升 6，D 牌，4-1 升7 D牌，靠质量和血量赢，这就意味着 2 阶段不能乱升级，最大化保留经济。\u003c/p\u003e","title":"云顶之弈如何从零到最强王者"},{"content":"RowKey 尽量简短 Data Block 是 HBase 中文件读取的最小单元。Data Block中主要存储用户的KeyValue数据，而KeyValue结构是HBase存储的核心。HBase中所有数据都是以KeyValue结构存储在HBase中。\nKeyValue由4个部分构成，分别为Key Length、Value Length、Key和Value。其中，Key Length和Value Length是两个固定长度的数值，Value是用户写入的实际数据，Key是一个复合结构，由多个部分构成：Rowkey、Column Family、Column Qualif ier、TimeStamp以及KeyType。其中，KeyType有四种类型，分别是Put、Delete、DeleteColumn和DeleteFamily。\nHBase中数据在最底层是以KeyValue的形式存储的，其中Key是一个比较复杂的复合结构。\n这也是HBase系统在表结构设计时经常强调Rowkey、Column Family以及ColumnQualif ier尽可能设置短的根本原因。列族一般情况下设置为 1 个。\n——《HBase 原理与实战》\n等长 类似桶排序规则。\nID 在前 \u0026lt;user_id\u0026gt;\u0026lt;业务字段\u0026gt;\n优先级排序 高频查询的越靠前\n","permalink":"http://localhost:1313/posts/rowkey-design/","summary":"\u003ch1 id=\"rowkey-尽量简短\"\u003eRowKey 尽量简短\u003c/h1\u003e\n\u003cp\u003eData Block 是 HBase 中文件读取的最小单元。Data Block中主要存储用户的KeyValue数据，而KeyValue结构是HBase存储的核心。HBase中所有数据都是以KeyValue结构存储在HBase中。\u003c/p\u003e\n\u003cp\u003eKeyValue由4个部分构成，分别为Key Length、Value Length、Key和Value。其中，Key Length和Value Length是两个固定长度的数值，Value是用户写入的实际数据，Key是一个复合结构，由多个部分构成：Rowkey、Column Family、Column Qualif ier、TimeStamp以及KeyType。其中，KeyType有四种类型，分别是Put、Delete、DeleteColumn和DeleteFamily。\u003c/p\u003e\n\u003cp\u003eHBase中数据在最底层是以KeyValue的形式存储的，其中Key是一个比较复杂的复合结构。\u003c/p\u003e\n\u003cp\u003e这也是HBase系统在表结构设计时经常强调Rowkey、Column Family以及ColumnQualif ier尽可能设置短的根本原因。列族一般情况下设置为 1 个。\u003c/p\u003e\n\u003cp\u003e——《HBase 原理与实战》\u003c/p\u003e\n\u003ch1 id=\"等长\"\u003e等长\u003c/h1\u003e\n\u003cp\u003e类似桶排序规则。\u003c/p\u003e\n\u003ch1 id=\"id-在前\"\u003eID 在前\u003c/h1\u003e\n\u003cp\u003e\u0026lt;user_id\u0026gt;\u0026lt;业务字段\u0026gt;\u003c/p\u003e\n\u003ch1 id=\"优先级排序\"\u003e优先级排序\u003c/h1\u003e\n\u003cp\u003e高频查询的越靠前\u003c/p\u003e","title":"RowKey 设计规约"},{"content":"前言 仅供本人面试前准备，其他人还是别看了，没意义。有很多我缩写，省去了很多易理解的部分。\n我尽量找别人已经总结过的东西，而不是自己写，无意义，面试的八股文罢了。都是靠努力就能实现的东西。\n常见容器 ArrayList 详解 https://note.youdao.com/ynoteshare1/index.html?id=efd2a3a29d2626acea2b053e56bae5cc\u0026type=notebook#/04F1A0EFF8F241C2A89E2234AAF0A36A\n底层基于数组实现\n创建 ArrayList 如果不指定大小，会先创建一个大小为 0 的 Object[ ] 数组 ，\n第一次添加数据时，会扩容成 ArrayList 的 默认大小 default_capacity：10**；**\n创建时如果指定大小，直接创建指定大小的Object[ ]数组\nadd（）\n对 size+1，去判断数组是否满了，如果满了就调用 grow（）方法扩容，扩容大小为，原数组大小 + 原数组大小右移一位。也就是扩容到原来的1.5倍。JDK 1.6 是 1.5 倍 +1 ，JDK 1.7，1.8 是 1.5 倍。 然后把老数组拷贝到新数组里 elementData = Arrays.copyOf(elementData, newCapacity);\n最后 elementData[ size++ ] = e，对数组赋值，（并且size+1） add（index，e） 首先对index做数组越界检查rangeCheck(index); 如果越界了，抛数组越界异常 如果没越界，还是对 size + 1，判断是否需要扩容，如果需要扩容，调用grow方法 如果需要扩容，调用System.arraycopy（1,2,3,4,5）方法。参数解释1：原来的数组，2：从哪里开始复制。3：复制的目标数组。4：目标数组的第几位开始复制。5：一共复制几个数。 System.arraycopy(elementData, index, elementData, index + 1, size - index); 假设把数字6插入到第3位，复制过后的数组是，1 2 3 4 5 -\u0026gt; 1 2 3 3 4 5 然后再把目标的位置的值修改，变为 1 2 6 3 4 5 最后size++； set（index，e） 首先解释，set这个方法是替换该位置原来的元素，所以不会使数组变大，不会做扩容判断 然后对index做数组越界检查，如果越界了，抛数组越界异常 把e替换到数组的index位置 返回数组index位置的原始值 remove（index） 首先对index做数组越界检查rangeCheck(index);，如果越界了，抛数组越界异常 然后进行数组拷贝 System.arraycopy(elementData, index+1, elementData, index,size - index - 1); 假设把第三位数字删除，1 2 3 4 5 6 - \u0026gt; 1\t2 4 5 6 6 然后 element[size\u0026ndash;] = null; 最后返回被删除的值 get（index） 首先对index做数组越界检查rangeCheck(index);，如果越界了，抛数组越界异常 return elementData(index); 总结来说，AraayList的get方法效率非常高，直接返回对应下标值，add方法和remove方法，效率就有点低了，需要考虑数组扩容和数组拷贝的问题**。**\n所以ArrayList比较适用于插入操作较少，不是很频繁插入的场景。\nHashMap 详解 https://note.youdao.com/ynoteshare1/index.html?id=efd2a3a29d2626acea2b053e56bae5cc\u0026type=notebook#/79C59785226E4D679AF124256055760B\n数组加单链表，1.8 后是红黑树 初始容量 16 1 \u0026laquo; 4 加载因子 0.75 泊松分布 扩容临界值 = 容量 * 加载因子 容量必须是 2 的 n 次方，就是tableSizeFor方法 构造函数完成后也只是创建一个空数组，只有在第一次放数据时才会初始化容量，等到第一次放数据的时候用。threshold就是这个大小，构造函数阶段会算出这数的值。为什么用这个数保存数组大小，我觉得是作者觉得既然构造阶段数组没有初始化，那临界值也没什么意义，就临时当数组初始大小，等待put的时候给数组初始化，然后那时再回归他本身的意义，扩容临界值。 size是集合当前大小 构造函数三个，无参 16，一个参初始容量，两个参 初始容量和加载因子。 hash 算法：让高位和低位做异或运算，让高位也参与 hash 寻址运算，降低 hash 冲突。 hash 寻址：为什么是 hash 值和数组 length -1 进行与运算？取余效率低，做位运算效率高，所以容量必须是 2 的 n 次方，如果不是，就找最相近的，用 tableSizeFor 方法。 链表超过 8 个后，变红黑树（数组的容量大于等于 64）转成红黑树后，会变成 TreeNode 扩容机制：数组 2 倍扩容，rehash，hash \u0026amp; n-1，判断二进制结果中是否多出一个 bit 的1，如果没多，那么就是原来的index，如果多了出来那么就是 index+oldCap，通过这个方式，避免 rehash，用每个 hash 对新数组.length 取模，1.8 后优化了下，如果一个链表的长度超过了 8，会自动将链表转成红黑树，查找的性能是 O(logn)，比 O（n）高。 红黑树是二叉查找树，左小右大，普通的二叉查找树可能出现瘸子的情况，只有一条腿，不平衡，导致查询性能变成 O(n)，线性查询。红黑树有一大堆的限制条件。例如 根节点是黑色的；每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点； 如果破坏了红黑树的规则和平衡，会自动 rebalance，变色（红\u0026lt;\u0026ndash;\u0026gt;黑），左旋，右旋之类的。 ps:hashcode是int型，4个字节，一个字节8个bit，一共32位 先定义个变量： key的hashcode右移 16位，其实就是把原来的hashcode值的高16位放到低16位，高16位补0。然后画图讲解: 相当于拿hashcode的低16为和高16位做异或操作（不一样的为1，一样的为0)，让高16位也参与到运算中（正常来说集合的大小是不会特别大的，2的16次幂就6万多了，虽然hashmap允许的最大值是2的30次幂），所以，hash值的后16位90%的情况下都不会参与运算。但是现在高16位和低16位异或后，低16位就同时保留了高低两部分的特征，降低hash冲突。 为什么说可以降低hash冲突，因为如果两个key，解析的hashcode可能低16为一样的，但是如果这么异或一下，就不一样了 代码 JDK 1.7 的hashMap 在并发情况下导致死循环的问题，头插法，不同线程的 next 赋值导致链表成环。不同线程，如何计算 Hash 的时候，A 线程时间片用完了，挂起，B 线程看见 table[i] 是空的，直接插入，A 线程因为已经执行完了 Hash 计算，直接进行插入，就会覆盖 B 线程插入的值 JDK 8 用 head 和 tail 来保证链表的顺序和之前一样；JDK 7 rehash 会倒置链表元素） ConcurrentHashMap 1.7 Segment + 分段数组 + 链表 Segment 继承自 ReetrantLock 弱一致性。当创建迭代器后，其他线程删除了该元素时候并不会抛出java.util.ConcurrentModificationException异常，能够保持创建迭代器后的元素被正确的Iterator.next()出来。例如ConcurrentHashMap就是弱一致性迭代器，HashMap就是强一致性迭代器。 get 无锁，volatile 加在了 Node 上 sizeCtl -1代表有线程完成了初始化；别的负数代表有线程在扩容；初始化完成后，sizeCtl就持有下一次扩容的size，作用即threshOld LinkedList 详解 自行查看\nLinkedList 底层是基双向链表实现的\nLinkedList的每条数据都会被封装成 Node\nprivate static class Node\u0026lt;E\u0026gt; { E item; Node\u0026lt;E\u0026gt; next; Node\u0026lt;E\u0026gt; prev; //构造方法 Node(Node\u0026lt;E\u0026gt; prev, E element, Node\u0026lt;E\u0026gt; next) { this.item = element; this.next = next; this.prev = prev; } } ArrayBlockingQueue 详解 用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下 不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当 队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入 元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐 量。我们可以使用以下代码创建一个公平的阻塞队列：\nArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true); LinkedBlockingQueue 详解 基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对 元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者 端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费 者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。\nLinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。\nConcurrentHashMap详解 1.7分段数组+单向链表\n1.8其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。\nhttps://www.jianshu.com/p/aa017a3ddc40\n枚举 从字节码层面上看，枚举仅仅是一个继承于 java.lang.Enum 的类、自动生成了 values 和 valueOf 方法的普通 Java 类而已。\nCopyOnWriteArrayList IO NIO Reflect Class Method Constructor ClassLoader JVM 运行时数据区 // 不想自己画，原图片在 https://www.cnblogs.com/wuzhenzhao/p/12346515.html\n程序计数器 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里面（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释工作时就是通过改变这个计数器的值来选去下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程回复等基础功能都需要以来这个计数器来完成。\nJava 虚拟机栈 与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\nJava虚拟机栈中还有着局部变量表部分，局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、doublle）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。\n其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需要的内存空间是完全确定的，在方法运行期间不会改变局部变量表的大小。\n在 Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈）如果扩展是无法申请到足够的内存，就会抛出OOME异常。OutOfMemoryError 后文就简称为 OOME 了。\n本地方法栈 本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由的实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OOME 异常。\n堆 Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点Java虚拟机规范的描述是：所有的对象实例以及数组都要在堆上分配，JIT，逃逸分析，栈上创建对象。\n分代回收，新生代（from+to+Eden，1:1:8）+老年代。从内存分配的角度来看，线程共享Java堆中可能划分出多个线程私有的分配缓冲区。\n逻辑上连续内存空间。\n方法区（Meta Space） 方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器后的代码等数据。又名非堆（Non-Heap），1.7 用永久代（Permanent Generation）实现方法区，1.8 更名为 Meta Space。1.7 及以前的版本的项目容易报 Permanent Generation OOM，1.6 默认 82M，1.7 默认 128M，当类和静态变量一多就容易报错，解决办法是加大这块内存地址。\n运行时常量池 运行时常量池（Runtime Pool）是方法区的一部分。Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。\n运行时常量是相对于常量来说的，它具备一个重要特征是：动态性。当然，值相同的动态常量与我们通常说的常量只是来源不同，但是都是储存在池内同一块内存区域。Java语言并不要求常量一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中。这里所说的常量包括：基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）和String（也可以通过String.intern()方法可以强制将String放入常量池）。\n直接内存 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义中的内存区域。但那是这部分内存也被频繁地使用，而且也可能异常能导致OOME异常出现，\n对象创建 指针碰撞：假设 Java 堆中内存是绝对规整的，所有内存都放在一遍，空闲的内存放在另一边，中间放一个指针作为分解点的指示器，那所分配内存仅仅是把那个指针向空闲空间那边挪一段与对象大小相等的距离。 空闲列表：因为堆内存在物理上是不连续的，而在逻辑上是连续的。当虚拟机在给对象在堆中分配内存时，会出现不是在连续内存空间上分配的情况。为了让对象能够在堆中能分到内存，虚拟机必须维护一个列表，记录上哪些内存块是可以用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。 什么情况会发生 OOM 堆溢出 虚拟机栈和本地方法栈溢出—— 1.请求的栈深度大于虚拟机允许的最大深度，抛出 StackOverflowError。2. 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OOM。 方法区和运行时常量池溢出——常量池属于方法区的一部分，类太多（包括本身就有的，还有动态生成的类太多）。 本机直接内存溢出—— -XX：MaxDirectMemorySize 指定，不指定，默认和 Java 堆最大值（ -Xmx 指定） 一样。 什么时候回收对象 引用计数 你引用我，我引用你，你我都是空对象。就会导致这个引用计数回收不了， Python 就是用的引用计数。\n可达性分析算法 GC Roots 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中 JNI 应用的对象。 什么时候对象不可达？ 第一次标记 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记。\n第二次标记 经过第一次标记后的对象，根据 此对象是否有必要执行finalize()方法 进行筛选，随后会由收集器对F-Queue中的对象进行第二次小规模的标记。具体如下：\n经过第一次标记后的对象，根据 此对象是否有必要执行finalize()方法 进行筛选。被判定为确实有必要执行finalize()方法的对象将会被放置在一个名为F-Queue的队列之中。 假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。 稍后会由一条由虚拟机自动建立的、低调度优先级的 Finalizer线程 去执行F-Queue中对象的finalize()方法。 finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行 第二次小规模的标记。如果对象在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，那在第二次标记时它将被移出 “即将回收” 的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。 这种自救的机会只有一次，因为对象的finalize()方法最多只会被系统调用一次。\nGC 算法 标记清除（Mark-Sweep） 分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清 除阶段回收被标记的对象所占用的空间，容易产生内存碎片。\n复制（copying） 按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。消耗内存多，但是没有内存碎片产生，用于新生代对象创建。\n标记整理(Mark-Compact) 标记后不是清理对象，而是将存活对象移向内存的一端，然后清除端边界外的对象。\n和指针碰撞不同\n分代收集算法 根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃 圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。\n新生代与复制算法 目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要 回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代 划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另 一块 Survivor 空间中。\n老年代与标记复制算法 而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。\nJAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储 class 类， 常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目 前存放对象的那一块)，少数情况会直接分配到老生代。 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。 当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被 移到老生代中。 Java 四中引用类型 强引用 把一个对象赋给一个引用变量，这个引用变量就是一个强引 用。当一个对象被强引用变量引用时\n软引用 软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它 不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。\n弱引用 弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。\n虚引用 虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚 引用的主要作用是跟踪对象被垃圾回收的状态。\n什么是 Safepoint Safepoint 可以用在不同地方，比如GC、Deoptimization，在Hotspot VM中，GC safepoint比较常见，需要一个数据结构记录每个线程的调用栈、寄存器等一些重要的数据区域里什么地方包含了GC管理的指针。\n从线程角度看，safepoint可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这个位置暂停，比如发生GC时，需要暂停暂停所以活动线程，但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待GC结束。\nhttps://www.jianshu.com/p/c79c5e02ebe6\nMinor GC 和 Full GC 的触发机制 新生代 GC（Minor GC） 指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。\n老年代 GC（Major GC/Full GC） 指发生在老年代的 GC，出现了 Major GC，经常会伴随着至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。\nJVM 系列文章之 Full GC 和 Minor GC from区 to区，反复横跳，进入老年代\nyoung区 Eden 80% from 10% to 10% old区 设置参数，可让创建对象时，直接进入old区。\n如果对象在 Eden 区出生并经过第一次 Minor GC 后仍然存活，并且能够被 Surviror 容纳的话，将被一定到 Survivor 空间中，并且对象年龄设为 1。对象在 Survivor 中每“熬”过一次 Minor GC，年龄+1，默认到 15 就晋升到老年代。但并不是永远要求对象年龄必须达到那个参数，如果在 Survivor 空间中相同年龄所有对象的大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。\n-XX:MaxTenuringThreshold=15 CMS里面默认是6。\n内存分配以及回收 对象优先在 Eden 区分配 大多数情况下，对象优先在 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。\n大对象为什么直接进入老年代 虚拟机提供了一个-XX:PretenureSizeThreshold参数，不同垃圾收集器默认值不同，直接在 Eden 区。大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区（from区to区）之间发生大量的内存复制。不同分代，采用不同垃圾回收算法，young 区采用的是复制清除算法，如果是大对象，就得不偿失了。\n注意:PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。\n一个简单的方法，在 Spring Boot项目中写个 循环依赖类（需要特殊处理，在我的 github 上的一个项目中有），然后用 类层次 类去引用，再Debug，就能看见 栈溢出信息，和 from to区的信息。 反复横跳，大于 15 次，晋升为老年代对象。\n空间分配担保 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果是，Minor GC 确保安全。看 HandlePromotionFailure 是否允许担保失败。如果允许，会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 有风险，如果小于或者配置的不允许，那么就改成一次 Full GC。\nJVM 调优 -Xms -Xmx 设置成一样 。例如 -Xms2048M -Xmx2048M\n-XX:USEBAISEDLOCKED=FALSE 关闭偏向锁。JDK 1.6引入新概念，在线程竞争不激烈时引入，偏向锁，轻量级锁。支持锁的升级和降级，但并发比较大的环境下，关掉这个是好的选择。在对象头中标出，00，01，10，11，两位标出是什么状态。\n年轻代：-XX:+UseParNewGC。\n老年代：-XX:+UseConcMarkSweepGC。\n-XX:-DoEscapeAnalysis ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis。逃逸分析是让某些朝生夕死的对象，在栈上创建对象，随着栈的消亡而消亡。\nhttps://www.hollischuang.com/archives/2583\n频繁触发 Full GC ，如果使用的是 G1，可以加上 -XX:+PrintAdaptiveSizePolicy 参数，查看到底是谁引发的\n更多见 https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html。比如你用的是 Azkaban，这种朝生夕死的任务执行的项目，它默认的配置是很简单的，也是很坑的。我的建议是把下面的调整到 5、5。当然，这个我也只是简单测了，改成这样后，就没有之前的 OOM 问题了。更好的比例，需要你一遍遍调。\n-XX:NewRatio=n Ratio of new/old generation sizes. The default value is 2. -XX:SurvivorRatio=n Ratio of eden/survivor space size. The default value is 8. 类加载 加载过程 编译 加载 验证 准备 解析 初始化 使用 卸载 https://www.cnblogs.com/straybirds/p/8513870.html\n什么时候加载，虚拟机规范没强制要求，这点虚拟机自己发挥，但是初始化阶段，虚拟机规范严格规定了有且仅有 5 种情况必须立即对类进行初始化。\n遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时。new 对象，读取或者设置一个类的静态字段（非 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候，调用静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候。没有初始化，则要。 当初始化一个类的时候，如果其父类未被初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个需要执行的主类。（main 方法） 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法的句柄所对应的类没有进行过初始化，则需要先出发其初始化。 双亲委派模型 Bootstrap ClassLoader（C++ 实现，负责将存放在 \u0026lt;JAVA_HOME\u0026gt;\\lib目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的仅按照文件名识别，例如 rt.jar 名字不符合也不会加载。加载到虚拟机的内存中。返回 null 就能用这个加载器加载）\nExtension ClassLoader（Java 实现负责加载 \u0026lt;JAVA_HOME\u0026gt;\\lib\\ext目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接用）\nApplication ClassLoader（Java 实现 一般情况下，这个就是默认的类加载器）\n自定义 ClassLoader\n破坏双委派模型 自己覆盖 loadClass 。OSGi 给“高速奔跑的汽车换轮胎”。还有公司要求会这个。。。。\n虚拟机字节码执行引擎 局部变量表\n动态连接\n方法返回地址\n操作数栈\n方法调用\n解析\n分派\n动态类型语言支持\n这个就是方法调用就是压栈，舍弃当前栈帧就是返回上一个方法。Debug 的 drop frame。\n程序源码 -\u0026gt; 语法解析 -\u0026gt; 单词流 -\u0026gt; 语法解析 -\u0026gt; 抽象语法树\n二选一\n-\u0026gt; 指令流 -\u0026gt; 解释器 -\u0026gt; 解释执行\n-\u0026gt; 优化器 -\u0026gt; 中间代码 -\u0026gt; 生成器 -\u0026gt; 目标代码\nJVM 各种优化 编译优化 例如\nString a = \u0026#34;Foo\u0026#34; + \u0026#34;Bar\u0026#34;; String b = \u0026#34;FooBar\u0026#34;; System.out.println(a == b); // 输出为 true，这属于编译时优化。 注解处理\n自动拆装箱\n锁消除（编译时就把“傻瓜式加锁“代码给去掉，没必要加锁的，就不加）\n运行优化 JIT —— Just In Time，当调用频率到一定值时，开启即时编译，跳过 class，直接生成对应汇编，运行汇编文件。很多其他语言也有这个高级 feature。\n方法内联 —— 我感觉是借鉴 cpp，直接把两段方法合并成一个方法。\n逃逸分析 —— 栈上创建对象\nJMM https://zhuanlan.zhihu.com/p/29881777\n无非就是搞了个抽象，具体实现，不同虚拟机不同的来。\n多线程 volatile 如何保证内存可见性 volatile 是 Java 提供的轻量级同步机制\n保证可见性 不保证原子性 禁止指令重排 MESI 协议 MESI 协议是一个基于失效的缓存一致性协议，是支持回写（write-back）缓存的最常用协议。也称作伊利诺伊协议 (Illinois protocol，因为是在伊利诺伊大学厄巴纳-香槟分校被发明的[1])。与写通过（write through）缓存相比，回写缓冲能节约大量带宽。总是有“脏”（dirty）状态表示缓存中的数据与主存中不同。MESI协议要求在缓存不命中（miss）且数据块在另一个缓存时，允许缓存到缓存的数据复制。与MSI协议相比，MESI协议减少了主存的事务数量。这极大改善了性能。[2]\nJMM（Java Memory Model）本身是一种抽象的概念，并不真实存在，它描述的一组规则或规范，通过这组规范定义了程序中各个变量（含实例字段，静态字段和构成数组对象的元素）的访问方式。\nJMM关于同步的规定：\n线程解锁前必须把共享变量的值刷新回主存 线程加锁前，必须读取主存的最新值到自己的工作内存 加锁解锁是同一把锁 更多https://blog.csdn.net/t894690230/article/details/50588129\nhappens-before 程序次序法则：如果在程序中，所有动作 A 出现在动作 B 之前，则线程中的每动作 A 都 happens-before 于该线程中的每一个动作 B。 监视器锁法则：对一个监视器的解锁 happens-before 于每个后续对同一监视器的加锁。 volatile 变量法则：对 volatile 域的写入操作 happens-before 于每个后续对同一 volatile 的读操作。 传递性：如果 A happens-before 于 B，且 B happens-before C，则 A happens-before C。 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作 volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始 https://juejin.im/post/5ae6d309518825673123fd0e\nhttps://en.wikipedia.org/wiki/Happened-before\nSynchronized C++ 实现源码解析 自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -\u0026gt; 等待的机制被称为自旋锁(spinlock)。 自旋锁的原理比较简单，如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。\n因为自旋锁避免了操作系统进程调度和线程切换，所以自旋锁通常适用在时间比较短的情况下。由于这个原因，操作系统的内核经常使用自旋锁。但是，如果长时间上锁的话，自旋锁会非常耗费性能，它阻止了其他线程的运行和调度。线程持有锁的时间越长，则持有该锁的线程将被 OS(Operating System) 调度程序中断的风险越大。如果发生中断情况，那么其他线程将保持旋转状态(反复尝试获取锁)，而持有该锁的线程并不打算释放锁，这样导致的是结果是无限期推迟，直到持有锁的线程可以完成并释放它为止。\n解决上面这种情况一个很好的方式是给自旋锁设定一个自旋时间，等时间一到立即释放自旋锁。自旋锁的目的是占着CPU资源不进行释放，等到获取锁立即进行处理。但是如何去选择自旋时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！JDK在1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋时间不是固定的了，而是由前一次在同一个锁上的自旋时间以及锁拥有的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。\nsynchronized.cpp解析\nJdk1.6 锁的升级与降级，自旋锁-\u0026gt;偏向锁-\u0026gt;轻量级锁-\u0026gt;重量级锁（操作系统内核的 mutex lock）\nReentrantLock 和 synchronized 之间 在加锁和内存上提供的语义与内置锁相同，此外它还提供了可定时、可中断、可轮询、公平性，以及实现非块结构的加锁。只要在需要这些高级的功能时，用 ReentrantLock，否则还是应该优先使用 synchronized。 synchronized 比 ReetrantLock 还有个优点：在线程转储中能给出在哪些调用帧获得了哪些锁，并能够检测和识别发生死锁的线程。JVM 并不知道哪些线程持有 ReetrantLock，因此在调试使用 ReetrantLock 的线程的问题时，将起不到帮助作用。\nThreadLocal https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/ThreadLocal.md\nSpring MVC 中，RequestHolder 使用 ThreadLocal 进行 HttpServletRequest 进行缓存。还有事务，AopProxyHolder、MyBatis 的 PageHelper 这种，都是根据当前线程的变量来确定的。\nAQS https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md\nDoug Lea 设计的，CountDownLatch、ReentrantLock 都继承这个类，是 Java 最低层级的同步机制。\nAQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器。\nAQS 原理概览 AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。\nvolatile 变量 + 双向队列。\nAQS 对资源的共享方式 Exclusive（独占） 只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍：\n公平锁：按照线程在队列中的排队顺序，先到者先拿到锁 非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。 Share（共享） 多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。\nReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。\n不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。\nFork/Join https://time.geekbang.org/column/article/92524\nFork/Join 是一个并行计算的框架，主要就是用来支持分治任务模型的，这个计算框架里的 Fork 对应的是分治任务模型里的任务分解，Join 对应的是结果合并。Fork/Join 计算框架主要包含两部分，一部分是分治任务的线程池 ForkJoinPool，另一部分是分治任务 ForkJoinTask。这两部分的关系类似于 ThreadPoolExecutor 和 Runnable 的关系，都可以理解为提交任务到线程池，只不过分治任务有自己独特类型 ForkJoinTask。\nForkJoinTask 是一个抽象类，它的方法有很多，最核心的是 fork() 方法和 join() 方法，其中 fork() 方法会异步地执行一个子任务，而 join() 方法则会阻塞当前线程来等待子任务的执行结果。ForkJoinTask 有两个子类——RecursiveAction 和 RecursiveTask，通过名字你就应该能知道，它们都是用递归的方式来处理分治任务的。这两个子类都定义了抽象方法 compute()，不过区别是 RecursiveAction 定义的 compute() 没有返回值，而 RecursiveTask 定义的 compute() 方法是有返回值的。这两个子类也是抽象类，在使用的时候，需要你定义子类去扩展。\nFork/Join 并行计算的核心组件是 ForkJoinPool。ForkJoinPool 本质上也是一个生产者 - 消费者的实现，但是更加智。ThreadPoolExecutor 内部只有一个任务队列，而 ForkJoinPool 内部有多个任务队列，当我们通过 ForkJoinPool 的 invoke() 或者 submit() 方法提交任务时，ForkJoinPool 根据一定的路由规则把任务提交到一个任务队列中，如果任务在执行过程中会创建出子任务，那么子任务会提交到工作线程对应的任务队列中。\n如果工作线程对应的任务队列空了，是不是就没活儿干了呢？不是的，ForkJoinPool 支持一种叫做“任务窃取”的机制，如果工作线程空闲了，那它可以“窃取”其他工作任务队列里的任务，例如下图中，线程 T2 对应的任务队列已经空了，它可以“窃取”线程 T1 对应的任务队列的任务。如此一来，所有的工作线程都不会闲下来了。ForkJoinPool 中的任务队列采用的是双端队列，工作线程正常获取任务和“窃取任务”分别是从任务队列不同的端消费，这样能避免很多不必要的数据竞争。我们这里介绍的仅仅是简化后的原理，ForkJoinPool 的实现远比我们这里介绍的复杂\nFork/Join 并行计算框架主要解决的是分治任务。分治的核心思想是“分而治之”：将一个大的任务拆分成小的子任务去解决，然后再把子任务的结果聚合起来从而得到最终结果。这个过程非常类似于大数据处理中的 MapReduce，所以你可以把 Fork/Join 看作单机版的 MapReduce。\nFork/Join 并行计算框架的核心组件是 ForkJoinPool。ForkJoinPool 支持任务窃取机制，能够让所有线程的工作量基本均衡，不会出现有的线程很忙，而有的线程很闲的状况，所以性能很好。Java 1.8 提供的 Stream API 里面并行流也是以 ForkJoinPool 为基础的。不过需要你注意的是，默认情况下所有的并行流计算都共享一个 ForkJoinPool，这个共享的 ForkJoinPool 默认的线程数是 CPU 的核数；如果所有的并行流计算都是 CPU 密集型计算的话，完全没有问题，但是如果存在 I/O 密集型的并行流计算，那么很可能会因为一个很慢的 I/O 计算而拖慢整个系统的性能。所以建议用不同的 ForkJoinPool 执行不同类型的计算任务。\n死锁 一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。线程 A 有🔒 1，我还想获取🔒 2，但是另一个线程 B 持有🔒 2，两个线程都不释放锁，等着对方释放锁，就会导致死锁。一般死锁了，只能重启。\n死锁发生的条件 互斥，共享资源 X 和 Y 只能被一个线程占用；\n占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；\n不可抢占，其他线程不能强行抢占线程 T1 占有的资源；\n循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。\n破坏其中一个，就可以成功避免死锁的发生。\nCAS 全称是 Compare And Swap，即“比较并交换。\nCAS 指令包含 3 个参数：共享变量的内存地址 A、用于比较的值 B 和共享变量的新值 C；并且只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条 CPU 指令，CAS 指令本身是能够保证原子性的。\nABA 问题，加版本号。\nAtomicInteger 调用 Unsafe 的 compareAndSwap native 方法 public final boolean compareAndSet(int expect, int update) { return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } native 方法 compareAndSwapInt 在 Linux 下的 JDK 实现如下。 UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) UnsafeWrapper(\u0026#34;Unsafe_CompareAndSwapInt\u0026#34;); oop p = JNIHandles::resolve(obj); jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); return (jint)(Atomic::cmpxchg(x, addr, e)) == e; UNSAFE_END Atocmic::cmpxchg 在 x86 处理器架构下（Linux 下）的 JDK 实现 \u0026gt; What I\u0026#39;m a bit uncertain about here is which barriers we need and which are optimal as it seems to be a bit different for different ARM versions, maybe somebody can enlighten me? Also I\u0026#39;m not sure how hotspot checks ARM version to make the appropriate decision. \u0026gt; \u0026gt; The proposed x86 implementation is much more straight forward (bsd, linux): \u0026gt; \u0026gt; inline jbyte Atomic::cmpxchg(jbyte exchange_value, volatile jbyte* dest, jbyte compare_value) { \u0026gt; int mp = os::is_MP(); \u0026gt; jbyte result; \u0026gt; __asm__ volatile (LOCK_IF_MP(%4) \u0026#34;cmpxchgb %1,(%3)\u0026#34; \u0026gt; : \u0026#34;=a\u0026#34; (result) \u0026gt; : \u0026#34;q\u0026#34; (exchange_value), \u0026#34;a\u0026#34; (compare_value), \u0026#34;r\u0026#34; (dest), \u0026#34;r\u0026#34; (mp) \u0026gt; : \u0026#34;cc\u0026#34;, \u0026#34;memory\u0026#34;); \u0026gt; return result; \u0026gt; } \u0026gt; \u0026gt;\u0026gt;\u0026gt; The implementation of single byte Atomic::cmpxchg on x86 (and all other \u0026gt;\u0026gt;\u0026gt; platforms) emulates the single byte cmpxchgb instruction using a loop of \u0026gt;\u0026gt;\u0026gt; jint-sized load and cmpxchgl and code to dynamically align the destination \u0026gt;\u0026gt;\u0026gt; address. \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; This code is used for GC-code related to remembered sets currently. \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; I have the changes on my platform (amd64, bsd) to simply use the native \u0026gt;\u0026gt;\u0026gt; cmpxchgb instead but could provide a patch fixing this unnecessary \u0026gt;\u0026gt;\u0026gt; performance glitch for all supported x86 if anybody wants this? \u0026gt;\u0026gt; \u0026gt;\u0026gt; I think that sounds good. \u0026gt;\u0026gt; Would you mind looking at other cpu arches to see if they provide something \u0026gt;\u0026gt; similar? It\u0026#39;s ok if you can\u0026#39;t build the code for the other arches, I can help \u0026gt;\u0026gt; you with that. \u0026gt;\u0026gt; \u0026gt;\u0026gt; /Mikael ThreadPoolExecutor 配置 ThreadPoolExecutor /** * Creates a new {@code ThreadPoolExecutor} with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless {@code allowCoreThreadTimeOut} is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the {@code keepAliveTime} argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the {@code Runnable} * tasks submitted by the {@code execute} method. * @param threadFactory the factory to use when the executor * creates a new thread * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:\u0026lt;br\u0026gt; * {@code corePoolSize \u0026lt; 0}\u0026lt;br\u0026gt; * {@code keepAliveTime \u0026lt; 0}\u0026lt;br\u0026gt; * {@code maximumPoolSize \u0026lt;= 0}\u0026lt;br\u0026gt; * {@code maximumPoolSize \u0026lt; corePoolSize} * @throws NullPointerException if {@code workQueue} * or {@code threadFactory} or {@code handler} is null */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize \u0026lt; 0 || maximumPoolSize \u0026lt;= 0 || maximumPoolSize \u0026lt; corePoolSize || keepAliveTime \u0026lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } corePoolSize —— 线程池的目标大小，即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超过这个数量的线程。在 ThreadPoolExecutor 初期，线程并不会立即启动，而是等到有任务提交时才会启动，除非调用 prestartAllThreads。\nmaximumPoolSize —— 线程池最大值。 the maximum number of threads to allow in the pool。\nkeepAliveTime —— 当线程数超过核心线程数时，这是多余的空闲线程将在终止之前等待新任务的最长时间。 when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.\nunit —— 上面的时间单位the time unit for the {@code keepAliveTime} argument\nworkQueue —— 任务队列，这个是提交的任务队列，如果提交的任务大于最大线程数了，会优先放到这个任务队列中。 the queue to use for holding tasks before they are executed. This queue will hold only the {@code Runnable} tasks submitted by the {@code execute} method.\nthreadFactory —— 利用 ThreadFactory#newThread 来创建 Thread，这里可以对 Thread 进行命名。the factory to use when the executor creates a new thread.\nhandler —— 执行不了了，wokerqueue 都塞不下了，就执行拒绝策略。可以自定义，用来重试任务，默认是直接丢掉。JDK 提供了 4 种。the handler to use when execution is blocked because the thread bounds and queue capacities are reached\nThreadPoolExecutor 允许提供一个 Blocking Queue 来保存等待执行的任务。\n无界队列。LinkedBlockingQueue 默认的构造器就是无界的。public LinkedBlockingQueue() { this(Integer.MAX_VALUE);} 2. 有界队列。ArrayBlockingQueue、有界的 LinkedBlockingQueue、PriorityBlockingQueue。 同步移交。Synchronous Handoff。 无界队列将不会执行拒绝策略，当然如果你的线程数大于了 Integer.MAX_VALUE 还是会执行的，前提是你到达这么多。一般情况就 OOM 了。所以《阿里巴巴 Java 开发规范》中不使用 Executors 创建线城池。\n饱和策略 AbortPolicy：中止策略是默认的饱和策略，该策略将抛出未检查的 RejectedExecutionException 调用者可以捕获这个异常，然后根据需求编写自己的处理代码。\nDiscardPolicy：当新提交的任务无法保存到队列中等待执行时，抛弃策略会悄悄抛弃该任务。\nCallerRunsPolicy：调用者运行（Caller-Runs）策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛弃异常，而是将某些任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了 execute 的线程中执行该任务。\nDiscardOldestPolicy：抛弃最旧的（Discard-Oldest）策略则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。如果工作队列是一个优先队列，那么”抛弃最旧的“策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用。\nSynchronousQueue 对于非常大的或者无界的线程池，可以通过使用 SynchronousQueue 来避免任务排队，以及直接将任务从生产者移交给工作者线程。SynchronousQueque 不是一个真正的队列，而是一种在线程之间进行移交的机制。要将一个元素放入 SynchronousQueue 中，必须有另一个线程正在等待接受这个元素。如果没有线程正在等待，并且线程池的当前大小小于最大值，那么 ThreadPoolExecutor 将创建一个新的线程，否则根据饱和策略，这个任务将被拒绝。\nThreadFactory 许多情况下都需要使用定制的线程工厂方法。\n例如，为线程池中的线程制定一个 UncaughtExceptionHandler，或者实例化一个定制的 Thread 类用于执行调试信息的记录。线程优先级（其实执行的时候优先级只是个参考），或者守护状态（也不建议），最常用的其实就是取个名字。\nPivatol 团队就封装了个 NamedThreadFactory，简单的封装，简单的应用。\npackage io.micrometer.core.instrument.util; public class NamedThreadFactory implements ThreadFactory { private final AtomicInteger sequence = new AtomicInteger(1); private final String prefix; public NamedThreadFactory(String prefix) { this.prefix = prefix; } public Thread newThread(Runnable r) { Thread thread = new Thread(r); int seq = this.sequence.getAndIncrement(); thread.setName(this.prefix + (seq \u0026gt; 1 ? \u0026#34;-\u0026#34; + seq : \u0026#34;\u0026#34;)); if (!thread.isDaemon()) { thread.setDaemon(true); } return thread; } } SpringBoot 相关的监控解决方案从 SpringBoot 2.0开始全面更改为Micrometer，不过要知道 Micrometer 与 Spring 属于同门，都是Pivotal旗下的产品。\n扩展 ThreadPoolexecutor beforeExecute\nafterExecutor\nterminated\n添加日志、计时、监视或统计信息收集的功能。无论任务是从 run 中正常返回，还是抛出一个异常而返回，afterExecute 都会被调用。如果是一个 Error 就不会。如果 beforeExecute 抛出一个 RuntimeException，那么任务将不被执行，并且 afterExecute 也不会被调用。\n在线程池完成关闭操作时调用 terminated，也就是在所有任务都已经完成并且所有工作者线程也已经关闭后。terminated 可以用来释放Executor 在其生命周期里分配的各种资源，此外还可以执行发送通知、记录日志或者收集 finalize 统计信息等操作。\nServlet 容器 Tomcat Jetty Websphere Application Server IBM\nNginx Nginx 服务器 Nginx 集群搭建 引入虚拟 IP，keepalived\nMySQL MySQL 执行过程 那些索引 Spring Spring Bean 的加载过程 Spring Bean 元信息配置阶段 基于 XML、Properties 配置\nXMLBeanDefinitionReader#loadBeanDefinitions(String resourceUrl);\nBeanDefinitionReader 的实现类 AbstractBeanDefinitionReader，而 AbstractBeanDefinitionReader 有三个实现类。分别对应 XML、Properties、Groovy 文件读取方式。现在都不推荐用这几个。\npackage org.springframework.beans.factory.support; import org.springframework.beans.factory.BeanDefinitionStoreException; import org.springframework.core.io.Resource; import org.springframework.core.io.ResourceLoader; import org.springframework.lang.Nullable; public interface BeanDefinitionReader { BeanDefinitionRegistry getRegistry(); @Nullable ResourceLoader getResourceLoader(); @Nullable ClassLoader getBeanClassLoader(); BeanNameGenerator getBeanNameGenerator(); int loadBeanDefinitions(Resource var1) throws BeanDefinitionStoreException; int loadBeanDefinitions(Resource... var1) throws BeanDefinitionStoreException; int loadBeanDefinitions(String var1) throws BeanDefinitionStoreException; int loadBeanDefinitions(String... var1) throws BeanDefinitionStoreException; } public abstract class AbstractBeanDefinitionReader implements BeanDefinitionReader, EnvironmentCapable { protected final Log logger = LogFactory.getLog(this.getClass()); private final BeanDefinitionRegistry registry; @Nullable private ResourceLoader resourceLoader; @Nullable private ClassLoader beanClassLoader; private Environment environment; private BeanNameGenerator beanNameGenerator = new DefaultBeanNameGenerator(); protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) { Assert.notNull(registry, \u0026#34;BeanDefinitionRegistry must not be null\u0026#34;); this.registry = registry; if (this.registry instanceof ResourceLoader) { this.resourceLoader = (ResourceLoader)this.registry; } else { this.resourceLoader = new PathMatchingResourcePatternResolver(); } if (this.registry instanceof EnvironmentCapable) { this.environment = ((EnvironmentCapable)this.registry).getEnvironment(); } else { this.environment = new StandardEnvironment(); } } public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException { Assert.notNull(resources, \u0026#34;Resource array must not be null\u0026#34;); int count = 0; Resource[] var3 = resources; int var4 = resources.length; for(int var5 = 0; var5 \u0026lt; var4; ++var5) { Resource resource = var3[var5]; count += this.loadBeanDefinitions((Resource)resource); } return count; } public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException { return this.loadBeanDefinitions(location, (Set)null); } //\t按照其他的模块的性情，这里应该是 doLoadBeanDefinitions ，其他重载方法就是转换下内容。 public int loadBeanDefinitions(String location, @Nullable Set\u0026lt;Resource\u0026gt; actualResources) throws BeanDefinitionStoreException { ResourceLoader resourceLoader = this.getResourceLoader(); if (resourceLoader == null) { throw new BeanDefinitionStoreException(\u0026#34;Cannot load bean definitions from location [\u0026#34; + location + \u0026#34;]: no ResourceLoader available\u0026#34;); } else { int count; if (resourceLoader instanceof ResourcePatternResolver) { try { Resource[] resources = ((ResourcePatternResolver)resourceLoader).getResources(location); count = this.loadBeanDefinitions(resources); if (actualResources != null) { Collections.addAll(actualResources, resources); } if (this.logger.isTraceEnabled()) { this.logger.trace(\u0026#34;Loaded \u0026#34; + count + \u0026#34; bean definitions from location pattern [\u0026#34; + location + \u0026#34;]\u0026#34;); } return count; } catch (IOException var6) { throw new BeanDefinitionStoreException(\u0026#34;Could not resolve bean definition resource pattern [\u0026#34; + location + \u0026#34;]\u0026#34;, var6); } } else { Resource resource = resourceLoader.getResource(location); count = this.loadBeanDefinitions((Resource)resource); if (actualResources != null) { actualResources.add(resource); } if (this.logger.isTraceEnabled()) { this.logger.trace(\u0026#34;Loaded \u0026#34; + count + \u0026#34; bean definitions from location [\u0026#34; + location + \u0026#34;]\u0026#34;); } return count; } } } public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException { Assert.notNull(locations, \u0026#34;Location array must not be null\u0026#34;); int count = 0; String[] var3 = locations; int var4 = locations.length; for(int var5 = 0; var5 \u0026lt; var4; ++var5) { String location = var3[var5]; count += this.loadBeanDefinitions(location); } return count; } } ​\n基于 注解 配置\n就是配置 @Compment、 @Bean 等注解来实现，@Service 和 @Repository 里面有加 @Compment 只是为了让代码分层更清晰而已。\n基于 Spring API 配置\nDefaultListableBeanFactory 实现了 BeanRegistry 接口，其中 registerBeanDefinition 方法就是在配置。\npublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException {} 一般是这个 GenericBeanDefinition 类，不管你是什么类，在我这，都叫 BeanDefinition ，而且在后面会有个 Merge 过程，将所有 BeanDefinition 再次转换成 RootBeanDefinition 然后命名为 mbd 进行各种操作。\nSpring Bean 元信息解析阶段 面向资源 BeanDefinition 解析（里面有各种 Load 方法）\nBeanDefinitionReader XML 解析器 - BeanDefinitionParser 面向注解 BeanDefinition 解析\nAnnotatedBeanDefinitionReader 资源 类对象 - java.lang.Class 底层 条件评估 - ConditionEvaluator Bean 范围解析 - ScopeMetadataResolver BeanDefinition 解析 - 内部 API 实现 BeanDefinition 处理 - AnnotationConfigUtils.processCommonDefinitionAnnotations BeanDefinition 注册 - BeanDefinitionRegisty // 这个类没有子类，也不继承 Resource ,就是纯粹的解析注解的 BeanDefitionReader public class AnnotatedBeanDefinitionReader { // 这个的实现有 DefaultListableBeanFactory,AnnotationConfigServletWebApplicationContext等等 // 这也是个策略模式，通过构造器注入，使用不同 BeanDefinitionRegistry 来注册。 private final BeanDefinitionRegistry registry; // 这里一般是 AnnotationBeanNameGenerator 以类名首字母小写生成 beanName private BeanNameGenerator beanNameGenerator; // 解析元信息相关的数据，这是个接口，里面就一个方法，方法返回值是ScopeMetadata ，而ScopeMetadata包括 proxy 的一些信息 public enum ScopProxyMode {DEFAULT,NO,INTERFACE,TAGET_CLASS} private ScopeMetadataResolver scopeMetadataResolver; // 这是做评估的 具体在它的 shouldSkip 方法是不是该跳过当前 Bean 注册与否 private ConditionEvaluator conditionEvaluator; public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) { this(registry, getOrCreateEnvironment(registry)); } public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) { this.beanNameGenerator = new AnnotationBeanNameGenerator(); this.scopeMetadataResolver = new AnnotationScopeMetadataResolver(); Assert.notNull(registry, \u0026#34;BeanDefinitionRegistry must not be null\u0026#34;); Assert.notNull(environment, \u0026#34;Environment must not be null\u0026#34;); this.registry = registry; this.conditionEvaluator = new ConditionEvaluator(registry, environment, (ResourceLoader)null); AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); } public void register(Class\u0026lt;?\u0026gt;... annotatedClasses) { Class[] var2 = annotatedClasses; int var3 = annotatedClasses.length; for(int var4 = 0; var4 \u0026lt; var3; ++var4) { Class\u0026lt;?\u0026gt; annotatedClass = var2[var4]; this.registerBean(annotatedClass); } } public void registerBean(Class\u0026lt;?\u0026gt; annotatedClass) { this.doRegisterBean(annotatedClass, (Supplier)null, (String)null, (Class[])null); } public \u0026lt;T\u0026gt; void registerBean(Class\u0026lt;T\u0026gt; annotatedClass, @Nullable Supplier\u0026lt;T\u0026gt; instanceSupplier) { this.doRegisterBean(annotatedClass, instanceSupplier, (String)null, (Class[])null); } public \u0026lt;T\u0026gt; void registerBean(Class\u0026lt;T\u0026gt; annotatedClass, String name, @Nullable Supplier\u0026lt;T\u0026gt; instanceSupplier) { this.doRegisterBean(annotatedClass, instanceSupplier, name, (Class[])null); } public void registerBean(Class\u0026lt;?\u0026gt; annotatedClass, Class\u0026lt;? extends Annotation\u0026gt;... qualifiers) { this.doRegisterBean(annotatedClass, (Supplier)null, (String)null, qualifiers); } public void registerBean(Class\u0026lt;?\u0026gt; annotatedClass, String name, Class\u0026lt;? extends Annotation\u0026gt;... qualifiers) { this.doRegisterBean(annotatedClass, (Supplier)null, name, qualifiers); } \u0026lt;T\u0026gt; void doRegisterBean(Class\u0026lt;T\u0026gt; annotatedClass, @Nullable Supplier\u0026lt;T\u0026gt; instanceSupplier, @Nullable String name, @Nullable Class\u0026lt;? extends Annotation\u0026gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) { AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass); if (!this.conditionEvaluator.shouldSkip(abd.getMetadata())) { abd.setInstanceSupplier(instanceSupplier); ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd); abd.setScope(scopeMetadata.getScopeName()); // 这里命名了，就用你命名的，没命名就生成 String beanName = name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry); AnnotationConfigUtils.processCommonDefinitionAnnotations(abd); int var10; int var11; if (qualifiers != null) { Class[] var9 = qualifiers; var10 = qualifiers.length; for(var11 = 0; var11 \u0026lt; var10; ++var11) { Class\u0026lt;? extends Annotation\u0026gt; qualifier = var9[var11]; if (Primary.class == qualifier) { abd.setPrimary(true); } else if (Lazy.class == qualifier) { abd.setLazyInit(true); } else { abd.addQualifier(new AutowireCandidateQualifier(qualifier)); } } } BeanDefinitionCustomizer[] var13 = definitionCustomizers; var10 = definitionCustomizers.length; for(var11 = 0; var11 \u0026lt; var10; ++var11) { BeanDefinitionCustomizer customizer = var13[var11]; customizer.customize(abd); } BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry); } } } 这里你都用 Java API 方式配置了，一定有 BeanDefition 配置了。\nSpring Bean 注册阶段 DefaultListableBeanFactory 实现了 BeanDefinitionRegistry 。它还有其他的实现类，关于 XML 、注解、Groovy、Reactive（响应式的，Josh Long 在 19年推特上有置顶 《Reactive Spring》）、还有其他的 GenericApplicationContext。\npublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { // 判断参数是否合法 Assert.hasText(beanName, \u0026#34;Bean name must not be empty\u0026#34;); Assert.notNull(beanDefinition, \u0026#34;BeanDefinition must not be null\u0026#34;); // 这里进行一个转换 if (beanDefinition instanceof AbstractBeanDefinition) { try { ((AbstractBeanDefinition)beanDefinition).validate(); } catch (BeanDefinitionValidationException var9) { throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, \u0026#34;Validation of bean definition failed\u0026#34;, var9); } } // 这里判断是否存在响应的 BeanDefinition //\tbeanDefinitionMap //private final Map\u0026lt;String, BeanDefinition\u0026gt; beanDefinitionMap = new ConcurrentHashMap(256); BeanDefinition existingDefinition = (BeanDefinition)this.beanDefinitionMap.get(beanName); if (existingDefinition != null) { // Spring Boot 2.1 后有个开关，来看是否能够有相同 BeanDefition 存在，默认为 否 if (!this.isAllowBeanDefinitionOverriding()) { throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition); } // 这里的 Role 默认是 0，在造器中设置为 0 // 当前bean 定义的角色，初始化为 ROLE_APPLICATION ， 提示这是一个应用bean // 另外还有基础设施bean（仅供框架内部工作使用），和 支持bean // int ROLE_APPLICATION = 0; // int ROLE_SUPPORT = 1; // int ROLE_INFRASTRUCTURE = 2; if (existingDefinition.getRole() \u0026lt; beanDefinition.getRole()) { if (this.logger.isInfoEnabled()) { this.logger.info(\u0026#34;Overriding user-defined bean definition for bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39; with a framework-generated bean definition: replacing [\u0026#34; + existingDefinition + \u0026#34;] with [\u0026#34; + beanDefinition + \u0026#34;]\u0026#34;); } // 如果是同一个 BeanDefinition 那自己覆盖自己，没问题， } else if (!beanDefinition.equals(existingDefinition)) { if (this.logger.isDebugEnabled()) { this.logger.debug(\u0026#34;Overriding bean definition for bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39; with a different definition: replacing [\u0026#34; + existingDefinition + \u0026#34;] with [\u0026#34; + beanDefinition + \u0026#34;]\u0026#34;); } } else if (this.logger.isTraceEnabled()) { this.logger.trace(\u0026#34;Overriding bean definition for bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39; with an equivalent definition: replacing [\u0026#34; + existingDefinition + \u0026#34;] with [\u0026#34; + beanDefinition + \u0026#34;]\u0026#34;); } // 最终还是放进去了 this.beanDefinitionMap.put(beanName, beanDefinition); } else { // 这里表明是不是 BeanFacotory 开始加载了。通常是 false if (this.hasBeanCreationStarted()) { // 细化 锁 粒度，针对当前 BeanDefinitionMap 进行一系列非原子操作 // Cannot modify startup-time collection elements anymore (for stable iteration) synchronized(this.beanDefinitionMap) { this.beanDefinitionMap.put(beanName, beanDefinition); List\u0026lt;String\u0026gt; updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); // 这里 BeanDefinitionNames 是一个 ArrayList，是线程不安全的，这里的目的是为了记住 BeanDefinition 的加载顺序。让这里保证 FIFO First In First Out 先进先出 this.beanDefinitionNames = updatedDefinitions; if (this.manualSingletonNames.contains(beanName)) { Set\u0026lt;String\u0026gt; updatedSingletons = new LinkedHashSet(this.manualSingletonNames); updatedSingletons.remove(beanName); this.manualSingletonNames = updatedSingletons; } } } else { this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); this.manualSingletonNames.remove(beanName); } this.frozenBeanDefinitionNames = null; } if (existingDefinition != null || this.containsSingleton(beanName)) { this.resetBeanDefinition(beanName); } } Spring BeanDefinition 合并阶段 BeanDefinition 合并 父子 BeanDefinition 合并 当前 BeanFactory 查找 层次性 BeanFactory 查找 public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { //这个方法实际定义在 ConfigurableBeanFactory 中 @Override public BeanDefinition getMergedBeanDefinition(String name) throws BeansException { String beanName = this.transformedBeanName(name); //这里通过递归的方式去查找父类 return (BeanDefinition)(!this.containsBeanDefinition(beanName) \u0026amp;\u0026amp; this.getParentBeanFactory() instanceof ConfigurableBeanFactory ? ((ConfigurableBeanFactory)this.getParentBeanFactory()).getMergedBeanDefinition(beanName) : this.getMergedLocalBeanDefinition(beanName)); } } 一般的 BeanDefinition 是从 GenericBeanDefinition 转换成 RootBeanDefinition。子的 BeanDeifinition 去合并（merge）父的 BeanDefinition 相关配置。\nSpring Bean Class 加载阶段 //在 AbstractBeanFactory 中，执行依赖查找的时候，doGetBean 会执行 protected \u0026lt;T\u0026gt; T doGetBean(String name, @Nullable Class\u0026lt;T\u0026gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException { String beanName = this.transformedBeanName(name); Object sharedInstance = this.getSingleton(beanName); Object bean; if (sharedInstance != null \u0026amp;\u0026amp; args == null) { if (this.logger.isTraceEnabled()) { if (this.isSingletonCurrentlyInCreation(beanName)) { this.logger.trace(\u0026#34;Returning eagerly cached instance of singleton bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39; that is not fully initialized yet - a consequence of a circular reference\u0026#34;); } else { this.logger.trace(\u0026#34;Returning cached instance of singleton bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39;\u0026#34;); } } bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null); } else { if (this.isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } BeanFactory parentBeanFactory = this.getParentBeanFactory(); // 一般是为空 if (parentBeanFactory != null \u0026amp;\u0026amp; !this.containsBeanDefinition(beanName)) { String nameToLookup = this.originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) { return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly); } if (args != null) { return parentBeanFactory.getBean(nameToLookup, args); } if (requiredType != null) { return parentBeanFactory.getBean(nameToLookup, requiredType); } return parentBeanFactory.getBean(nameToLookup); } if (!typeCheckOnly) { this.markBeanAsCreated(beanName); } try { // 这里进行合并，将所有 BeanDefinition 转换为 RootBeanDefinition 进行操作。 RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName); //这里进行检查合并的 BeanDefinition this.checkMergedBeanDefinition(mbd, beanName, args); // 这里是检查依赖 String[] dependsOn = mbd.getDependsOn(); String[] var11; if (dependsOn != null) { var11 = dependsOn; int var12 = dependsOn.length; for(int var13 = 0; var13 \u0026lt; var12; ++var13) { String dep = var11[var13]; if (this.isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Circular depends-on relationship between \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39; and \u0026#39;\u0026#34; + dep + \u0026#34;\u0026#39;\u0026#34;); } this.registerDependentBean(dep, beanName); try { this.getBean(dep); } catch (NoSuchBeanDefinitionException var24) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;\u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39; depends on missing bean \u0026#39;\u0026#34; + dep + \u0026#34;\u0026#39;\u0026#34;, var24); } } } // 没有指定 Scope 默认是 Singleton ，会进这里 if (mbd.isSingleton()) { // 这里的 getSingleton 方法在下面 // spring-2 sharedInstance = this.getSingleton(beanName, () -\u0026gt; { try { // 这里是 Lambda 表达式内容，这里的 createBean 在下面。这个 CreateBean是子类来实现的，具体在下面⬇️ // spring-1 return this.createBean(beanName, mbd, args); } catch (BeansException var5) { this.destroySingleton(beanName); throw var5; } }); bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } else if (mbd.isPrototype()) { var11 = null; Object prototypeInstance; try { this.beforePrototypeCreation(beanName); prototypeInstance = this.createBean(beanName, mbd, args); } finally { this.afterPrototypeCreation(beanName); } bean = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } else { String scopeName = mbd.getScope(); Scope scope = (Scope)this.scopes.get(scopeName); if (scope == null) { throw new IllegalStateException(\u0026#34;No Scope registered for scope name \u0026#39;\u0026#34; + scopeName + \u0026#34;\u0026#39;\u0026#34;); } try { Object scopedInstance = scope.get(beanName, () -\u0026gt; { this.beforePrototypeCreation(beanName); Object var4; try { var4 = this.createBean(beanName, mbd, args); } finally { this.afterPrototypeCreation(beanName); } return var4; }); bean = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException var23) { throw new BeanCreationException(beanName, \u0026#34;Scope \u0026#39;\u0026#34; + scopeName + \u0026#34;\u0026#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton\u0026#34;, var23); } } } catch (BeansException var26) { this.cleanupAfterBeanCreationFailure(beanName); throw var26; } } if (requiredType != null \u0026amp;\u0026amp; !requiredType.isInstance(bean)) { try { T convertedBean = this.getTypeConverter().convertIfNecessary(bean, requiredType); if (convertedBean == null) { throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); } else { return convertedBean; } } catch (TypeMismatchException var25) { if (this.logger.isTraceEnabled()) { this.logger.trace(\u0026#34;Failed to convert bean \u0026#39;\u0026#34; + name + \u0026#34;\u0026#39; to required type \u0026#39;\u0026#34; + ClassUtils.getQualifiedName(requiredType) + \u0026#34;\u0026#39;\u0026#34;, var25); } throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); } } else { return bean; } } // 获得 SingletonBean public Object getSingleton(String beanName, ObjectFactory\u0026lt;?\u0026gt; singletonFactory) { Assert.notNull(beanName, \u0026#34;Bean name must not be null\u0026#34;); // 这里是一个 ConcurentHashMap synchronized(this.singletonObjects) { Object singletonObject = this.singletonObjects.get(beanName); // 在 ObjectFactory 中找到这个 Bean 就直接返回了，下面是为 null 才会才会操作 if (singletonObject == null) { if (this.singletonsCurrentlyInDestruction) { throw new BeanCreationNotAllowedException(beanName, \u0026#34;Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)\u0026#34;); } if (this.logger.isDebugEnabled()) { this.logger.debug(\u0026#34;Creating shared instance of singleton bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39;\u0026#34;); } this.beforeSingletonCreation(beanName); boolean newSingleton = false; boolean recordSuppressedExceptions = this.suppressedExceptions == null; if (recordSuppressedExceptions) { this.suppressedExceptions = new LinkedHashSet(); } try { // 没有找到会在这里进行 getObject，这里是没有实现的，具体的在上面的 Lambda 表达式中有。往上翻⬆️ // 上面采用匿名类实现 SingletonFactory // spring-2 singletonObject = singletonFactory.getObject(); newSingleton = true; } catch (IllegalStateException var16) { singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { throw var16; } } catch (BeanCreationException var17) { BeanCreationException ex = var17; if (recordSuppressedExceptions) { Iterator var8 = this.suppressedExceptions.iterator(); while(var8.hasNext()) { Exception suppressedException = (Exception)var8.next(); ex.addRelatedCause(suppressedException); } } throw ex; } finally { if (recordSuppressedExceptions) { this.suppressedExceptions = null; } this.afterSingletonCreation(beanName); } if (newSingleton) { this.addSingleton(beanName, singletonObject); } } return singletonObject; } } //这个是 AbstractBeanFactory 的子类进行实现的。具体的类名称，叫AbstractAutowireCapableBeanFactory // spring-1 protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { if (this.logger.isTraceEnabled()) { this.logger.trace(\u0026#34;Creating instance of bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39;\u0026#34;); } RootBeanDefinition mbdToUse = mbd; // 这里的 resolveBeanClass Class\u0026lt;?\u0026gt; resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]); if (resolvedClass != null \u0026amp;\u0026amp; !mbd.hasBeanClass() \u0026amp;\u0026amp; mbd.getBeanClassName() != null) { mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); } try { mbdToUse.prepareMethodOverrides(); } catch (BeanDefinitionValidationException var9) { throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, \u0026#34;Validation of method overrides failed\u0026#34;, var9); } Object beanInstance; try { beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse); if (beanInstance != null) { return beanInstance; } } catch (Throwable var10) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \u0026#34;BeanPostProcessor before instantiation of bean failed\u0026#34;, var10); } try { // 这里的 doCreateBean 在下面实例化 Bean 中有讲解 ⬇️ // spring-3 beanInstance = this.doCreateBean(beanName, mbdToUse, args); if (this.logger.isTraceEnabled()) { this.logger.trace(\u0026#34;Finished creating instance of bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39;\u0026#34;); } return beanInstance; } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) { throw var7; } catch (Throwable var8) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \u0026#34;Unexpected exception during bean creation\u0026#34;, var8); } } //这里就是在 RootBeanDefinition 进行 getBeanClass 操作 @Nullable protected Class\u0026lt;?\u0026gt; resolveBeanClass(RootBeanDefinition mbd, String beanName, Class\u0026lt;?\u0026gt;... typesToMatch) throws CannotLoadBeanClassException { try { // 判断当前是否有 BeanClass if (mbd.hasBeanClass()) { return mbd.getBeanClass(); } else { // 这里判断 Java 安全方面内容有没有激活，如果激活了，就不等于空，那就以安全的方式来resolveBeanClass return System.getSecurityManager() != null ? (Class)AccessController.doPrivileged(() -\u0026gt; { //这里来 resovleBeanClass 具体内容看下面⬇️第六步 // spring-4 return this.doResolveBeanClass(mbd, typesToMatch); }, this.getAccessControlContext()) : this.doResolveBeanClass(mbd, typesToMatch); } } catch (PrivilegedActionException var6) { ClassNotFoundException ex = (ClassNotFoundException)var6.getException(); throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex); } catch (ClassNotFoundException var7) { throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), var7); } catch (LinkageError var8) { throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), var8); } } // 这里来 doResovleBeanClass // spring-4 private Class\u0026lt;?\u0026gt; doResolveBeanClass(RootBeanDefinition mbd, Class\u0026lt;?\u0026gt;... typesToMatch) throws ClassNotFoundException { // 这里有两个 ClassLoader，一个是当前 BeanFactory 的 ClassLoader ，默认是 AppClassloader ClassLoader beanClassLoader = this.getBeanClassLoader(); // 这是一个 dynamicClassLoader ClassLoader dynamicLoader = beanClassLoader; boolean freshResolve = false; // 一般这里都不会激活 start if (!ObjectUtils.isEmpty(typesToMatch)) { ClassLoader tempClassLoader = this.getTempClassLoader(); if (tempClassLoader != null) { dynamicLoader = tempClassLoader; freshResolve = true; if (tempClassLoader instanceof DecoratingClassLoader) { DecoratingClassLoader dcl = (DecoratingClassLoader)tempClassLoader; Class[] var8 = typesToMatch; int var9 = typesToMatch.length; for(int var10 = 0; var10 \u0026lt; var9; ++var10) { Class\u0026lt;?\u0026gt; typeToMatch = var8[var10]; dcl.excludeClass(typeToMatch.getName()); } } } } // 一般这里都不会激活 end //这里获取 BeanClassName String className = mbd.getBeanClassName(); if (className != null) { // 这里评估一下 BeanClass，有时候 BeanClass 的名称和这个名称是不一样的 Object evaluated = this.evaluateBeanDefinitionString(className, mbd); if (!className.equals(evaluated)) { if (evaluated instanceof Class) { return (Class)evaluated; } if (!(evaluated instanceof String)) { throw new IllegalStateException(\u0026#34;Invalid class name expression result: \u0026#34; + evaluated); } className = (String)evaluated; freshResolve = true; } // 这里一般也是 false，不会走这里 if (freshResolve) { if (dynamicLoader != null) { try { return dynamicLoader.loadClass(className); } catch (ClassNotFoundException var12) { if (this.logger.isTraceEnabled()) { this.logger.trace(\u0026#34;Could not load class [\u0026#34; + className + \u0026#34;] from \u0026#34; + dynamicLoader + \u0026#34;: \u0026#34; + var12); } } } // 和这里一样 return ClassUtils.forName(className, dynamicLoader); } } // 这里才是关键 return mbd.resolveBeanClass(beanClassLoader); } // 这个是 AbstractBeanDefinition 中的方法，这里利用反射来加载 Bean @Nullable public Class\u0026lt;?\u0026gt; resolveBeanClass(@Nullable ClassLoader classLoader) throws ClassNotFoundException { String className = this.getBeanClassName(); if (className == null) { return null; } else { Class\u0026lt;?\u0026gt; resolvedClass = ClassUtils.forName(className, classLoader); this.beanClass = resolvedClass; return resolvedClass; } } 至此 BeanDefinition 变成 Class 的操作已经结束。一般情况下，就是利用 加载 BeanFactory 的ClassLoader来加载，只是多了个 Java 安全的校验加载。\nSpring Bean 实例化前阶段 主要是下面这个接口，在Spring 5前面有个Adpter类，就是和 WebMvcConfigurerAdapter 一样，为了适配之后的类。继承这个接口，实现 postProcessBeforeInstantiation 方法，就可以对 Bean 实例化前进行操作。增强事务功能就是对这个方法进行了改造。\npublic interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor { @Nullable default Object postProcessBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) throws BeansException { //这里可以返回一个代理对象，为 null 就是不做改变，具体在 return null; } // 如果上面返回对象不为空，那么马上就会执行这一步操作，为空，则在 population 中执行。属性填充后执行 default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException { return true; } @Nullable default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException { return null; } /** @deprecated */ @Deprecated @Nullable default PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException { return pvs; } } //AbstractAutowireCapableBeanFactory // 这里创建 Bean protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { if (this.logger.isTraceEnabled()) { this.logger.trace(\u0026#34;Creating instance of bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39;\u0026#34;); } RootBeanDefinition mbdToUse = mbd; // 这个就是上面的 BeanDefinition 转换为 Class 的调用 Class\u0026lt;?\u0026gt; resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]); if (resolvedClass != null \u0026amp;\u0026amp; !mbd.hasBeanClass() \u0026amp;\u0026amp; mbd.getBeanClassName() != null) { mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); } try { mbdToUse.prepareMethodOverrides(); } catch (BeanDefinitionValidationException var9) { throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, \u0026#34;Validation of method overrides failed\u0026#34;, var9); } Object beanInstance; try { // 这里进行 Bean 的前置处理，具体方法实现内容 如下⬇️ // 对应上面的 postProcessBeforeInstantiation 方法，如果返回了对象，则直接跳过下面的 doCreateBean 方法。 // spring-5 beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse); // 就是这里对 Bean 进行了判断，如果实例化前就把这个 Bean 给返回了，那就不用执行下面的操作le if (beanInstance != null) { return beanInstance; } } catch (Throwable var10) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \u0026#34;BeanPostProcessor before instantiation of bean failed\u0026#34;, var10); } try { beanInstance = this.doCreateBean(beanName, mbdToUse, args); if (this.logger.isTraceEnabled()) { this.logger.trace(\u0026#34;Finished creating instance of bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39;\u0026#34;); } return beanInstance; } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) { throw var7; } catch (Throwable var8) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \u0026#34;Unexpected exception during bean creation\u0026#34;, var8); } } // AbstractAutowireCapableBeanFactory // spring-5 @Nullable protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) { Object bean = null; if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) { if (!mbd.isSynthetic() \u0026amp;\u0026amp; this.hasInstantiationAwareBeanPostProcessors()) { //目标类型 Class\u0026lt;?\u0026gt; targetType = this.determineTargetType(beanName, mbd); // 这里就是判断，执行前置操作 applyBeanPostProcessorsBeforeInstantiation 这里面的内容其实就是 获得 BeanPostProcessor 然后遍历出 InstantiationAwareBeanPostProcessor 执行 postProcessBeforeInstantiation 方法。这里可以来个狸猫换太子，用代理对象替换 Bean if (targetType != null) { bean = this.applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); // 如果这里的 Bean 不为空，马上执行 后置操作 postProcessAfterInitialization#postProcessAfterInitialization() if (bean != null) { bean = this.applyBeanPostProcessorsAfterInitialization(bean, beanName); } } } mbd.beforeInstantiationResolved = bean != null; } return bean; } // AbstractAutowireCapableBeanFactory // spring-3 protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { instanceWrapper = this.createBeanInstance(beanName, mbd, args); } Object bean = instanceWrapper.getWrappedInstance(); Class\u0026lt;?\u0026gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } synchronized(mbd.postProcessingLock) { if (!mbd.postProcessed) { try { // 合并 BeanDefinition 前置操作 this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable var17) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Post-processing of merged bean definition failed\u0026#34;, var17); } mbd.postProcessed = true; } } // 这里检查循环依赖 boolean earlySingletonExposure = mbd.isSingleton() \u0026amp;\u0026amp; this.allowCircularReferences \u0026amp;\u0026amp; this.isSingletonCurrentlyInCreation(beanName); if (earlySingletonExposure) { if (this.logger.isTraceEnabled()) { this.logger.trace(\u0026#34;Eagerly caching bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39; to allow for resolving potential circular references\u0026#34;); } this.addSingletonFactory(beanName, () -\u0026gt; { return this.getEarlyBeanReference(beanName, mbd, bean); }); } Object exposedObject = bean; try { // 这里执行 属性填充 功能，具体代码在下面 this.populateBean(beanName, mbd, instanceWrapper); // 这里是初始化 Bean ，初始化 Bean 才执行 postProcessBeforeInstantiation 这个操作，具体的在下面 ⬇️ // spring-6 exposedObject = this.initializeBean(beanName, exposedObject, mbd); } catch (Throwable var18) { if (var18 instanceof BeanCreationException \u0026amp;\u0026amp; beanName.equals(((BeanCreationException)var18).getBeanName())) { throw (BeanCreationException)var18; } throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Initialization of bean failed\u0026#34;, var18); } if (earlySingletonExposure) { Object earlySingletonReference = this.getSingleton(beanName, false); if (earlySingletonReference != null) { if (exposedObject == bean) { exposedObject = earlySingletonReference; } else if (!this.allowRawInjectionDespiteWrapping \u0026amp;\u0026amp; this.hasDependentBean(beanName)) { String[] dependentBeans = this.getDependentBeans(beanName); Set\u0026lt;String\u0026gt; actualDependentBeans = new LinkedHashSet(dependentBeans.length); String[] var12 = dependentBeans; int var13 = dependentBeans.length; for(int var14 = 0; var14 \u0026lt; var13; ++var14) { String dependentBean = var12[var14]; if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, \u0026#34;Bean with name \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39; has been injected into other beans [\u0026#34; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \u0026#34;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using \u0026#39;getBeanNamesOfType\u0026#39; with the \u0026#39;allowEagerInit\u0026#39; flag turned off, for example.\u0026#34;); } } } } try { this.registerDisposableBeanIfNecessary(beanName, bean, mbd); return exposedObject; } catch (BeanDefinitionValidationException var16) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Invalid destruction signature\u0026#34;, var16); } } // AbstractAutowireCapableBeanFactory protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) { if (bw == null) { if (mbd.hasPropertyValues()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Cannot apply property values to null instance\u0026#34;); } // 老版本的 Spring 中，是有个 else{return;}的，不过是多此一举，下面的 esle 包裹到了方法结束 } else { boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() \u0026amp;\u0026amp; this.hasInstantiationAwareBeanPostProcessors()) { Iterator var5 = this.getBeanPostProcessors().iterator(); while(var5.hasNext()) { BeanPostProcessor bp = (BeanPostProcessor)var5.next(); // 这里就是 Bean 实例化前的操作，执行 postProcessAfterInstantiation 方法 if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp; // 返回值为是否继续填充 Bean if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { continueWithPropertyPopulation = false; break; } } } } //如果后处理器继续填充，则执行下面代码，原来这里是 if(!continueWithPropertyPopulation){return;} if (continueWithPropertyPopulation) { PropertyValues pvs = mbd.hasPropertyValues() ? mbd.getPropertyValues() : null; if (mbd.getResolvedAutowireMode() == 1 || mbd.getResolvedAutowireMode() == 2) { MutablePropertyValues newPvs = new MutablePropertyValues((PropertyValues)pvs); //这里以前是 == RootBeanDefinition.AUTOWIRE_BY_NAME，这种硬编码的方式，这就是魔法值了。要被 alibaba 编码规范插件检测出来的。 if (mbd.getResolvedAutowireMode() == 1) { //根据名称自动注入 this.autowireByName(beanName, mbd, bw, newPvs); } // 同上 if (mbd.getResolvedAutowireMode() == 2) { //根据类型自动注入 this.autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } boolean hasInstAwareBpps = this.hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = mbd.getDependencyCheck() != 0; PropertyDescriptor[] filteredPds = null; if (hasInstAwareBpps) { if (pvs == null) { pvs = mbd.getPropertyValues(); } Iterator var9 = this.getBeanPostProcessors().iterator(); while(var9.hasNext()) { BeanPostProcessor bp = (BeanPostProcessor)var9.next(); if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp; PropertyValues pvsToUse = ibp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { if (filteredPds == null) { filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } pvsToUse = ibp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { return; } } pvs = pvsToUse; } } } if (needsDepCheck) { if (filteredPds == null) { filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } this.checkDependencies(beanName, mbd, filteredPds, (PropertyValues)pvs); } if (pvs != null) { this.applyPropertyValues(beanName, mbd, bw, (PropertyValues)pvs); } } } } //AbstractAutowireCapableBeanFactory // spring-6 protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) { if (System.getSecurityManager() != null) { AccessController.doPrivileged(() -\u0026gt; { this.invokeAwareMethods(beanName, bean); return null; }, this.getAccessControlContext()); } else { // 这个方法在下面，就是执行各种 Aware 接口 ⬇️ // spring-7 this.invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { wrappedBean = this.applyBeanPostProcessorsBeforeInitialization(bean, beanName); } try { this.invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable var6) { throw new BeanCreationException(mbd != null ? mbd.getResourceDescription() : null, beanName, \u0026#34;Invocation of init method failed\u0026#34;, var6); } if (mbd == null || !mbd.isSynthetic()) { wrappedBean = this.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean; } //AbstractAutowireCapableBeanFactory // spring-7 private void invokeAwareMethods(String beanName, Object bean) { if (bean instanceof Aware) { if (bean instanceof BeanNameAware) { ((BeanNameAware)bean).setBeanName(beanName); } if (bean instanceof BeanClassLoaderAware) { ClassLoader bcl = this.getBeanClassLoader(); if (bcl != null) { ((BeanClassLoaderAware)bean).setBeanClassLoader(bcl); } } if (bean instanceof BeanFactoryAware) { ((BeanFactoryAware)bean).setBeanFactory(this); } } } Spring Bean 实例化阶段 传统实例化方式 实例化策略 - InstantiationStrategy 构造器依赖注入（这里的一个方法有几百行代码，去验证，加载，如果参数比较多，不建议构造器注入） 实例化就是上面的 doCreateBean 方法。\n// AbstractAutowireCapableBeanFactory protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { // 这里引入一个 Wrapper 一个 Bean 实例的包装，可以做很多事 BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { // private final ConcurrentMap\u0026lt;String, BeanWrapper\u0026gt; factoryBeanInstanceCache; instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName); } // 如果 这个 wrapper 为空，就去创建，一般会进这里 if (instanceWrapper == null) { // 这个 createBeanInstance 方法在下面 ⬇️ // spring-8 instanceWrapper = this.createBeanInstance(beanName, mbd, args); } Object bean = instanceWrapper.getWrappedInstance(); Class\u0026lt;?\u0026gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } synchronized(mbd.postProcessingLock) { if (!mbd.postProcessed) { try { // 合并 BeanDefinition 前置操作 this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable var17) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Post-processing of merged bean definition failed\u0026#34;, var17); } mbd.postProcessed = true; } } // 这里检查循环依赖 boolean earlySingletonExposure = mbd.isSingleton() \u0026amp;\u0026amp; this.allowCircularReferences \u0026amp;\u0026amp; this.isSingletonCurrentlyInCreation(beanName); if (earlySingletonExposure) { if (this.logger.isTraceEnabled()) { this.logger.trace(\u0026#34;Eagerly caching bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39; to allow for resolving potential circular references\u0026#34;); } this.addSingletonFactory(beanName, () -\u0026gt; { return this.getEarlyBeanReference(beanName, mbd, bean); }); } Object exposedObject = bean; try { // 这里执行 属性填充 功能，具体代码在下面 this.populateBean(beanName, mbd, instanceWrapper); // 这里是初始化 Bean ，初始化 Bean 才执行 postProcessBeforeInstantiation 这个操作，具体的在下面 ⬇️ // spring-6 exposedObject = this.initializeBean(beanName, exposedObject, mbd); } catch (Throwable var18) { if (var18 instanceof BeanCreationException \u0026amp;\u0026amp; beanName.equals(((BeanCreationException)var18).getBeanName())) { throw (BeanCreationException)var18; } throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Initialization of bean failed\u0026#34;, var18); } if (earlySingletonExposure) { Object earlySingletonReference = this.getSingleton(beanName, false); if (earlySingletonReference != null) { if (exposedObject == bean) { exposedObject = earlySingletonReference; } else if (!this.allowRawInjectionDespiteWrapping \u0026amp;\u0026amp; this.hasDependentBean(beanName)) { String[] dependentBeans = this.getDependentBeans(beanName); Set\u0026lt;String\u0026gt; actualDependentBeans = new LinkedHashSet(dependentBeans.length); String[] var12 = dependentBeans; int var13 = dependentBeans.length; for(int var14 = 0; var14 \u0026lt; var13; ++var14) { String dependentBean = var12[var14]; if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, \u0026#34;Bean with name \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39; has been injected into other beans [\u0026#34; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \u0026#34;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using \u0026#39;getBeanNamesOfType\u0026#39; with the \u0026#39;allowEagerInit\u0026#39; flag turned off, for example.\u0026#34;); } } } } try { this.registerDisposableBeanIfNecessary(beanName, bean, mbd); return exposedObject; } catch (BeanDefinitionValidationException var16) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Invalid destruction signature\u0026#34;, var16); } } //AbstractAutowireCapableBeanFactory // spring-8 protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) { // 这里的 resovleBeanClass 就是上面提到的 BeanClass 加载， Class\u0026lt;?\u0026gt; beanClass = this.resolveBeanClass(mbd, beanName, new Class[0]); if (beanClass != null \u0026amp;\u0026amp; !Modifier.isPublic(beanClass.getModifiers()) \u0026amp;\u0026amp; !mbd.isNonPublicAccessAllowed()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Bean class isn\u0026#39;t public, and non-public access not allowed: \u0026#34; + beanClass.getName()); } else { // 这是一个函数式接口，在 Spring5 之前不支持这个，一般用 @Compment 来声明的，是为 null Supplier\u0026lt;?\u0026gt; instanceSupplier = mbd.getInstanceSupplier(); if (instanceSupplier != null) { return this.obtainFromSupplier(instanceSupplier, beanName); } else if (mbd.getFactoryMethodName() != null) { // 这个也一般不会执行，根据 BeanFactoryName 去获取 BeanWrapper return this.instantiateUsingFactoryMethod(beanName, mbd, args); } else { //\t更多的是执行这个,resoled 判断对象是否被处理过 boolean resolved = false; boolean autowireNecessary = false; if (args == null) { synchronized(mbd.constructorArgumentLock) { // spring-11 if (mbd.resolvedConstructorOrFactoryMethod != null) { resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; } } } //一般这里是不满足的 if (resolved) { return autowireNecessary ? this.autowireConstructor(beanName, mbd, (Constructor[])null, (Object[])null) : this.instantiateBean(beanName, mbd); } else { // 一般这里不满足，直接跳过 // spring-10 Constructor\u0026lt;?\u0026gt;[] ctors = this.determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors == null \u0026amp;\u0026amp; mbd.getResolvedAutowireMode() != 3 \u0026amp;\u0026amp; !mbd.hasConstructorArgumentValues() \u0026amp;\u0026amp; ObjectUtils.isEmpty(args)) { //这里通常来说是null ctors = mbd.getPreferredConstructors(); // 这个 instantiaeaBean 调用无参构造器 方法如下 // 之前的代码是 if(ctors!=null){return autowireConstructor(beanName, mbd, ctors, (Object[])null)} return ctors != null ? this.autowireConstructor(beanName, mbd, ctors, (Object[])null) : this.instantiateBean(beanName, mbd); } else { // 这边是根据有参构造器 注入 // 一般情况下的 Bean 走的这个方法，不做特殊处理 return this.autowireConstructor(beanName, mbd, ctors, args); } } } } } //AbstractAutowireCapableBeanFactory protected BeanWrapper instantiateBean(String beanName, RootBeanDefinition mbd) { try { Object beanInstance; if (System.getSecurityManager() != null) { beanInstance = AccessController.doPrivileged(() -\u0026gt; { // instantiate(mbd, beanName, this) 这个方法是重点 return thisx.getInstantiationStrategy().instantiate(mbd, beanName, this); }, this.getAccessControlContext()); } else { //\t这里就是 通过传统的方式，InstantiationStrategy 默认是CglibSubclassingInstantiationStrategy 这里\t// 就清楚了，默认采用 Cglib 方法代理生成 Bean。在无参构造器方法中有写。然后这个 instantiate 方法是\t// SimpleInstantiationStrategy 类的，具体方法如下⬇️ // spring-9 beanInstance = this.getInstantiationStrategy().instantiate(mbd, beanName, this); } BeanWrapper bw = new BeanWrapperImpl(beanInstance); this.initBeanWrapper(bw); return bw; } catch (Throwable var6) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Instantiation of bean failed\u0026#34;, var6); } } //AbstractAutowireCapableBeanFactory public AbstractAutowireCapableBeanFactory() { this.instantiationStrategy = new CglibSubclassingInstantiationStrategy(); this.parameterNameDiscoverer = new DefaultParameterNameDiscoverer(); this.allowCircularReferences = true; this.allowRawInjectionDespiteWrapping = false; this.ignoredDependencyTypes = new HashSet(); this.ignoredDependencyInterfaces = new HashSet(); this.currentlyCreatedBean = new NamedThreadLocal(\u0026#34;Currently created bean\u0026#34;); this.factoryBeanInstanceCache = new ConcurrentHashMap(); this.factoryMethodCandidateCache = new ConcurrentHashMap(); this.filteredPropertyDescriptorsCache = new ConcurrentHashMap(); this.ignoreDependencyInterface(BeanNameAware.class); this.ignoreDependencyInterface(BeanFactoryAware.class); this.ignoreDependencyInterface(BeanClassLoaderAware.class); } //SimpleInstantiationStrategy // spring-9 public Object (RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) { //\t这里判断是否方法覆盖 if (!bd.hasMethodOverrides()) { Constructor constructorToUse; synchronized(bd.constructorArgumentLock) { // 这里看是否已经处理掉 构造器或者工厂方法 constructorToUse = (Constructor)bd.resolvedConstructorOrFactoryMethod; if (constructorToUse == null) { //然后进这个方法 Class\u0026lt;?\u0026gt; clazz = bd.getBeanClass(); // 这里判断，是否是个接口，是接口直接报错，抛出异常。当然 JPA/MyBatis plus 类似处理注解 AutowiredAnnotationBeanPostProcessor // implements BeanPostProcessor, BeanFactoryAware 实现这两个接口，然后做 Bean 前置处理，将接口语义转换成实体类，或者用JDK/Cglib做提升，生成代理类 if (clazz.isInterface()) { throw new BeanInstantiationException(clazz, \u0026#34;Specified class is an interface\u0026#34;); } try { // 这里又要和安全相关的，因为这里要调用反射 if (System.getSecurityManager() != null) { clazz.getClass(); constructorToUse = (Constructor)AccessController.doPrivileged(() -\u0026gt; { return clazz.getDeclaredConstructor(); }); } else { // 这里得到默认的无参构造器 constructorToUse = clazz.getDeclaredConstructor(); } // resolvedConstructorOrFactoryMethod 这个就不为空了，对应前面的 // spring-11 bd.resolvedConstructorOrFactoryMethod = constructorToUse; } catch (Throwable var9) { throw new BeanInstantiationException(clazz, \u0026#34;No default constructor found\u0026#34;, var9); } } } //\t这里面就是 利用反射创建，newInstance，默认的无参构造器 // 这个阶段，还没有完成属性的 创建和初始化。 return BeanUtils.instantiateClass(constructorToUse, new Object[0]); } else { // return this.instantiateWithMethodInjection(bd, beanName, owner); } } // spring-10 @Nullable protected Constructor\u0026lt;?\u0026gt;[] determineConstructorsFromBeanPostProcessors(@Nullable Class\u0026lt;?\u0026gt; beanClass, String beanName) throws BeansException { if (beanClass != null \u0026amp;\u0026amp; this.hasInstantiationAwareBeanPostProcessors()) { Iterator var3 = this.getBeanPostProcessors().iterator(); while(var3.hasNext()) { BeanPostProcessor bp = (BeanPostProcessor)var3.next(); if (bp instanceof SmartInstantiationAwareBeanPostProcessor) { SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor)bp; // 实现一种拦截机制，来取调用哪种构造器 Constructor\u0026lt;?\u0026gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName); if (ctors != null) { return ctors; } } } } return null; } 构造器注入，是按照类型注入。也可以通过 @Qualifier指定\nSpring Bean 实例化后阶段 // InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation //判断当前 Bean 是不是要属性填入，如果是，则返回 true，如果不是返回 false。也就是这里可以做一个拦截。具体代码如下 //属性填充阶段后，再去操作，populateBean 方法 // AbstractAutowireCapableBeanFactory // 该方法是 对 Bean 进行属性填充。 protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) { if (bw == null) { if (mbd.hasPropertyValues()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Cannot apply property values to null instance\u0026#34;); } // 老版本的 Spring 中，是有个 else{return;}的，不过是多此一举，下面的 esle 包裹到了方法结束 } else { boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() \u0026amp;\u0026amp; this.hasInstantiationAwareBeanPostProcessors()) { Iterator var5 = this.getBeanPostProcessors().iterator(); while(var5.hasNext()) { BeanPostProcessor bp = (BeanPostProcessor)var5.next(); // 这里就是 Bean 实例化前的操作，执行 postProcessAfterInstantiation 方法 if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp; // 返回值为是否继续填充 Bean，如果为 false，则取反，执行 if 里面的操作。就会跳过后面的属性填充。 if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { // 这里为 false ，下面的 if 方法不会执行。 continueWithPropertyPopulation = false; break; } } } } //如果后处理器继续填充，则执行下面代码，原来这里是 if(!continueWithPropertyPopulation){return;} if (continueWithPropertyPopulation) { PropertyValues pvs = mbd.hasPropertyValues() ? mbd.getPropertyValues() : null; if (mbd.getResolvedAutowireMode() == 1 || mbd.getResolvedAutowireMode() == 2) { MutablePropertyValues newPvs = new MutablePropertyValues((PropertyValues)pvs); //这里以前是 == RootBeanDefinition.AUTOWIRE_BY_NAME，这种硬编码的方式，这就是魔法值了。要被 alibaba 编码规范插件检测出来的。 if (mbd.getResolvedAutowireMode() == 1) { //根据名称自动注入 this.autowireByName(beanName, mbd, bw, newPvs); } // 同上 if (mbd.getResolvedAutowireMode() == 2) { //根据类型自动注入 this.autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } boolean hasInstAwareBpps = this.hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = mbd.getDependencyCheck() != 0; PropertyDescriptor[] filteredPds = null; if (hasInstAwareBpps) { if (pvs == null) { pvs = mbd.getPropertyValues(); } Iterator var9 = this.getBeanPostProcessors().iterator(); while(var9.hasNext()) { BeanPostProcessor bp = (BeanPostProcessor)var9.next(); if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp; PropertyValues pvsToUse = ibp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { if (filteredPds == null) { filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } pvsToUse = ibp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { return; } } pvs = pvsToUse; } } } if (needsDepCheck) { if (filteredPds == null) { filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } this.checkDependencies(beanName, mbd, filteredPds, (PropertyValues)pvs); } if (pvs != null) { this.applyPropertyValues(beanName, mbd, bw, (PropertyValues)pvs); } } } } // 2 // 其实在 AbstractAutowiredCapableBeanFactory 中，如果在 doCreateBean 执行之前，就已经返回了 Bean 实例，那么 // doCreateBean 是不会执行的，为保证 postProcessAfterInstantiation 在 Bean 实例化后一定执行，下面的代码就展示了如何实现的 // AbstractAutowireCapableBeanFactory // spring-12 @Nullable protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) { Object bean = null; if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) { if (!mbd.isSynthetic() \u0026amp;\u0026amp; this.hasInstantiationAwareBeanPostProcessors()) { Class\u0026lt;?\u0026gt; targetType = this.determineTargetType(beanName, mbd); if (targetType != null) { // 在这个方法 bean = this.applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); if (bean != null) { bean = this.applyBeanPostProcessorsAfterInitialization(bean, beanName); } } } mbd.beforeInstantiationResolved = bean != null; } return bean; } // 1 // AbstractAutowireCapableBeanFactory // 创建 Bean protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { if (this.logger.isTraceEnabled()) { this.logger.trace(\u0026#34;Creating instance of bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39;\u0026#34;); } RootBeanDefinition mbdToUse = mbd; Class\u0026lt;?\u0026gt; resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]); if (resolvedClass != null \u0026amp;\u0026amp; !mbd.hasBeanClass() \u0026amp;\u0026amp; mbd.getBeanClassName() != null) { mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); } try { mbdToUse.prepareMethodOverrides(); } catch (BeanDefinitionValidationException var9) { throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, \u0026#34;Validation of method overrides failed\u0026#34;, var9); } Object beanInstance; try { // spring-12 // 这里是解析实例化前，如果有 Bean 实例，就直接返回，跳过下面的 doCreateBean 方法。 beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse); if (beanInstance != null) { return beanInstance; } } catch (Throwable var10) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \u0026#34;BeanPostProcessor before instantiation of bean failed\u0026#34;, var10); } try { beanInstance = this.doCreateBean(beanName, mbdToUse, args); if (this.logger.isTraceEnabled()) { this.logger.trace(\u0026#34;Finished creating instance of bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39;\u0026#34;); } return beanInstance; } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) { throw var7; } catch (Throwable var8) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \u0026#34;Unexpected exception during bean creation\u0026#34;, var8); } } // 3 @Nullable protected Object applyBeanPostProcessorsBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) { Iterator var3 = this.getBeanPostProcessors().iterator(); while(var3.hasNext()) { BeanPostProcessor bp = (BeanPostProcessor)var3.next(); if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp; Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName); if (result != null) { return result; } } } return null; } //4 public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException { Object result = existingBean; Object current; for(Iterator var4 = this.getBeanPostProcessors().iterator(); var4.hasNext(); result = current) { BeanPostProcessor processor = (BeanPostProcessor)var4.next(); current = processor.postProcessAfterInitialization(result, beanName); if (current == null) { return result; } } return result; } 也就是为保证 postProcessAfterInitialization 方法一定执行，其实有两处互斥的地方调用了该方法。\nSpring Bean 属性赋值前阶段 populateBean 就是属性赋值阶段\n// AbstractAutowireCapableBeanFactory protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) { if (bw == null) { if (mbd.hasPropertyValues()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Cannot apply property values to null instance\u0026#34;); } // 老版本的 Spring 中，是有个 else{return;}的，不过是多此一举，下面的 esle 包裹到了方法结束 } else { boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() \u0026amp;\u0026amp; this.hasInstantiationAwareBeanPostProcessors()) { Iterator var5 = this.getBeanPostProcessors().iterator(); while(var5.hasNext()) { BeanPostProcessor bp = (BeanPostProcessor)var5.next(); // 这里就是 Bean 实例化前的操作，执行 postProcessAfterInstantiation 方法 if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp; // 返回值为是否继续填充 Bean if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { continueWithPropertyPopulation = false; break; } } } } //如果后处理器继续填充，则执行下面代码，原来这里是 if(!continueWithPropertyPopulation){return;} if (continueWithPropertyPopulation) { PropertyValues pvs = mbd.hasPropertyValues() ? mbd.getPropertyValues() : null; if (mbd.getResolvedAutowireMode() == 1 || mbd.getResolvedAutowireMode() == 2) { MutablePropertyValues newPvs = new MutablePropertyValues((PropertyValues)pvs); //这里以前是 == RootBeanDefinition.AUTOWIRE_BY_NAME，这种硬编码的方式，这就是魔法值了。要被 alibaba 编码规范插件检测出来的。 if (mbd.getResolvedAutowireMode() == 1) { //根据名称自动注入 this.autowireByName(beanName, mbd, bw, newPvs); } // 同上 if (mbd.getResolvedAutowireMode() == 2) { //根据类型自动注入 this.autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } boolean hasInstAwareBpps = this.hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = mbd.getDependencyCheck() != 0; PropertyDescriptor[] filteredPds = null; if (hasInstAwareBpps) { if (pvs == null) { pvs = mbd.getPropertyValues(); } Iterator var9 = this.getBeanPostProcessors().iterator(); while(var9.hasNext()) { BeanPostProcessor bp = (BeanPostProcessor)var9.next(); if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp; // 在赋值前阶段，会执行下面的 postProcessProperties 方法 PropertyValues pvsToUse = ibp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName); //如果这里为空，则执行下面的方法 if (pvsToUse == null) { if (filteredPds == null) { filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } pvsToUse = ibp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { return; } } pvs = pvsToUse; } } } if (needsDepCheck) { if (filteredPds == null) { filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } this.checkDependencies(beanName, mbd, filteredPds, (PropertyValues)pvs); } if (pvs != null) { this.applyPropertyValues(beanName, mbd, bw, (PropertyValues)pvs); } } } } Spring Bean Aware 接口回调阶段 按顺序执行\nBeanNameAware BeanClassLoaderAware BeanFactoryAware EnvironmentAware //这个和接下来是 applicationContext 执行的 EmbeddedValueResolverAware ResourceLoaderAware ApplicationEventPublisherAware MessageSourceAware ApplicationContextAware 在执行 populateBean 方法之后，执行\n// 3 private void invokeAwareMethods(String beanName, Object bean) { if (bean instanceof Aware) { if (bean instanceof BeanNameAware) { ((BeanNameAware)bean).setBeanName(beanName); } if (bean instanceof BeanClassLoaderAware) { ClassLoader bcl = this.getBeanClassLoader(); if (bcl != null) { ((BeanClassLoaderAware)bean).setBeanClassLoader(bcl); } } if (bean instanceof BeanFactoryAware) { ((BeanFactoryAware)bean).setBeanFactory(this); } } } // 2 protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) { if (System.getSecurityManager() != null) { AccessController.doPrivileged(() -\u0026gt; { this.invokeAwareMethods(beanName, bean); return null; }, this.getAccessControlContext()); } else { this.invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { wrappedBean = this.applyBeanPostProcessorsBeforeInitialization(bean, beanName); } try { this.invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable var6) { throw new BeanCreationException(mbd != null ? mbd.getResourceDescription() : null, beanName, \u0026#34;Invocation of init method failed\u0026#34;, var6); } if (mbd == null || !mbd.isSynthetic()) { wrappedBean = this.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean; } protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { instanceWrapper = this.createBeanInstance(beanName, mbd, args); } Object bean = instanceWrapper.getWrappedInstance(); Class\u0026lt;?\u0026gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } synchronized(mbd.postProcessingLock) { if (!mbd.postProcessed) { try { this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable var17) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Post-processing of merged bean definition failed\u0026#34;, var17); } mbd.postProcessed = true; } } boolean earlySingletonExposure = mbd.isSingleton() \u0026amp;\u0026amp; this.allowCircularReferences \u0026amp;\u0026amp; this.isSingletonCurrentlyInCreation(beanName); if (earlySingletonExposure) { if (this.logger.isTraceEnabled()) { this.logger.trace(\u0026#34;Eagerly caching bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39; to allow for resolving potential circular references\u0026#34;); } this.addSingletonFactory(beanName, () -\u0026gt; { return this.getEarlyBeanReference(beanName, mbd, bean); }); } Object exposedObject = bean; try { // 这里属性填入 this.populateBean(beanName, mbd, instanceWrapper); //这里执行 各种 aware exposedObject = this.initializeBean(beanName, exposedObject, mbd); } catch (Throwable var18) { if (var18 instanceof BeanCreationException \u0026amp;\u0026amp; beanName.equals(((BeanCreationException)var18).getBeanName())) { throw (BeanCreationException)var18; } throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Initialization of bean failed\u0026#34;, var18); } if (earlySingletonExposure) { Object earlySingletonReference = this.getSingleton(beanName, false); if (earlySingletonReference != null) { if (exposedObject == bean) { exposedObject = earlySingletonReference; } else if (!this.allowRawInjectionDespiteWrapping \u0026amp;\u0026amp; this.hasDependentBean(beanName)) { String[] dependentBeans = this.getDependentBeans(beanName); Set\u0026lt;String\u0026gt; actualDependentBeans = new LinkedHashSet(dependentBeans.length); String[] var12 = dependentBeans; int var13 = dependentBeans.length; for(int var14 = 0; var14 \u0026lt; var13; ++var14) { String dependentBean = var12[var14]; if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, \u0026#34;Bean with name \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39; has been injected into other beans [\u0026#34; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \u0026#34;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using \u0026#39;getBeanNamesOfType\u0026#39; with the \u0026#39;allowEagerInit\u0026#39; flag turned off, for example.\u0026#34;); } } } } try { this.registerDisposableBeanIfNecessary(beanName, bean, mbd); return exposedObject; } catch (BeanDefinitionValidationException var16) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \u0026#34;Invalid destruction signature\u0026#34;, var16); } } // 后面几个 Aware // 3 private void invokeAwareInterfaces(Object bean) { if (bean instanceof Aware) { if (bean instanceof EnvironmentAware) { ((EnvironmentAware)bean).setEnvironment(this.applicationContext.getEnvironment()); } if (bean instanceof EmbeddedValueResolverAware) { ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(this.embeddedValueResolver); } if (bean instanceof ResourceLoaderAware) { ((ResourceLoaderAware)bean).setResourceLoader(this.applicationContext); } if (bean instanceof ApplicationEventPublisherAware) { ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(this.applicationContext); } if (bean instanceof MessageSourceAware) { ((MessageSourceAware)bean).setMessageSource(this.applicationContext); } if (bean instanceof ApplicationContextAware) { ((ApplicationContextAware)bean).setApplicationContext(this.applicationContext); } } } //ApplicationContextAwareProcessor implements BeanPostProcessor //2 @Nullable public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { AccessControlContext acc = null; if (System.getSecurityManager() != null \u0026amp;\u0026amp; (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware || bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware || bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) { acc = this.applicationContext.getBeanFactory().getAccessControlContext(); } if (acc != null) { AccessController.doPrivileged(() -\u0026gt; { this.invokeAwareInterfaces(bean); return null; }, acc); } else { this.invokeAwareInterfaces(bean); } return bean; } //AbstractApplicationContext // 1 protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) { beanFactory.setBeanClassLoader(this.getClassLoader()); beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, this.getEnvironment())); //这一步 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); if (beanFactory.containsBean(\u0026#34;loadTimeWeaver\u0026#34;)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } if (!beanFactory.containsLocalBean(\u0026#34;environment\u0026#34;)) { beanFactory.registerSingleton(\u0026#34;environment\u0026#34;, this.getEnvironment()); } if (!beanFactory.containsLocalBean(\u0026#34;systemProperties\u0026#34;)) { beanFactory.registerSingleton(\u0026#34;systemProperties\u0026#34;, this.getEnvironment().getSystemProperties()); } if (!beanFactory.containsLocalBean(\u0026#34;systemEnvironment\u0026#34;)) { beanFactory.registerSingleton(\u0026#34;systemEnvironment\u0026#34;, this.getEnvironment().getSystemEnvironment()); } } Spring Bean 初始化前阶段 BeanPostProcessor#postProcessBeforeInitialization\nSpring Bean 初始化阶段 依次往下执行\n注解 @Postconstructor\n接口 InitializingBean\n元信息配置 @Bean（init-method=\u0026ldquo;init\u0026rdquo;)\nSpring Bean 初始化后阶段 BeanPostProcessor#postProcessAfterInitialization\nSpring Bean 初始化完成阶段 SmartInitializingSingleton#afterSingletonsInstantiated\n适合 ApplicationContext 中回调\nSpring Bean 销毁前阶段 DestructionAwareBeanPostProcessor#postProcessBeforeDestruction\nSpring Bean 销毁阶段 执行次序依次往下执行\n@PreDestroy 标注方法 实现 DisposableBean 接口的 destroy() 方法 自定义销毁方法 (destroy-mehod) Spring Bean 垃圾收集 Bean 垃圾回收（GC） 关闭 Spring 容器（应用上下文） 执行 GC Spring Bean 覆盖的 finalize() 方法被回调 Spring 事务 来源于 https://juejin.cn/post/6844903608224333838#heading-9\n人家是专门做面试方向的，可以关注公众号，支持一下 Java Guide，只是讲了最基本的 Java 面试题，还不错。\n事务的特性（ACID） 原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性： 执行事务前后，数据保持一致； 隔离性： 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的； 持久性: 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 Spring事务管理接口： PlatformTransactionManager： （平台）事务管理器 TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则) TransactionStatus： 事务运行状态 所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。\nPlatformTransactionManager接口介绍 Spring并不直接管理事务，而是提供了多种事务管理器 ，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 Spring事务管理器的接口是： org.springframework.transaction.PlatformTransactionManager ，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。\nPlatformTransactionManager接口 PlatformTransactionManager接口中定义了三个方法：\nPublic interface PlatformTransactionManager()...{ // Return a currently active transaction or create a new one, according to the specified propagation behavior（根据指定的传播行为，返回当前活动的事务或创建一个新事务。） TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; // Commit the given transaction, with regard to its status（使用事务目前的状态提交事务） void commit(TransactionStatus status) throws TransactionException; // Perform a rollback of the given transaction（对执行的事务进行回滚） void rollback(TransactionStatus status) throws TransactionException; } 复制代码 Spring中PlatformTransactionManager根据不同持久层框架所对应的接口实现类,几个比较常见的如下图所示\nTransactionDefinition接口介绍 事务管理器接口 PlatformTransactionManager 通过 getTransaction(TransactionDefinition definition) 方法来得到一个事务，这个方法里面的参数是 TransactionDefinition类 ，这个类就定义了一些基本的事务属性。\n那么什么是事务属性呢？\n事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面。\nTransactionDefinition接口中的方法如下： TransactionDefinition接口中定义了5个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等的常量。\n我下面只是列出了TransactionDefinition接口中的方法而没有给出接口中定义的常量，该接口中的常量信息会在后面依次介绍到。\npublic interface TransactionDefinition { // 返回事务的传播行为 int getPropagationBehavior(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据 int getIsolationLevel(); // 返回事务必须在多少秒内完成 //返回事务的名字 String getName()； int getTimeout(); // 返回是否优化为只读事务。 boolean isReadOnly(); } 事务隔离级别： 并发事务带来的问题 在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致一下的问题。\n脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。\n丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。\n例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。\n不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。\n幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n不可重复度和幻读区别：\n不可重复读的重点是修改，幻读的重点在于新增或者删除。\n例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。\n例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。\n隔离级别 TransactionDefinition 接口中定义了五个表示隔离级别的常量：\nTransactionDefinition.ISOLATION_DEFAULT:\t使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别. TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 事务传播行为（为了解决业务层方法之间互相调用的事务问题）： 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：\n支持当前事务的情况：\nTransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。 TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性） 不支持当前事务的情况：\nTransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。 其他情况：\nTransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。 这里需要指出的是，前面的六种事务传播行为是 Spring 从 EJB 中引入的，他们共享相同的概念。而 PROPAGATION_NESTED 是 Spring 所特有的。以 PROPAGATION_NESTED 启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。如果熟悉 JDBC 中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。\n事务超时属性(一个事务允许执行的最长时间) 所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。\n事务只读属性（对事物资源是否执行只读操作） 事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。在 TransactionDefinition 中以 boolean 类型来表示该事务是否只读。\n回滚规则（定义事务回滚规则） 这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。 但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。\nTransactionStatus接口介绍 TransactionStatus 接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息.\nPlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象。返回的TransactionStatus 对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事务）。\nTransactionStatus接口接口内容如下：\npublic interface TransactionStatus{ boolean isNewTransaction(); // 是否是新的事物 boolean hasSavepoint(); // 是否有恢复点 void setRollbackOnly(); // 设置为只回滚 boolean isRollbackOnly(); // 是否为只回滚 boolean isCompleted; // 是否已完成 } AOP原理 首先，这只能作用于方法层级上面，字段层级不行。Spring AOP 离开了 IoC 容器，就没有所谓的 AOP，具体的是在 Bean 实例化前，实现了 SmartInstantiationAwareBeanPostProcessor 的 AbstractAdvisorAutoProxyCreator 3个实现类来搞的。AnnotationAwareAspectJAutoProxyCreator、DefaultAdvisorAutoProxyCreator、InfrastructureAdvisorAutoProxyCreator。\nJava 的 Proxy 或者 CGLIB（ASM）动态代理，实现 AOP，做方法前后等增强。各种 Advisor 增强。\n前者是必须有接口，用实现同一个接口的生成类替换原来的类。后者是生成其子类，来增强原有类，所以 final 方法会被代理失效。\nhttps://juejin.im/post/5bf4fc84f265da611b57f906\nJDK动态代理和cglib的实现的区别 一个是接口，一个做它的子类，对原有类型进行提升\nJDK动态代理实现 Proxy.newInstance\nCGLIB 实现动态代理 本质上是实现一个子类，去提升该类的方法。所以不要将类或方法设置成 final 类型的，类设置了会报错，作为不了他的子类，方法设置成 final，只能 invoke 不能增强该方法 。\nimport org.springframework.cglib.proxy.Enhancer; import org.springframework.cglib.proxy.MethodInterceptor; public class CGLIBDemo { public static void main(String[] args) { Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(CGLIBDemo.class); enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -\u0026gt; { System.err.println(\u0026#34;Before invoke \u0026#34; + method); Object result = methodProxy.invokeSuper(o, objects); System.err.println(\u0026#34;After invoke\u0026#34; + method); return result; }); CGLIBDemo cglibDemo = (CGLIBDemo) enhancer.create(); cglibDemo.test(); System.out.println(cglibDemo); } public void test(){ System.out.println(\u0026#34;I\u0026#39;m test method\u0026#34;); } } Javassist 动态生成字节码 其实还是基于 ASM 来做的。\nLjava.lang.String\n这种，直接生成 class 文件，织入 [Ljava.lang.String 这种代码，来在虚拟机内部动态生成 class 文件。\nSpring 是如何解决循环依赖的 首先 prototype 不让循环依赖\n其次是构造器注入依赖，必须提供无参构造器，让 bean 能够实例化，如果没有，那也会报错。\n最终，Spring 会先实例化对象，将对象放入 earlySingletonObjects 中，如果循环依赖开始，优先查找 earlySingletonObjects。\npublic class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry { // 三级缓存 private final Map\u0026lt;String, Object\u0026gt; singletonObjects = new ConcurrentHashMap(256); private final Map\u0026lt;String, ObjectFactory\u0026lt;?\u0026gt;\u0026gt; singletonFactories = new HashMap(16); private final Map\u0026lt;String, Object\u0026gt; earlySingletonObjects = new HashMap(16); // 上面三个 map 解决循环依赖。如果是非单例模式，构造器注入，循环依赖无解，直接抛出异常。在 AbstractBeanFactory 中 private final Set\u0026lt;String\u0026gt; registeredSingletons = new LinkedHashSet(256); private final Set\u0026lt;String\u0026gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap(16)); private final Set\u0026lt;String\u0026gt; inCreationCheckExclusions = Collections.newSetFromMap(new ConcurrentHashMap(16)); @Nullable private Set\u0026lt;Exception\u0026gt; suppressedExceptions; private boolean singletonsCurrentlyInDestruction = false; private final Map\u0026lt;String, Object\u0026gt; disposableBeans = new LinkedHashMap(); private final Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; containedBeanMap = new ConcurrentHashMap(16); private final Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; dependentBeanMap = new ConcurrentHashMap(64); private final Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; dependenciesForBeanMap = new ConcurrentHashMap(64); public DefaultSingletonBeanRegistry() { } } 所有面试题\nhttps://blog.csdn.net/ThinkWon/article/details/104391081\nSpring MVC Spring MVC 具体请求执行过程 handlerMapping -\u0026gt; handler -\u0026gt;\n其实看 DispatherServlet#doService 方法就行了。所谓的图，不懂的人，还是看不懂的，看源代码就知道了。\n前置知识是 MethodHandler\nSpring Cloud Spring Cloud Netflix Spring Cloud Alibaba Spring Cloud Azure Spring Cloud Amazon Spring Cloud HUAWEI 其实 Spring Cloud Alibaba 开源，是为了更好的卖自家的云产品，例如 RocketMQ，大厂没有什么真正开源，就是为了钱罢了，用爱发电这种事，大家都比较难做。\nEureka/Nacos Spring Cloud 服务注册、服务发现几个抽象。\nDiscoveryClient、ServiceInstance\n租约机制。\nEureka 实现了 AP。任何 Server 都是主 Server，Server 与 Server 之间同步需要时间，可能会出现不一致的情况。Consistency\nNacos 实现了两种 AP，CP 模式，需要哪种可以指定。\nFeign/Dubbo 前者使用 HTTP 协议，更为通用，适合不是那么注重性能的场景或者需要跨语言的场景。\n虽然 Dubbo 协议也支持，但不是支持所有语言。\nHystrix/Sentinel（哨兵） Sentinel 除了熔断限流，还有分布式应用监控的功能\nGateway/Zuul RocketMQ 我选择 Confluent Kafka\n分布式服务配置中心 Apollo 挺好用，隔离机制，以及发布信息等做的挺好，就是要配置 MySQL，启动三个不同的 jar，内部实现是 Eureka + http long polling 长连接。\nSpring Cloud Config Nacos MyBatis MyBatis缓存机制 一级缓存 基于 PerpetualCache 的 HashMap 本地缓存， 其存储作用域为 Session， 当 Session flush 或 close 之后， 该 Session 中的所有 Cache 就 将清空， 默认打开一级缓存。\n二级缓存 与一级缓存其机制相同， 默认也是采用 PerpetualCache， HashMap 存储， 不同在于其存储作用域为 Mapper(Namespace)， 并且可自定义存储源， 如 Ehcache。 默认不打开二级缓存， 要开启二级缓存， 使用二级缓存属性类需要实 现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ， 对于缓存数据更新机制， 当某一个作用域(一级缓存 Session/二级缓存 Namespaces)的进行了 C/U/D 操作后， 默认该作用域下所有 select 中的缓存将被 clear 。\n就是跨 SqlSession 的缓存，生产上不建议开启。\n设计模式 简单工厂模式 定义 简单工厂模式又叫静态方法模式。\n补充：根据输入参数，或调用不同静态方法创建不同类型实例。\n示例代码 单例模式 定义 应用场景 注意事项\n对于初始化耗时的类来说，饿汉式单例更适合。 Spring 采用 Hash 散列表来实现单例，自己 new [SpringBean] 还是会创建不同对象。 示例代码 public class Singleton{ // 只有低版本的 Java 才会有指令重排问题，所以这里没加 volatile // 我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题，解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序 private static Singleton instance; private Singleton(){ // 防止反射创建两次实例 if(instance != null){ throw new IllegalAccessException(); } } public static Singleton getInstance(){ if(instance == null){ synchronized(Singleton.class){ if(instance == null){ instance = new Singleton(); } } } return instance; } } 构建器模式 定义 将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）。\n应用场景 https://time.geekbang.org/column/article/199674\n我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。\n如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。\n如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了\n示例代码 另外，MyBatis 也有 SqlSessionFactoryBuilder 来构建 SqlSessionFactory（虽然也可以用 Java Bean 的方式）。\npublic final class BeanDefinitionBuilder { private final AbstractBeanDefinition beanDefinition; private int constructorArgIndex; // 提供静态工厂方法，返回一般 BeanDefinitionBuilder public static BeanDefinitionBuilder genericBeanDefinition(String beanClassName) { BeanDefinitionBuilder builder = new BeanDefinitionBuilder(new GenericBeanDefinition()); builder.beanDefinition.setBeanClassName(beanClassName); return builder; } // 省略其他相同类型方法..... // init-method public BeanDefinitionBuilder setInitMethodName(@Nullable String methodName) { this.beanDefinition.setInitMethodName(methodName); return this; } // detroy-method public BeanDefinitionBuilder setDestroyMethodName(@Nullable String methodName) { this.beanDefinition.setDestroyMethodName(methodName); return this; } // scope defualt singleton public BeanDefinitionBuilder setScope(@Nullable String scope) { this.beanDefinition.setScope(scope); return this; } // 省略其他类型方法.... public AbstractBeanDefinition getBeanDefinition() { this.beanDefinition.validate(); return this.beanDefinition; } } //使用 public class BeanDefinitionAPI{ public GenericBeanDefinition getGeneriBeanDefinition(){ return (GenericBeanDefinition)BeanDefinitionBuilder .genericBeanDefinition(\u0026#34;org.springframework.web.client.RestTemplate\u0026#34;) .setScope(\u0026#34;singleton\u0026#34;) .getBeanDefinition(); } } 原型模式 代理模式 桥接模式 适配器模式 门面模式 组合模式 享元模式 迭代器模式 JDK 源码用到了哪些设计模式 https://blog.csdn.net/baiye_xing/article/details/76427717\nMySQL/Oracle 一条 SQL 的执行过程 来源于这个大佬的 https://www.processon.com/view/link/5f27c4e17d9c0835d3a35995\n词法解析 -\u0026gt; 如果开启了缓存（5.7后默认关闭），如果没有修改内容，则返回结果 -\u0026gt; 词法解析生成树 -\u0026gt; 调用 innodb -\u0026gt;\n事务隔离级别 读未提交 Read Uncommitted\n读已提交 Read Committed\n可重复读 Repeatable Read\n串行化 Serializable\n分别解决了事务执行的不同情况。\n这些是事务型数据库设计的基本概念\n通过 Explain 分析并优化 SQL 两年前使用 PL/SQL 对慢 SQL 的解释查询计划小优化。其实还有其他的 SQL 优化，没展示出来，项目后期帮其他组员重构优化代码和 SQL。\nhttps://yq.aliyun.com/articles/687976?spm=a2c4e.11155435.0.0.5f4633120ERia8\n还有 like \u0026lsquo;%xx%\u0026rsquo;， like \u0026lsquo;xx%\u0026rsquo;， like \u0026lsquo;%xx\u0026rsquo;\n我把其他组员的第一个改成了第二个，因为第二个能用到索引。这也是优化 SQL 的一个小技巧。\n具体原因，是因为根据 ASCII 比对的，比对成了就返回。有前缀索引内味了。\nBaiKalDB 百度开源的，基于 MySQL 以及 RocksDB 实现的分布式数据库。通过 Partition Region 的概念实现，理论上没有存储瓶颈。\n有点像 TiDB，也被人说是 C++ 版本的 TiDB。\n这个 RocksDB 也被用于 Pika 中，是一种高效的且大容量的 NoSQL 数据库。\nOceanBase 阿里开源的数据库。\nRedis Reids 6 个底层数据结构 简单动态字符串 SDS List 双向链表 ZipList 压缩列表 SkipList 跳表 HashMap 哈希表 整数数组 Redis 是一个主要由 Salvatore Sanfilippo（Antirez）开发的开源内粗数据结构存储器。因为其丰富的数据类型结构的值，可以被用作缓存、数据库、分布式锁和消息队列等1\nRedis 包含了 5 种的基本数据类型\nString\nHash\nList\nSet\nSortedSet\n和四个特殊的数据类型\nHyperLogLog BitMap GEO（地理坐标） Steam（流） 注意，这个 5 种的基本数据类型不代表它的具体实现。它的具体实现是根据值的大小，而不同的。下面有个图2，\n可以看出来，除了它的表面上的对应的实现，还有压缩列表这个数据结构(ZipList)，在它的值到达一定阈值时，会自动转换为其表面的实现。\n其实可以这么记，String 就是 Simple Dynamic String，Set 是哈希表和整数数组，List 、SortedList 和 Hash 在一定阈值后变成其对应实现。List -\u0026gt; 双向链表，Hash -\u0026gt; 哈希表，SortedSet -\u0026gt; 跳表.\n下面是 Redis 6.0.5 的 redis.conf 的配置及其注释**（可以跳过不看）。**\n############################### ADVANCED CONFIG ############################### # Hash 对应的 ZipList设置 ------------------------------- # Hashes are encoded using a memory efficient data structure when they have a # small number of entries, and the biggest entry does not exceed a given # threshold. These thresholds can be configured using the following directives. hash-max-ziplist-entries 512 hash-max-ziplist-value 64 # list 对应的 ZipList 设置 ------------------------------- # Lists are also encoded in a special way to save a lot of space. # The number of entries allowed per internal list node can be specified # as a fixed maximum size or a maximum number of elements. # For a fixed maximum size, use -5 through -1, meaning: # -5: max size: 64 Kb \u0026lt;-- not recommended for normal workloads # -4: max size: 32 Kb \u0026lt;-- not recommended # -3: max size: 16 Kb \u0026lt;-- probably not recommended # -2: max size: 8 Kb \u0026lt;-- good # -1: max size: 4 Kb \u0026lt;-- good # Positive numbers mean store up to _exactly_ that number of elements # per list node. # The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size), # but if your use case is unique, adjust the settings as necessary. list-max-ziplist-size -2 # set 最大值 ------------------------------- # Sets have a special encoding in just one case: when a set is composed # of just strings that happen to be integers in radix 10 in the range # of 64 bit signed integers. # The following configuration setting sets the limit in the size of the # set in order to use this special memory saving encoding. set-max-intset-entries 512 # zset 命令也就是 SortedList 最大的 ZipList 值 ------------------------------- # Similarly to hashes and lists, sorted sets are also specially encoded in # order to save a lot of space. This encoding is only used when the length and # elements of a sorted set are below the following limits: zset-max-ziplist-entries 128 zset-max-ziplist-value 64 下面我讲下对应的数据类型及其数据结构实现\nRedis 全局 Hash 表总览 为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。\n一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。\n哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。指针你懂我意思吧，就是个内存地址，并不是实际内容。这个其实就是 HashMap，讲这个，就顺便复习下 HashMap 的东西。*tips：这里的 key 其实是 c++ 里面的声明变量的方式。和 Java 里面的 String s 这种类似\nHashTable 问题 这里其实 Java 里面的本来应该常用哈希表（HashTable）的，这里的哈希表和 Java HashMap 实现是差不多的。后者是双向链表（过一定阈值）转红黑树。\n1. 哈希冲突 哈希冲突就是 12%6 = 0，24%6 = 0，或者两个不同的键算出了同样的哈希值。单单靠计算哈希值然后取模的方式，不同的键值肯定会存在一样的取模后的值。所以哈希表里面就会用往下加 。但是这个往下加也有个限度，它会一个个加，加到 10w 个，那就要往下找 10w 次，对本来是 O(1) 查找速度的数据结构肯定接受不了。在 Java 的 HashMap 中，如果单个链表长度过长，则会进行扩容，在其中进行 rehash 。\n2. rehash 为了解决那么多的节点可能出现在哈希表的一个下标下，那么就需要 rehash 来重新调整哈希表的大小，即数组大小。\n为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步[3]：\n给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍； 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中； 释放哈希表 1 的空间。 到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。\n这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了渐进式 rehash。\n**简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。**如下图所示：\n压缩列表 ZipList 介绍 压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。\n压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。\n在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。\n下面不是重点可以跳过\n属性 类型 长度 用途 zlbytes unit32_t 4字节 记录整个压缩列表占用的内存字节数；在对压缩列表进行内存重分配，或者计算 zlend 的位置时使用。 zltail unit32_t 4字节 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无需遍历压缩列表就可以确定表尾节点的地址。 zllen unit16_t 2字节 记录了压缩列表包含的节点数量：当这个属性的值小于 UINT16_MAX（65535）时，这个属性的值就是压缩力表包含节点的数量；等于时，节点的真实数量需要遍历整个压缩列表才能计算得出。（所以压缩列表节点数不宜过大） entryX 列表节点 不确定 压缩列表包含的各个节点，节点的长度由节点保存的内容决定 zlend unit8_t 1字节 特殊值 0xFF （十进制 255），用于标记和压缩列表的末端 下面是一个压缩列表的样例[4]\n列表zlbytes属性的值为0xd2（十进制210），表示压缩列表的总长为210字节。 列表zltail属性的值为0xb3（十进制179），这表示如果我们有一个指向压缩列表起始地址的指针p，那么只要用指针p加上偏移量179，就可以计算出表尾节点entry5的地址。 列表zllen属性的值为0x5（十进制5），表示压缩列表包含五个节点。 压缩列表节点数不宜过大！！！\n跳表 SkipList 跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位。\n跳跃表（SkipList）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。\n跳跃表支持平均 O（logN）、最坏 O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。\n在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。\n和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。\n下面是演示跳表找一个节点。以此类推，三级索引，N 级索引。当数据量很大时，跳表的查找复杂度就是 O(logN)。\n更为详细的跳表介绍（可以不看）\n还有，为什么选择跳表而不是平衡树，看这个解释（可以跳过不看）\n数据结构的时间复杂度 名称 时间复杂度 哈希表 O(1) 跳表 O(logN) 双向链表 O(N) 压缩列表 O(N) 整数列表 O(N) 不同操作的复杂度 不同操作的复杂度集合类型的操作类型很多，有读写单个集合元素的，例如 HGET、HSET，也有操作多个元素的，例如 SADD，还有对整个集合进行遍历操作的，例如 SMEMBERS。这么多操作，它们的复杂度也各不相同。而复杂度的高低又是我们选择集合类型的重要依据。\n**单元素操作，是指每一种集合类型对单个数据实现的增删改查操作。**例如，Hash 类型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。集合类型支持同时对多个元素进行增删改查，例如 Hash 类型的 HMGET 和 HMSET，Set 类型的 SADD 也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了。 范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据，比如 Hash 类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE。**这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。**Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。 统计操作，是指集合类型对集合中所有元素个数的记录，例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。 例外情况，是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。 参考 《Redis 使用手册》\n极客时间《Redis 核心技术实战》\nRedis单线程 所谓的单线程，其实是指 Redis 对读和写键值的时候是单线程操作（这里就会导致某个命令如果执行耗时过长，会导致 Redis 实例卡住），和传统的 Socket 单线程 accept 接收不同。Redis 采用了 select/epoll IO多路复用的方式，将所有到达的 TCP 请求，进行了汇总到事件队列中，然后由 Redis 主线程一条条执行命令。\n所谓单线程，是指网络 IO 和键值对读写是由一个线程来完成的。用于集群数据同步、持久化（save/bgsave）、异步删除都是由其他线程来完成的。\nRedis6 默认为关闭，需手动设置开启\n即使开启了多线程，Redis 对读和写键值的时候，还是单线程了，只不过是多线程接受消息。\nRedis 哨兵集群 一主多从，客观下线\n// TODO 判断过程\nRedis 分片 16384个哈希槽，CRC16\nCodis\n// TODO 分配哈希槽命令\nRedis 集群同步 一主多从，RDB 同步\nreplica buf，以及对应的 log\n// TODO 同步步骤\nRedis 源码优化 利用 taskset 将主线程进行绑核操作。\nlscpu 查看 cpu 是不是 numa 架构，来进行 CPU 绑核操作。华为的 OpenGuass 数据库也是利用了这个绑核操作，在数据库启动的时候就会自动绑核做极致优化。\nNetty ByteBuf 数据的容器，具体方法，里面有读指针和写指针等。\nInboundChannel 入站管道。\nChannelPipeline Netty Zero Copy 少了两步骤，调用的操作系统的复制方法。\n少了用户态的参与。\nhttps://zhuanlan.zhihu.com/p/78869158\nNetty 解决粘包 使用复杂的协议，进行拆包。\n数据结构 二叉树遍历 前序：根左右\n中序：左根右\n后序：左右根\n二叉树 public class Node{ Node left, right; int val; public Node(int val){ this.val = val;\t} } 前序遍历 public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new LinkedList(); LinkedList\u0026lt;TreeNode\u0026gt; stack = new LinkedList(); if(root == null){ return res; } stack.add(root); while(!stack.isEmpty()){ TreeNode node = stack.pollLast(); res.add(node.val); if(node.right != null){ stack.add(node.right); } if(node.left != null){ stack.add(node.left); } } return res; } 求二叉树最大深度 public int maxDepth(TreeNode root) { if (root == null) { return 0; } int leftHeight = maxDepth(root.left); int rightHeight = maxDepth(root.right); return Math.max(leftHeight, rightHeight) + 1; } 算法 冒泡排序 public void sort(int[] arr) { int size = arr.length; int i, j; //pos变量用来标记循环里最后一次交换的位置 int k = size - 1, pos = 0; //一共要排序size-1次 for (i = 0; i \u0026lt; size - 1; i++) { //每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换 int flag = 0; //选出该趟排序的最大值往后移动 for (j = 0; j \u0026lt; k; j++) { if (arr[j] \u0026gt; arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; //只要有发生了交换，flag就置为1 flag = 1; //循环里最后一次交换的位置 j赋给pos pos = j; } } k = pos; //判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return if (flag == 0) { return; } } } 演示动态图\n快速排序 二分搜索 插入排序 insert 归并排序 merge 选择排序 select LeetCode 刷题 滑动窗口寻找字符串 大型分布式网站架构 架构 单体 -\u0026gt; SOA -\u0026gt; 微服务 -\u0026gt; Serveless\n下一代架构，Serveless\n负载均衡策略 轮询（Round Robin） 随机 hash 取模 加权轮询（和轮询一样，只不过根据权重，重复的IP地址根据权重变成多份） 加权随机 最小连接数 动态选择连接数最小服务器 常见权限设计 ACL：Access-Control List，访问控制列表。 RBAC：Role-Based Access Control，基于角色的权限控制。 ABAC：Attribute-Based Access Control，基于属性的权限控制。 PBAC：Policy-Based Access Control，基于策略的权限控制。 ACL示例：MySQL，MongoDB，HBase 都是以 ACL 作为权限控制思想，MySQL 在赋予用户权限时，有个 acl_users 数组进行存储 all_user 信息（不仅在 mysql.user 这个表里加数据）。\nRBAC示例：常见的权限系统，在 人员 1\u0026lt;\u0026ndash;\u0026gt;n 角色 1\u0026lt;\u0026ndash;\u0026gt;n 权限。\nOAuth2 https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\n阮一峰大佬的云冲印的例子。\n其实现 Spring Security Oauth2\n如何设计海量数据的存储系统 参考 TiDB，或者 GFS 升级版 Colossus（套娃）。\nConsistent Hash 一致性哈希 基础：将 Hash 函数的值域空间组织成一个圆环，计算出对应的 key 的 hash 值在环上对应的区间。\n进阶：对每个节点进行计算多个 Hash 值，引入虚拟节点，虚拟节点映射到真实节点。\nhttps://www.infoq.cn/article/7cBOXVbB6B5V0BJh6Rfx\n缓存的实现原理，设计缓存要注意什么 https://juejin.im/post/5b849878e51d4538c77a974a\n进程内缓存Guava cache 、Ecache，也可以使用其提供的同步机制同步多个进程间缓存。\n// TODO《深入分布式缓存》\n操作系统的页式存储 https://www.tomorrow.wiki/archives/334\npage cache。最好不要改，redis 利用 page cache 做了优化，改大了影响性能。\n// TODO 详细解释 page cache\n分布式Session 可以将用户的 token 作为键值，使用 登陆 -\u0026gt; UUID -\u0026gt; token -\u0026gt; token为键，用户信息为值 ，将用户信息放入 Memcached/Redis集群之中。\n对用户 token/id 采用 Hash 取模的方式，将用户 session 强行绑定在固定机器上，就不用跨实例共享 session 了（也叫粘性 Session，缺点很明显，动态扩容，会导致大量 Session 失效）。\nHTTP 请求的过程与原理 DNS解析 TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束 TCP 连接的特点 TCP如何保证安全可靠的 ACK机制，三次握手，四次挥手\nUDP 基础知识 无连接协议即用户数据报协议（UDP），通常在性能至关重要并且能够容忍一定的数据包丢失的情况下。用户数据报协议（英语：User Datagram Protocol，缩写：UDP；又称用户数据包协议）是一个简单的面向数据报的通信协议，位于OSI模型的传输层。该协议由David P. Reed在1980年设计且在RFC 768中被规范。典型网络上的众多使用UDP协议的关键应用在一定程度上是相似的。\n在TCP/IP模型中，UDP为网络层以上和应用层以下提供了一个简单的接口。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验字段。\nUDP适用于不需要或在程序中执行错误检查和纠正的应用，它避免了协议栈中此类处理的开销。对时间有较高要求的应用程序通常使用UDP，因为丢弃数据包比等待或重传导致延迟更可取。\nUDP 的可靠性 由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。某些应用程序（如TFTP）可能会根据需要在应用程序层中添加基本的可靠性机制。[1]\n一些应用程序不太需要可靠性机制，甚至可能因为引入可靠性机制而降低性能，所以它们使用UDP这种缺乏可靠性的协议。流媒体，实时多人游戏和IP语音（VoIP）是经常使用UDP的应用程序。 在这些特定应用中，丢包通常不是重大问题。如果应用程序需要高度可靠性，则可以使用诸如TCP之类的协议。\n例如，在VoIP中延迟和抖动是主要问题。如果使用TCP，那么任何数据包丢失或错误都将导致抖动，因为TCP在请求及重传丢失数据时不向应用程序提供后续数据。如果使用UDP，那么应用程序则需要提供必要的握手，例如实时确认已收到的消息。\n由于UDP缺乏拥塞控制，所以需要基于网络的机制来减少因失控和高速UDP流量负荷而导致的拥塞崩溃效应。换句话说，因为UDP发送端无法检测拥塞，所以像使用包队列和丢弃技术的路由器之类的网络基础设备会被用于降低UDP过大流量。数据拥塞控制协议（DCCP）设计成通过在诸如流媒体类型的高速率UDP流中增加主机拥塞控制，来减小这个潜在的问题。\nUDP 应用 许多关键的互联网应用程序使用UDP[2]，包括：\n域名系统（DNS），其中查询阶段必须快速，并且只包含单个请求，后跟单个回复数据包； 动态主机配置协议（DHCP），用于动态分配IP地址； 简单网络管理协议（SNMP）； 路由信息协议（RIP）； 网络时间协议（NTP）。 流媒体、在线游戏流量通常使用UDP传输。 实时视频流和音频流应用程序旨在处理偶尔丢失、错误的数据包，因此只会发生质量轻微下降，而避免了重传数据包带来的高延迟。 由于TCP和UDP都在同一网络上运行，因此一些企业发现来自这些实时应用程序的UDP流量影响了使用TCP的应用程序的性能，例如销售、会计和数据库系统。 当TCP检测到数据包丢失时，它将限制其数据速率使用率。由于实时和业务应用程序对企业都很重要，因此一些人认为开发服务质量解决方案至关重要。[3]\n详情\nTCP 是面向连接的传输，管理了两个端点之间的连接的建立，在连接的生命周期内的有序和可靠的消息传输，以及最后，连接的有序终止。相比之下，在类似于 UDP 这样的无连接协议中，并没有持久化连接的概念，并且每个消息（一个 UDP 数据报）都是一个单独的传输单元。\nUDP 没有 TCP 的纠错机制，其中每个节点都将确认它们所接收到的包，而没有被确认的包会被发送方重新传输。\nUDP 广播 UDP 提供了向多个接收者发送消息的额外传输模式\n单播——发送消息给一个由唯一地址所标识的单一网络目的地。\n多播——传输到一个预定义的主机组。\n广播——传输到网络（或者子网）上的所有主机。\n服务稳定性 依赖管理 理清调用链路、流量控制、慢调用降级。\n优雅降级 为避免单个服务实例宕机导致服务雪崩，通常有集群管理或服务熔断机制，可以两个一起用。Dubbo 服务设置里面手动设置阈值。\n服务分级 对服务实例设置白名单机制，对不同服务进行分级处理，优先处理等级高的服务请求。我觉得可以把调用失败的请求，转到 mq 上，由一群专门用于处理调用失败请求的服务，进行定时执行从 mq 尝试拉取失败请求，进行重试。\n开关 如果服务消费者 A、B、C 都依赖服务提供者 D，如果前面做了服务分级，则可以在实例负载超过警戒水位线，进行关闭对低优先级的请求。\n应急预案 提前做好扩容方案。\nSentinel 都符合了这些要求（应急预案不含）。本质上都是舍车保帅，保证能用的服务不挂，保证优先级高的服务能用，提前准备应对方案。\n高并发系统设计 操作原子性 volatile，synchronized\n多线程同步 JUC\n数据一致性 强一致性\n要求无论数据的更新操作是在哪个副本上执行，之后所有的读操作都要能够获取到更新的最新数据。\n弱一致性\n系统的某个数据被更新后，后续对该数据的读取操作到的可能是更新前的值，也可能是更新后的值。全部用户完全读取到更新后的数据需要经过一段时间，这段时间称为“不一致性窗口”\n最终一致性\n最终一致性是弱一致性的特殊形式，这种情况下系统保证用户最终能够读取到某个操作对系统的更新，“不一致窗口”的时间依赖于网络的延迟、系统的负载和副本的个数。\n系统的可扩展性 通过简单加机器，简单的配置就能实现更高吞吐量，那这就是易扩展。\n并发减库存 https://time.geekbang.org/column/article/40743\n减库存一般有三种\n下单减库存 付款减库存 预扣减库存 下单减库存可以通过数据库事务控制，但是下了单不一定付款。\n付款减库存，如果并发比较高，可能出现买家下单后付不了款的情况，因为商品已经被其他人买走了。\n预扣库存，买家下单后，库存为其保留一定时间（如10分钟），超过这个时间，库存将会自动释放，释放后其他买家可以继续购买（有点锁的味道）。在买家付款前，系统会校验订单的库存是否还有保留，如果没有保留，则再次尝试预扣；如果库存不足（预扣失败），则不允许继续付款，如果预扣成功，则完成付款并实际地去减库存。\n对商品剩余数量的查询，可以使用缓存 Ecache/Guava Cache 进行本地缓存返回。\n**应用层做排队。**按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。\n数据库层做排队。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。\n性能优化措施 前端性能优化 页面的 HTTP 请求数量（尽量减少请求数量，像QQ音乐网页版就是反例，大量无用的 debug 请求） 是否使用 CDN 网络（静态资源上 CDN） 是否使用压缩 Java 程序优化 合理使用单例模式。提升对象复用性，减少内存开销 Future 模式（FutureTask，异步执行任务） 线程池（避免对象频繁创建、销毁，使用池化思想，在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用） 选择就绪（使用 NIO） 减少上下文切换 （2 * cpu核心数 * cpu核数 + 1，IO 密集型这么做，计算密集型 cpu 核心数+1） 降低锁竞争（1. 合理减少 synchronized 域的范围，2. 减小锁的粒度 3.使用读写锁比使用独占锁提供更高的并发量 ） 压缩 HTTP Header gzip\n结果缓存 从数据库开始使用缓存（不建议） -\u0026gt; 不建议使用 MyBatis 的二级缓存，进程内缓存 Guava cache，Ecache -\u0026gt; 跨进程缓存 （Redis ，对值结构；要求复杂点的系统不推荐Memcached）-\u0026gt; 静态资源缓存（CDN）\n数据库查询性能优化 合理使用索引（explain，解释计划查询，对特定业务进行建立索引进行查询优化）例子 oracle 是 explain plan for 反范式设计（适当冗余字段，尽量避免多表操作） 使用查询缓存（不推荐，5.7 之后默认关闭，8.0 不准开，使用起来很多坑） 使用搜索引擎（Elasticsearch 加速 Like 查询以及很多复杂的查询） 使用 Key-Value 数据库（HBase， TDH 的 HyperBase，通过设计合理的 RowKey 加速查询） GC 优化 分析 dump 日志，合理设置启动参数，Xms 设置为机器内存的 65% - 70%。\n硬件性能提升 其实硬件性能提升是所有优化里面，能最简单，最大的优化。生产上都是 Nginx + F5 来提升单体应用。\nJava 应用 CPU 使用率飙升故障排查 // TODO 把 19 年如何解决 CPU 使用率飙升的命令写出来\n工具 Arthas\n数据分析 使用Hadoop 进行数据分析。\nStorm 是 2011 年 Twitter 开源的一个实时的分布式流式处理系统，有点类似于 Hadoop 提供的大数据解决方案，但是它要处理的对象是没有终点的数据流（也叫无界数据流），而非 Hadoop 的 MapReduce 那样的批处理系统。\n日志收集系统 Chukwa 离线数据分析 数据同步 过程往往是从 OLTP 库中，以及日志系统中，提取和清洗（数据清洗可以用 Kafka Stream）所需要的数据到 OLAP 系统（所在的银行当前系统就是这样的）。构建在 hive 平台，然后在 OLAP 系统上进行多维度复杂的数据分析和汇总操作，利用这些数据构建数据报表，进行前端展示。我们做的是每天全量同步。使用的 Sqoop，没用 DataX 。\n离线同步（全量同步） 使用 sqoop\n实时同步（增量同步） 使用 MySQL 主从机制，通过伪装成从库进行 binlog \u0026mdash;\u0026gt; Kafka （任意 MQ） \u0026mdash;\u0026gt; 其他库\n算是备忘录模式的体现，全量和增量。\nZookeeper Zookeeper 介绍 Zookeeper 是一个开源的分布式协调服务软件，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步操作。最终，将简单易用的接口和性能高效，功能稳定的系统提供给用户。\n分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。\nZookeeper 保证了分布式一致性特性：\n顺序一致性 原子性 单一视图 可靠性 实时性（最终一致性） Zookeeper 提供了什么？ 文件系统 通知机制 Zookeeper 文件系统 Zookeeper 提供了一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状目录结构，这种特性使得 Zookeeper不能用于存放大的数据，每个节点的存放数据上限为 1M。\nZAB 协议 ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。\nZAB协议包括两种基本的模式：崩溃恢复和消息广播。\n当整个Zookeeper集群刚刚启动或者 Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与Leader服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式，首先选举产生新的Leader服务器，然后集群中Follower服务器开始与新的Leader服务器进行数据同步，当集群中超过半数及其与该 Leader服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader服务器开始接收客户端的事务请求生成事务提案进行事务请求处理。\n四种类型的数据节点 Znode PERSISTENT：持久节点，除非手动删除，否则节点一直存在于Zookeeper上\nEPHEMERAL：临时节点 临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与Zookeeper连接断开不宜一定会话失效），那么这个客户端创建的所有临时节点都会被移除。Kafka集群就是基于临时节点。\nPERSISTENT_SEQUENTIAL：持久顺序节点 基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字\nEPHEMERAL_SEQUENTIAL：临时顺序节点 基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由副节点维护的自增整型数字。\nZooKeeper Wather 机制 \u0026ndash; 数据变更通知 Zookeeper允许客户端向服务端的某个Znode注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据Watcher通知状态和事件类型做出业务上的改变。\n工作机制：\n客户端注册watcher\n服务端处理watcher\n客户端回调watcher\nWatcher特性总结：\n一次性\n无论是服务端还是客户端，一旦一个Watcher被触发，Zookeeper都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。\n客户端串行执行\n客户端Watcher回调的过程是一个串行同步的过程。\n轻量\nWatcher通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。\n客户端向服务端注册Watcher的时候，并不会把客户端真实的Watcher对象实体传递到服务端，仅仅是在客户端请求中使用boolean类型属性进行了标记。\nwatcher event异步发送watcher的通知事件从server发送到client是异步的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于Zookeeper本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化。所以我们使用Zookeeper不能期望能够监控到节点每次的变化。Zookeeper只能保证最终的一致性，而无法保证强一致性。\n注册watcher getData、exists、getChildren\n触发watcher create、delete、setData\n当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。\nKafka Kafka 各个名词概述 Topic\nBroker\nPartition\nProducer\nConsumer\nLeader Replica\nFollower Replica\nRebalance\nConsumer Offset\nConsumer Group\nCordinator\nCotroller\nInterceptor\nRecord Kafka 处理的主要对象。\nTopic 主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。\nProducer 向主题发布消息的客户端应用程序。\nConsumer 订阅这些主题消息的客户端应用程序就被称为消费者。\nConsumer Group 指的是多个消费者实例共同组成一个组来消费一个主题。该组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它。消费者组提升了消费者端的吞吐量。\nBroker 一个 Kafka 集群由一个至多个 Broker 组成，Broker 负责接收和处理客户端发送过来的请求，以及对消息进行持久化。\nReplication 备份机制\nLeader Replica 领导者副本，对外提供服务。\nFollower Replica 追随者副本，不对外提供服务，不能与外界进行交互。对 Leader 副本同步有延迟。\nCordinator 协调者\nController 控制器 Partition 比如 MongoDB 和 Elasticsearch 中的 Sharding、HBase 中的 Region，其实它们都是相同的原理，只是 Partitioning 是最标准的名称。\n生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。如你所见，Kafka 的分区编号是从 0 开始的，如果 Topic 有 100 个分区，那么它们的分区号就是从 0 到 99。\n一个有序不变的消息队列，每个主题下可以有多个分区。\n副本和分区的关系 副本是在分区这个层级定义的，每个分区下可以配置若干个副本，其中只能有一个领导者副本和 N-1 个追随者副本。生产者向分区写入消息，每条消息在分区中的位置信息有Offset 的数据来表征。分区的位移总是从 0 开始。\nRebalance 消费者组里面的所有消费者实例不仅“瓜分”订阅主题的数据，它们还能彼此协助，假如组内的某个实例挂掉了，Kafka 能够自动检测到，然后把这个 Faild 实例之前负责的分区转移给其他或者消费者。这就是 Rebalance，这个有很多 Bug。\nConsumer Offset 每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上。\nBroker注册 Broker是分布式部署并且相互之间相互独立，但是需要有一个注册系统能够将整个集群中的 Broker 管理起来，此时就使用到了Zookeeper。在 Zookeeper 上会有一个专门用来进行Broker服务器列表记录的节点：\n/brokers/ids\n每个Broker在启动时，都会到Zookeeper上进行注册，即到/brokers/ids下创建属于自己的节点，如/brokers/ids/[0\u0026hellip;N]。\nKafka使用了全局唯一的数字来指代每个Broker服务器，不同的Broker必须使用不同的Broker ID进行注册，创建完节点后，每个Broker就会将自己的IP地址和端口信息记录到该节点中去。其中，Broker创建的节点类型是临时节点，一旦Broker宕机，则对应的临时节点也会被自动删除。\nKafka ACK 机制 1 leader\n0 不管\n-1 所有\nKafka Zero Copy 和大家的零拷贝技术一样，少了用户态的参与。\nKafka 副本机制 只有 Leader 副本才供外界读写，Follower 副本只是作为冗余，怕 Leader 副本 down 掉数据全部丢失。 Follower 副本定期向 Leader 拉取数据。\nKafka 跨机房同步数据 Kafka 消息压缩 Kafka 默认不使用压缩，合理使用压缩，可以减少带宽使用。\nGZIP、Snappy 、LZ4、Zstandard 算法（简写为 zstd）\n在 Producer 端和 Broker 端设置相同（或者 Broker 端不改 compression.type 参数，默认为 producer 端的压缩方法）。\n在吞吐量方面：LZ4 \u0026gt; Snappy \u0026gt; zstd 和 GZIP；\n而在压缩比方面，zstd \u0026gt; LZ4 \u0026gt; GZIP \u0026gt; Snappy。\nKafka 高水位 高水位的作用在 Kafka 中，高水位的作用主要有 2 个。\n定义消息可见性，即用来标识分区下的哪些消息是可以被消费者消费的。 帮助 Kafka 完成副本同步。 它依靠一个名为 LSO（Log Stable Offset）的位移值来判断事务型消费者的可见性。\n与 Leader 副本保持同步。判断的条件有两个。\n该远程 Follower 副本在 ISR 中。 该远程 Follower 副本 LEO 值落后于 Leader 副本 LEO 值的时间，不超过 Broker 端参数 replica.lag.time.max.ms 的值。如果使用默认值的话，就是不超过 10 秒。 Leader Epoch\nEpoch。一个单调增加的版本号。每当副本领导权发生变更时，都会增加该版本号。小版本号的 Leader 被认为是过期 Leader，不能再行使 Leader 权力。 起始位移（Start Offset）。Leader 副本在该 Epoch 值上写入的首条消息的位移。 为什么 Kafka 的 Consumer 采用 pull 方式，Provider 采用 push 方式 消费者消费消息是需要一定时间的，为了防止推送过多消息给 Consumer 端，导致 Consumer 挂掉，让 Consumer 按需来自己 pull 消息。\nLucene Lucene全文搜索的原理 https://blog.csdn.net/yangqian201175/article/details/51462413\n《Lucene in action》\nELK Elasticsearch 简介 primary shard， replica shard，cordinating\nElasticsearch 聚合操作 Aggregation\nElasticsearch DLS Query TermLevel\nElasticsearch 查询 支持多种类型查询，返回对应 score\nLogstash docker pull docker.elastic.co/logstash/logstash:7.1.0\nKibana 中文环境设置 I18N_LOCALE=zh-CN\nBigData HDFS Hadoop 分布式文件系统。NameNode + DataNode，NameNode 只存 metadata，实际文件存在各个 DataNode。\n是的，它只是个文件系统，虽然一切皆文件。\nMapReduce MapReduce 是一种处理海量数据的并行编程模型和计算框架，用于对大规模数据集进行并行计算。\nMapReduce 一个任务的运行需要由 JobTracker 和 TaskTracker 两类空志节点的配合来完成，JobTracker 将 Mappers 和 Reducers 分配给空闲的 TaskTracker 后，有TaskTracker 来执行这些任务。MapReduce 框架尽量在那些存储数据的节点（如 DataNode）上来执行计算任务，采用移动计算而非移动数据的思想，减少数据在网络中传输，以此来提高计算效率。同时 JobTracker 也负责任务的容错管理，如果某个 TaskTracker 发生故障，JobTracker 会重新进行任务调度。\nHive 将 SQL 解释成 MapReduce 任务。\nHive是早期将高级查询语言SQL引入Hadoop平台的引擎之一，早期的Hive服务器进程被称作Hiveserver1；Hiveserver1既不支持处理并行的多个连接，又不支持访问授权控制；后来这两个问题在Hiveserver2上被解决，Hiveserver2能够使用grant/revoke语句来限制用户对数据库、表、视图的访问权限，行列权限的控制是通过生成视图来实现的；但Hiveserver2的授权管理体系被认为存在问题，那就是任何通过认证登陆的用户都能够为自己增加对任何资源的访问权限。也就是说Hiveserver2提供的不是一种安全的授权体系，Hiveserver2的授权体系是为防止正常用户误操作而提供保障机制；不是为保护敏感数据的安全性而设计的。然而这些更多的是某些公司的说辞，事实上Hiveserver2自身的安全体系也在逐步完善，上述问题也在快速修复中。\n连接 从 Hive 连接中可以看出用的是 Hiveserver2\nbeeline -u jdbc:hive2://olap1:10000/ \u0026ndash;maxWidth=1000\n数据仓库 从 WEB 开发到离线数仓，一个用多中间件 CRUD 开发，到另一个用 SQL 开发。换个地方 CRUD 而已\nUDF，UDAF，UDTF。脱敏函数（UDF），聚合函数（UDAF 自定义count，sum），UDTF\nUDF 一进一出，实现 UDF 接口，编写evaluate方法，例如可用作脱敏函数，对数据进行脱敏。\nclass SimpleUDFExample extends UDF{ public Text evaluate(Text input){ return new Text(\u0026#34;Hello \u0026#34; + input.toString()); } } UDAF 多进一出，实现 AbstractGenericUDAFResolver，可用作实现自定义聚合函数。下面是求两个列的线性方程的相关系数。\n看另一篇文章。\nHBase HBase是一个高可靠、高性能、面向列、可伸缩的分布式数据库，是谷歌 BigTable 的开源实现，主要用来存储非结构化和半结构化的松散数据，运行在 HDFS 之上。设计 RowKey 尽量将数据均地分布在各个 Region 上，并且 RowKey 为等长，用于拼接 RowKey 的列必须是确定长度的值，高频词往前提，同样查询频率的，辨识度高，更短的列往前提。等长是因为桶排序。\n没有特殊要求，一个列族就可以满足大部分要求，多个列族会影响性能，实际生产中，都是一个列族，多个列族会有问题，具体的看《HBase 原理与实战》这本书。\n拼接 Rowkey 是按照特定需求来做的，不能乱拼。\nHyperBase 星环增强了 HBase 变成了 HyperBase。查询更方便，千亿数据，查询秒返回。支持普通单表查询，多表查询慢，聚合操作更慢。聚合操作使用以下部件实现。支持更为丰富的值类型，例如 JSON 存储。\n不过还是只是支持 PB 级别数据罢了，再大就不太行了。\nKylin 聚合操作。\nSpark Spark SQL 也可以将 SQL 转换成 MR 任务，星环的 Inceptor 就整合了 Spark。Hive-on-spark，将 Hive 的 MR 任务转换成 Spark 的 job。\nFlink 流式处理中间件。还是写 SQL。\n符合事件驱动架构设计。\nKafka Streaming 也可以，但前者大公司都在用。做个 CRUD boy 他不香吗？\nCDH TDH Cloudera Data Hub，Transwarp Data Hub 一站式大数据平台\nTranswarp Data Hub 对标的国外的 CDH，其实也用到了 CDH 开源的代码，我看到安装包里面有 CDH 的东西，并且他们封装的 Elasticsearch Transport 的 SDK，打包有问题。\nOLAP Online analytical processing 联机分析处理\nOLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。\nOLAP由三个基本的分析操作组成：上卷（roll-up）、钻取（drill-down）、切片（slicing）和切块（dicing）。上卷涉及可以在一个或多个维度中累积和计算的数据的聚合。例如，所有的销售办事处汇总到销售部门，以预测销售趋势。相比之下，钻取是一种允许用户浏览详细信息的技术。例如，用户可以查看组成一个地区销售额的单个产品的销售额。切片和切块是说，用户可以从OLAP多维数据集中取出（切片）一组特定的数据，并从不同的角度查看（切块）切片\nhttps://zh.wikipedia.org/wiki/%E7%B7%9A%E4%B8%8A%E5%88%86%E6%9E%90%E8%99%95%E7%90%86\nOLTP 联机事务处理（OLTP, Online transaction processing）是指透过信息系统、电脑网络及数据库，以在线交易的方式处理一般即时性的作业资料，和更早期传统数据库系统大量批量的作业方式并不相同。OLTP通常被运用于自动化的资料处理工作，如订单输入、金融业务…等反复性的日常性交易活动。 和其相对的是属于决策分析层次的联机分析处理（OLAP）。\n来自\nJ2EE 规范 JMS 下面的来自oracle 官方文档\n《大型分布式网站架构·设计与实践》中只是一笔带过一些概念，没有 JMS 实际代码，然后用 ActiveMQ \u0026amp; JMS 的标题。\n定义 Java Message Service 是一组 Java 应用程序接口，它提供消息的创建、发送、接收、读取等一系列的服务。\n{% hideToggle 原文 %}\nThe Java Message Service is a Java API that allows applications to create‚ send‚ receive‚ and read messages\n{% endhideToggle %}\nJMS 定义了一组公共应用程序接口和相应的语法，是一种通用的 API。\n{% hideToggle 原文 %}\nthe JMS API defines a common set of interfaces and associated semantics that allow programs written in the Java programming language to communicate with other messaging implementations\n{% endhideToggle %}\n它定义了五种消息类型，如下。\n{% hideToggle 原文 %}\nThe JMS API defines five message body formats‚ also called message types‚ which allow you to send and receive data in many different forms and which provide compatibility with existing messaging formats.\n{% endhideToggle %}\nMessage Type Body Contains TextMessage A java.lang.String object (for example, the contents of an XML file). MapMessage A set of name-value pairs, with names as String objects and values as primitive types in the Java programming language. The entries can be accessed sequentially by enumerator or randomly by name. The order of the entries is undefined. BytesMessage A stream of uninterpreted bytes. This message type is for literally encoding a body to match an existing message format. StreamMessage A stream of primitive values in the Java programming language, filled and read sequentially. ObjectMessage A Serializable object in the Java programming language. Message Nothing. Composed of header fields and properties only. This message type is useful when a message body is not required. JDBC 1.0 规范 Connection\nStatement\nResultSet\nDriverManager.getDriver(url);\n2.0 规范 数据源\nDataSource\t这个接口是在JDBC 2.0规范可选包中引入的API。它比DriverManager更受欢迎，因为它提供了更多底层数据源相关的细节，而且对应用来说，不需要关注JDBC驱动的实现。JDBC API中只提供了DataSource接口，没有提供DataSource的具体实现，DataSource具体的实现由JDBC驱动程序提供。主流的数据库连接池也提供了其实现，如 Druid，c3p0，Hikaricp CommonDataSource 连接池相关\nConectionPoolDataSource 支持缓存和复用Connection对象，这样能够在很大程度上提升应用性能和伸缩性。 PooledConnection ConnectionEvent ConnectionEventListener ResultSet 扩展\nRowSet 继承自java.sql包下的ResultSet接口，相较于java.sql.ResultSet而言，RowSet的离线操作能够有效地利用计算机越来越充足的内存减轻数据库服务器的负担。由于数据操作都是在内存中进行的，然后批量提交到数据源，因此灵活性和性能都有了很大的提高。RowSet默认是一个可滚动、可更新、可序列化的结果集，而且它作为一个JavaBean组件，可以方便地在网络间传输，用于两端的数据同步。通俗来讲，RowSet就相当于数据库表数据在应用程序内存中的映射，我们所有的操作都可以直接与RowSet对象交互。RowSet与数据库之间的数据同步，作为开发人员不需要关注。 RowSetEvent RowSetInternal RowSetListener RowSetMetaData RowSetReader RowSetWriter 分布式扩展\nXAConnection XADataSource 该实例返回的Connection对象能够支持分布式事务。 上面三个都是接口。\n需要掌握的 API java.sql.Wrapper\njava.sql.Connection\njava.sql.Statement\njava.sql.PrepareStatement\njava.sql.CallableStatement\njava.sql.DatabaseMetaData\njava.sql.ParameterMetaData\njava.sql.ResultSet\njava.sql.ResultSetMetaData\n这些接口都继承了java.sql.Wrapper接口，里面有两个方法\n/** * unwrap()方法用于返回未经过包装的JDBC驱动原始类型实例，可以通过该实例调用JDBC驱动中提供的非标准的方法。 */ \u0026lt;T\u0026gt; T unwrap(java.lang.Class\u0026lt;T\u0026gt; iface) throws java.sql.SQLException; /** * 用于判断当前实例是否是JDBC驱动中某一类型的包装类型 */ boolean isWrapperFor(java.lang.Class\u0026lt;?\u0026gt; iface) throws java.sql.SQLException; JNDI JNDI（Java Naming and Directory Interface，Java命名和目录接口）为应用程序提供了一种通过网络访问远程服务的方式。\nRMI Servlet servlet-class mapping load-up\nJTA(Java Transaction Architecture) JTA定义了一种标准的API，应用系统由此可以访问各种事务监控。\nJTS(Java Transaction Service) 参考 https://www.ibm.com/developerworks/cn/java/j2ee/\nCloud Native 云原生 云原生十二要素 十二要素程序的核心思想\n使用声明的方式来搭建自动化环境，最大限度地减少新加入项目的开发人员的时间和成本。 与底层操作系统之间建立清晰的约定，在执行环境之间提供最大的可移植性。 适合部署在现代的云平台上，无须提供服务器和系统管理工具。 最大程度减少开发环境与生产环境之间的区别，通过持续部署获得最大的灵活性。 可以在不对工具、架构或开发实践带来重大变动的前提下，进行水平扩展。 十二要素程序的实践\n代码库 一份版本控制下的基准代码库，多份部署 依赖 显示声明和隔离依赖关系 配置 在环境中存储配置 后端服务 把后端服务当作附加资源 构建、发布、运行 严格分离构建和运行阶段 进程 将应用程序作为一个或多个无状态进程执行 端口绑定 通过端口绑定暴露服务 并发 通过进程模型进行扩展 易处理 通过快速启动和正常关机来最大限度地提高健壮性 开发/生产环境一致 尽可能保持开发、预发布和生产环境的配置一致 日志 将日志视为事件流 管理进程 将管理任务作为一次性进程运行 Cloud Foundry Pivotal 团队 12 年发布的云原生平台，完美实现了云原生的十二要素。Cloud Foundry 创始人之一，Chris Richardson，也是 《微服务架构设计模式》的作者。你想要了解微服务，这本书大量图解，帮你了解。\nAmazon S3 容器化 Docker 构建 Dockerfile，参考我的 evaluation 库\ndocker build docker run docekr ps docker kill docker compose up docker images docker rm Kubernetes （K8s，K3s） 简介 Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。\nK3s 国产的轻量级的 K8s。 用树莓派搭建 K3s\nKubernetes 是一个 Docker 编排框架。Docker 编排框架将运行 Docker 的一组计算机视为资源池。你只需要告诉 Docker 编排框架运行你的服务的 N 个实例，它就会自动把其余的事情搞定。\n有三个主要功能：\n资源管理：将一组计算机视为由 CPU、内存和存储卷构成的资源池，将计算机集群视为一台计算机。 调度：选择要运行容器的机器。默认情况下，调度考虑容器的资源需要和每个节点的可用资源。它还可以实现在同一节点上部署具有亲和性（affinity）的容器，或确保特定的几个容器分散部署在不同的节点之上（反亲和性，anti-affinity） 服务管理：实现命名和版本化服务的概念，这个概念可以直接映射到微服务架构中的具体服务。编排框架确保始终运行所需数量的正常实例。它实现请求的负载均衡。编排框架也可以执行服务的滚动升级，并允许你会滚到旧版本。 Kubenetes 的架构 Kubernetes 在一组机器上运行。下图显示了 Kubernetes 集群的架构。Kubernetes 集群中的计算机角色分为主节点和普通节点（也称为节点）集群通常只有很少的几个主节点（可能只有一个）和很多普通节点。主节点负责管理集群。Kubernetes 的普通节点称为 “工作节点”，它会运行一个或多个 Pod。Pod 是 Kubernetes 的部署单元，由一组容器组成。\nAPI 服务器：用于部署和管理服务的 REST API，例如，可被 kubectl 命令行使用。 Etcd：存储集群数据键值的 NoSQL 数据库。 调度器：选择要运行的 Pod 的节点。 控制器管理器：运行控制器，确保集群状态与预期状态匹配。例如，一种被称为复制（replication）控制器的控制通过启动和终止实例来确保运行所需数量的服务实例。 Kubenetes 集群由管理集群的主节点和运行服务的普通节点组成。开发人员和部署流水线通过 API 服务器与 Kubernetes 交互，API 服务器与主节点上运行的其他集群管理软件一起运行。应用程序容器在节点上运行，每个节点运行一个 Kubelet （它管理应用程序容器），以及一个 Kube-proxy （它将应用程序请求路由到 Pod），可以直接使用代理，也可以通过配置 Linux 内核中内置的 iptable 路由规则间接地完成路由工作。\n普通节点运行多个组件，包括以下内容：\nKubelet ： 创建和管理节点上运行的 Pod。 Kube-proxy：管理网络，包括跨 pod 的负载均衡。 Pods：应用程序服务。 Kubernetes 的关键概念 Pod：Pod 的 Kubernetes 的基本部署单元。它由一个或多个共享 IP 地址和存储卷的容器组成。服务实例的 pod 通常由单个容器组成，例如运行 JVM 的容器。但在某些情况下，Pod 包含一个或多个实现支持功能的边车（sidecar）容器。例如，Nginx 服务器可以有一个边车容器，定期执行 git pull 以下载最新版本的网站。Pod 的生命周期很短，因为 Pod 的容器或它运行的节点可能会崩溃。 Deployment：Pod 的声明规范。Deployment 是一个控制器，可确保始终运行所需数量的 Pod 实例（服务实例）。它通过滚动升级和会滚来支持版本控制。每个服务都是 Kubernetes 的一个 Deployment。 Servcie：向应用程序服务的客户端提供的一个静态/稳定的网络地址。它是基础设施提供的服务发现一种形式。每个 Service 具有一个 IP 地址和一个可解析位该 IP 地址的 DNS 名称，并跨一个或多个 Pod 对 TCP 和 UDP 流量进行负载均衡处理。IP 地址和 DNS 名称只能在 Kubernetes 内部访问。也可以配置可从集群外部访问的服务。 ConfigMap：名称与值对的命名集合，用于定义一个或多个应用程序服务的外部化配置。Pod 容器的定义可以饮用 ConfigMap 来定义容器的环境变量。它还可以使用 ConfigMap 在容器内创建配置文件。可以使用 Secret 来存储敏感信息（如密码），它也是 ConfigMap 的一种形式。 在 Kubernetes 上部署 Restaurant Service 定义一个部署（Deployment）对象。最简单的方法是编写 YAML 文件。\napiVersion: extensions/v1beta1 kind: Deployment metadata: name: ftgo-restaurant-service spec: # Pod 副本的数量 replicas: 2 template: metadata: labels: app: ftgo-restaurant-service spec: containers: - name: ftgo-restaurant-service image: msapatterns/ftgo-restaurant-service:lastes imagePullPolicy: Always ports: - containerPort: 8080 nanme: httpport env: - name: JAVA_OPTS value: \u0026#34;-Dsun.net.inetaddr.ttl=30\u0026#34; - name: SPRING_DATASOURCE_URL value: jdbc:mysql://ftgo-mysql/eventuate - name: SPRING_DATASOURCE_USERNAME valueFrom: secretKeyRef: name: ftgo-db-secret key: username - name: SPRING_DATASOURCE_PASSWORD valueFrom: secretKeyRef: name: ftgo-db-secret key: password - name: SPRING_DATASOURCE_DRIVER_CLASS_NAME value: com.mysql.jdbc.Driver - name: EVENTUATELOCAL_KAFKA_BOOTSTRAP_SERVERS value: ftgo-kafka:9092 - name: EVENTUATELOCAL_KAFKA_ZOOKEEPER_CONNECTION_STRING value: ftgo-zookeeper:2181 livenessProbe: httpGet: path: /actuator/health port: 8080 initialDelySeconds: 60 periodSeconds: 20 readinessProbe: httpGet: path: /actuator/health port: 8080 initialDelaySeconds: 60 periodSeconds: 20 接下来是部署 Service（这里的服务发现组件），K8s 自带的。\n部署 API Gateway。大同小异，同上。\nKubernetes 零停机部署 构建新的容器镜像，变更版本 编辑服务部署的 YAML 文件，以便它引用新镜像。 使用 kubectl apply -f 命令更新部署。 K8s 将对 Pod 进行滚动升级。\nkubectl rollout undo deployment ftgo-restaurant-service 简介 FaaS、SaaS、PasS、IaaS、Serverless 这些内容都是一些概念，并不是实际的实现，尤其是 Serverless 截止 2021 年初还没有标准的规范，我 Amazon 可以说我 Lambda 是标准的，我 Spring Boot + Azure 也可以说是 Serverless，我 Serverless X 也可以说是这个。某一次的技术沙龙直播，我问这个腾讯相关的人员，说各有优缺点。\n下面的图层描绘了不同抽象层次上的云服务类型。 Function as Service 功能即服务是一类云计算服务，它提供了一个平台，允许客户开发，运行和管理应用程序功能，而无需构建和维护通常与开发和启动应用程序相关的基础结构的复杂性。按照此模型构建应用程序是实现“无服务器”体系结构的一种方法，通常在构建微服务应用程序时使用。\nFunction as a service (FaaS) is a category of cloud computing services that provides a platform allowing customers to develop, run, and manage application functionalities without the complexity of building and maintaining the infrastructure typically associated with developing and launching an app.[1] Building an application following this model is one way of achieving a \u0026ldquo;serverless\u0026rdquo; architecture, and is typically used when building microservices applications.\nSoftware as a Service 软件即服务Software as a Service，亦可称为“按需即用软件”（即“一经要求，即可使用”）软件即服务，它是一种软件交付模式。在这种交付模式中，软件仅需通过网络，不须经过传统的安装步骤即可使用，软件及其相关的数据集中托管于云端服务。用户通常使用精简客户端，一般即经由网页浏览器来访问、访问软件即服务。SaaS 最大的特色在于软件本身并没有被下载到用户的硬盘，而是存储在提供商的云端或者服务器。对比传统软件需要花钱购买，下载。软件即服务只需要用户租用软件，在线使用，不但大大减少了用户购买风险, 也无需下载软件本身，无设备要求的限制。\nPlatform as a Service 平台即服务，是一种云计算服务，提供运算平台与解决方案服务。在云计算的典型层级中，PaaS层介于软件即服务与基础设施即服务之间。\nPaaS提供用户将云端基础设施部署与创建至客户端，或者借此获得使用编程语言、程序库与服务。用户不需要管理与控制云端基础设施（包含网络、服务器、操作系统或存储），但需要控制上层的应用程序部署与应用托管的环境。[1]\nPaaS 将软件研发的平台做为一种服务，以软件即服务（SaaS）模式交付给用户。因此，PaaS也是SaaS模式的一种应用。但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度。\nPaaS 提供软件部署平台（runtime），抽象掉了硬件和操作系统细节，可以无缝地扩展（scaling）。开发者只需要关注自己的业务逻辑，不需要关注底层。下面这些都属于 PaaS。\nK8s + Docker 也就相当于 PaaS 的实现。\nInfrastructure as a Service 基础设施为服务。\n云原生开发最终演化方向。\nServerless 无服务化，冷启动应用，按需分配服务，适合边缘业务。\n下下一代项目架构，目前只是 AWS 提供了 Lambda 来实现，在英文版的 InfoQ 上，有人把 Spring Boot + Azure = Serverless。\n其实还没有非常明确的定义 Serverless 的规范，任何厂商都可以说他们的才是正统的 Serverless 服务器。\nSPI SPI（Service Provider Interface）是 JDK 内置的一种服务提供发现机制。SPI 是一种动态替换发现的机制。 SPI 典型的实现为 JDBC。\nDDD DDD 名词解释 子域 核心域 通用域 支撑域 限界上下文 聚合 聚合根 实体 值对象 领域事件 依赖倒置 仓储（Repository） ServiceManager DDD 如何落地 划分子域，子域内构建事件风暴。\nDDD 包名规范 infrastructure\nrepository\nservice\nentity\nOS 动态内存分配 空闲列表 可用表格，可用链表存储。\n分区分配算法 首次适应 最佳适应 最差适应 分区释放算法 指针碰撞 ","permalink":"http://localhost:1313/posts/interview/","summary":"\u003ch1 id=\"前言\"\u003e前言\u003c/h1\u003e\n\u003cp\u003e仅供本人面试前准备，其他人还是别看了，没意义。有很多我缩写，省去了很多易理解的部分。\u003c/p\u003e\n\u003cp\u003e我尽量找别人已经总结过的东西，而不是自己写，无意义，面试的八股文罢了。都是靠努力就能实现的东西。\u003c/p\u003e\n\u003ch1 id=\"常见容器\"\u003e常见容器\u003c/h1\u003e\n\u003ch2 id=\"arraylist-详解\"\u003eArrayList 详解\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://note.youdao.com/ynoteshare1/index.html?id=efd2a3a29d2626acea2b053e56bae5cc\u0026amp;type=notebook#/04F1A0EFF8F241C2A89E2234AAF0A36A\"\u003ehttps://note.youdao.com/ynoteshare1/index.html?id=efd2a3a29d2626acea2b053e56bae5cc\u0026type=notebook#/04F1A0EFF8F241C2A89E2234AAF0A36A\u003c/a\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e底层\u003cstrong\u003e基于数组\u003c/strong\u003e实现\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e创建 ArrayList 如果不指定大小\u003c/strong\u003e，会先创建一个\u003cstrong\u003e大小为 0 的 Object[ ] 数组\u003c/strong\u003e ，\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e第一次添加数据\u003c/strong\u003e时，会\u003cstrong\u003e扩容\u003c/strong\u003e成 ArrayList 的 默认大小 \u003cstrong\u003edefault_capacity：10\u003c/strong\u003e**；**\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e\n\u003cp\u003e创建时如果\u003cstrong\u003e指定大小\u003c/strong\u003e，直接\u003cstrong\u003e创建指定大小的Object[ ]数组\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eadd（）\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e对 \u003cstrong\u003esize+1\u003c/strong\u003e，去\u003cstrong\u003e判断数组是否满了\u003c/strong\u003e，如果满了就\u003cstrong\u003e调用 grow（）方法扩容\u003c/strong\u003e，扩容大小为，\u003cstrong\u003e原数组大小 + 原数组大小右移一位\u003c/strong\u003e。也就是扩容到原来的\u003cstrong\u003e1.5倍\u003c/strong\u003e。JDK 1.6 是 1.5 倍 +1 ，JDK 1.7，1.8 是 1.5 倍。\u003c/li\u003e\n\u003cli\u003e然后把老数组拷贝到新数组里\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eelementData\u003c/strong\u003e = \u003cstrong\u003eArrays.copyOf(elementData, newCapacity);\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最后 \u003cstrong\u003eelementData[ size++ ] = e\u003c/strong\u003e，对数组赋值，（并且size+1）\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003eadd（index，e）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e首先\u003cstrong\u003e对index做数组越界检查rangeCheck(index)\u003c/strong\u003e;  如果越界了，抛数组越界异常\u003c/li\u003e\n\u003cli\u003e如果没越界，还是\u003cstrong\u003e对 size + 1，判断是否需要扩容\u003c/strong\u003e，如果需要扩容，调用\u003cstrong\u003egrow\u003c/strong\u003e方法\u003c/li\u003e\n\u003cli\u003e如果需要扩容，调用\u003cstrong\u003eSystem.arraycopy（1,2,3,4,5）\u003cstrong\u003e方法。参数解释\u003c/strong\u003e1：原来的数组，2：从哪里开始复制。3：复制的目标数组。4：目标数组的第几位开始复制。5：一共复制几个数\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003eSystem.arraycopy(elementData, index, elementData, index + 1, size - index);\u003c/li\u003e\n\u003cli\u003e假设把数字6插入到第3位，复制过后的数组是，1 2 3 4 5 -\u0026gt; \u003cstrong\u003e1 2 3 3 4 5\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e然后再把目标的位置的值修改，变为 \u003cstrong\u003e1 2 6 3 4 5\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e最后size++；\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003eset（index，e）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e首先解释，set这个方法是替换该位置原来的元素，所以不会使数组变大，不会做扩容判断\u003c/li\u003e\n\u003cli\u003e然后对index做数组越界检查，如果越界了，抛数组越界异常\u003c/li\u003e\n\u003cli\u003e把e替换到数组的index位置\u003c/li\u003e\n\u003cli\u003e返回数组index位置的原始值\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"7\"\u003e\n\u003cli\u003eremove（index）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e首先\u003cstrong\u003e对index做数组越界检查rangeCheck(index);\u003c/strong\u003e，如果越界了，抛数组越界异常\u003c/li\u003e\n\u003cli\u003e然后进行\u003cstrong\u003e数组拷贝 System.arraycopy(elementData, index+1, elementData, index,size - index - 1);\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e假设把第三位数字删除，\u003cstrong\u003e1 2 3 4 5 6 \t- \u0026gt; 1\t2 4 5 6 6\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e然后 element[size\u0026ndash;] = null;\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e最后\u003cstrong\u003e返回被删除的值\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"8\"\u003e\n\u003cli\u003eget（index）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e首先对index做数组越界检查\u003cstrong\u003erangeCheck(index);\u003c/strong\u003e，如果越界了，抛数组越界异常\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ereturn elementData(index);\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"9\"\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e总结来说，AraayList的get方法效率非常高，直接返回对应下标值，add方法和remove方法，效率就有点低了，需要考虑数组扩容和数组拷贝的问题\u003c/strong\u003e**。**\u003c/p\u003e","title":"For Interview"},{"content":"打开 DockerDesktop 如果你有其他配置改了的，直接复制这个，记住前面的逗号不要删 ,\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;,\u0026#34;https://hub-mirror.c.163.com\u0026#34;] 如果你之前什么都没改，复制粘贴下面内容 { \u0026#34;debug\u0026#34;: true, \u0026#34;experimental\u0026#34;: false, \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;,\u0026#34;https://hub-mirror.c.163.com\u0026#34;] } 如果在上图的界面报错，不能改 打开 Terminal 进入 Users/YourName目录下，复制粘贴进去\ncd .docker vi deamon.json 重启docker，镜像生效\n{% note danger %}\n如果 docker 点 prefrence一直在更新状态，检查一下daemon.json 文件是否格式正确\n{% endnote %}\n如果不想换镜像源，可以开代理 别问我什么是代理，问就是不知道\n我的本地代理端口是10080，你要是服务器的话，http://[ ip address]:[port]\n像这样\n二选一，别两个都写，或者打开 terminal，\nexport ALL_PROXY=socks5://127.0.0.1:10080; export http_proxy=socks5://127.0.0.1:10080; export https_proxy=socks5://127.0.0.1:10080;，\n终极方案 Dockerfile FROM 你的服务器后，加上，Docker Compose 建议下一种方法。\nENV http_proxy \u0026lt;HTTP_PROXY\u0026gt; ENV https_proxy \u0026lt;HTTPS_PROXY\u0026gt; 打开终端后设置 export http_proxy=\u0026#34;\u0026lt;HTTPS_PROXY\u0026gt;\u0026#34; export https_proxy=\u0026#34;\u0026lt;HTTPS_PROXY\u0026gt;\u0026#34; 引用 https://www.jianshu.com/p/419eaf4425a6\nhttp://pangguoming.com/blog/architecture/docker-configuration-file-daemon.json\n","permalink":"http://localhost:1313/posts/mac-docker--mirrors/","summary":"\u003ch1 id=\"打开-dockerdesktop\"\u003e打开 \u003ccode\u003eDockerDesktop\u003c/code\u003e\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"docker更改国内镜像源.png\" loading=\"lazy\" src=\"https://i.loli.net/2020/07/16/BM374ek9xKfoOZT.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"如果你有其他配置改了的直接复制这个记住前面的逗号不要删\"\u003e如果你有其他配置改了的，直接复制这个，记住前面的逗号不要删\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e,\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;,\u0026#34;https://hub-mirror.c.163.com\u0026#34;]\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"如果你之前什么都没改复制粘贴下面内容\"\u003e如果你之前什么都没改，复制粘贴下面内容\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e\u0026#34;debug\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e\u0026#34;experimental\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e\u0026#34;registry-mirrors\u0026#34;\u003c/span\u003e: [\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;https://hub-mirror.c.163.com\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"如果在上图的界面报错不能改\"\u003e如果在上图的界面报错，不能改\u003c/h1\u003e\n\u003cp\u003e打开 Terminal 进入 Users/YourName目录下，复制粘贴进去\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecd .docker\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003evi deamon.json\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e重启\u003ccode\u003edocker\u003c/code\u003e，镜像生效\u003c/p\u003e\n\u003cp\u003e{% note danger %}\u003c/p\u003e\n\u003cp\u003e如果 \u003ccode\u003edocker\u003c/code\u003e 点 \u003ccode\u003eprefrence\u003c/code\u003e一直在更新状态，检查一下\u003ccode\u003edaemon.json\u003c/code\u003e 文件是否格式正确\u003c/p\u003e\n\u003cp\u003e{% endnote %}\u003c/p\u003e\n\u003ch1 id=\"如果不想换镜像源可以开代理\"\u003e如果不想换镜像源，可以开代理\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e别问我什么是代理，问就是不知道\u003c/p\u003e\n\u003cp\u003e我的本地代理端口是10080，你要是服务器的话，\u003ccode\u003ehttp://[ ip address]:[port]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e像这样\u003c/p\u003e\n\u003cp\u003e二选一，别两个都写，或者打开 \u003ccode\u003eterminal\u003c/code\u003e，\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eexport ALL_PROXY=socks5://127.0.0.1:10080;\u003c/code\u003e\n\u003ccode\u003eexport http_proxy=socks5://127.0.0.1:10080; \u003c/code\u003e\n\u003ccode\u003eexport https_proxy=socks5://127.0.0.1:10080;\u003c/code\u003e，\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg alt=\"proxy.png\" loading=\"lazy\" src=\"https://i.loli.net/2020/07/20/2vHdlr7B34L5fGX.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"终极方案\"\u003e终极方案\u003c/h1\u003e\n\u003ch2 id=\"dockerfile\"\u003eDockerfile\u003c/h2\u003e\n\u003cp\u003eFROM 你的服务器后，加上，Docker Compose 建议下一种方法。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-dockerfile\" data-lang=\"dockerfile\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eENV\u003c/span\u003e http_proxy \u0026lt;HTTP_PROXY\u0026gt;\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eENV\u003c/span\u003e https_proxy \u0026lt;HTTPS_PROXY\u0026gt;\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"打开终端后设置\"\u003e打开终端后设置\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexport http_proxy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026lt;HTTPS_PROXY\u0026gt;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexport https_proxy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026lt;HTTPS_PROXY\u0026gt;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"引用\"\u003e引用\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://www.jianshu.com/p/419eaf4425a6\"\u003ehttps://www.jianshu.com/p/419eaf4425a6\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://pangguoming.com/blog/architecture/docker-configuration-file-daemon.json\"\u003ehttp://pangguoming.com/blog/architecture/docker-configuration-file-daemon.json\u003c/a\u003e\u003c/p\u003e","title":"Mac 下 Docker 更改国内镜像源"},{"content":"电子原版目录以及概要\n请购买实体书籍，支持作者、翻译以及出版社\nCreating and Destroying Objects 用静态工厂方法代替构造器 public static Boolean valueOf(boolean b){ return b ? Boolean.TRUE : Boolean.FALSE; } 静态工厂方法与设计模式中的工厂方法模式不同。并不能直接对应设计模式的工厂方法。\n优势\n有名字（像这种BigInteger.probablePrime(int bitLength,Random rnd)） 不必每次调用他们的时候，都创建一个新对象。像Integer.MAX_VALUE = 0x7fffffff（享元Flyweight模式）真正的享元模式如下，Integer中有个私有静态类，叫IntergeCache 可以返回原返回类型的任何子类型的对象。Java8允许接口中含有静态方法，Java9允许接口中有私有的静态方法，但是静态域和静态成员变量仍然需要是公有的。 所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。 方法返回的对象所属的类，在便携包含该静态工厂方法的类时可以不存在。 public static Integer valueOf(int i) { if (i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; /** * 这里定义了最大值，也就是说这个可以配置 * -XX:AutoBoxCacheMax=NNN，这里的 NNN 表示最大值是多少，只能改最大值，不能改最小值。 * 在设置了-XX:+AggressiveOpts启动参数后，AutoBoxCacheMax的默认值会被修改为20000并且生效。 * 这里的 -XX:+AggressiveOpts 是表示加快编译 * aggressive adj.好争斗的, 挑衅的, 侵略性的 * export JAVA_OPTS=\u0026#34;-Xms2048m -Xmx2048m\u0026#34;。 * 合起来翻译 积极的选择 * - Tired compilers (hoping that it will make it into JDK7) * - Scalar replacement (and I am still hoping that this will remove some of the memory throughput preassure 64-bit brought) * EA and stack allocation * Code cache */ String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\u0026#34;java.lang.Integer.IntegerCache.high\u0026#34;); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k \u0026lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high \u0026gt;= 127; } private IntegerCache() {} } 缺点\n类如果不含公有或者受保护的构造器，就不能被子类化 难发现它们 BeanDefinitionBuiler 就是将静态工厂方法 和 构建器 模式结合的案例。\n遇到多个构造器参数时要考虑使用构建器 JavaBean模式（不推荐，当然我觉得不包括 POJO 类）\nBuilder模式（lombok提供了@Builder注解，可以偷懒，但是就不要注解了，可以在顶部菜单栏Refactor使用 delomok生成相应代码）\n// 样例 // spring-beans 下。 public final class BeanDefinitionBuilder { private final AbstractBeanDefinition beanDefinition; private int constructorArgIndex; // 返回一般 BeanDefinitionBuilder public static BeanDefinitionBuilder genericBeanDefinition(String beanClassName) { BeanDefinitionBuilder builder = new BeanDefinitionBuilder(new GenericBeanDefinition()); builder.beanDefinition.setBeanClassName(beanClassName); return builder; } // 省略其他相同类型方法..... // init-method public BeanDefinitionBuilder setInitMethodName(@Nullable String methodName) { this.beanDefinition.setInitMethodName(methodName); return this; } // detroy-method public BeanDefinitionBuilder setDestroyMethodName(@Nullable String methodName) { this.beanDefinition.setDestroyMethodName(methodName); return this; } // scope defualt singleton public BeanDefinitionBuilder setScope(@Nullable String scope) { this.beanDefinition.setScope(scope); return this; } // 省略其他类型方法.... public AbstractBeanDefinition getBeanDefinition() { this.beanDefinition.validate(); return this.beanDefinition; } } //使用 public class BeanDefinitionAPI{ public GenericBeanDefinition getGeneriBeanDefinition(){ return (GenericBeanDefinition)BeanDefinitionBuilder .genericBeanDefinition(\u0026#34;org.springframework.web.client.RestTemplate\u0026#34;) .setScope(\u0026#34;singleton\u0026#34;) .getBeanDefinition(); } } 如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是一种不错的选择\n用私有构造器或者枚举类型强化Singleton属性 如果要阻止反射实例化单例类，可以在被要求创建第二个实例的时候，抛出异常。\n/** * 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。 * 双检锁/双重校验锁（DCL，即 double-checked locking） */ public class Singleton{ private volatile Singleton singleton = null; private Singleton(){ //这里检查是不是初始化过了 if(singleton != null){ throw new IllegalAccessException(); } } public static getInstance(){ if(singleton == null){ synchronized(Singleton.class){ if(singleton == null){ singleton = new Singleton(); } } } return singleton; } } 单元素的枚举类型经常成为实现Singleton的最佳方法。当然如果Singleton必须扩展一个超类，而不是扩展Enum的时候，则不宜使用这个方法。\n下面是 Spring Boot 2.0 引入的单例类。具体执行顺序如下\nSpringApplication#run --\u0026gt; SpringApplication#prepareEnvironment --\u0026gt; SpringApplication#configureEnvironment --\u0026gt; ApplicationConversionService#getSharedInstance 也是使用 DCL 思想（我觉得应该从 Stackoverflow 上面复制的）。\npublic class ApplicationConversionService extends FormattingConversionService { private static volatile ApplicationConversionService sharedInstance; public ApplicationConversionService() { this(null); } public ApplicationConversionService(StringValueResolver embeddedValueResolver) { if (embeddedValueResolver != null) { setEmbeddedValueResolver(embeddedValueResolver); } configure(this); } /** * Return a shared default application {@code ConversionService} instance, lazily * building it once needed. * \u0026lt;p\u0026gt; * Note: This method actually returns an {@link ApplicationConversionService} * instance. However, the {@code ConversionService} signature has been preserved for * binary compatibility. * @return the shared {@code ApplicationConversionService} instance (never * {@code null}) */ public static ConversionService getSharedInstance() { ApplicationConversionService sharedInstance = ApplicationConversionService.sharedInstance; if (sharedInstance == null) { synchronized (ApplicationConversionService.class) { sharedInstance = ApplicationConversionService.sharedInstance; if (sharedInstance == null) { sharedInstance = new ApplicationConversionService(); ApplicationConversionService.sharedInstance = sharedInstance; } } } return sharedInstance; } // 省略一大段代码。 } 通过私有构造器强化不可实例化的能力 像这种工具类就私有构造器。使用 final 防止继承，使用私有构造器防止实例化（开安全后防止反射实例化）。\npublic final class DateUtil{ private DateUtil(){} } 例如 spring.core 中的 String 工具类。\npublic abstract class StringUtils { private static final String FOLDER_SEPARATOR = \u0026#34;/\u0026#34;; private static final String WINDOWS_FOLDER_SEPARATOR = \u0026#34;\\\\\u0026#34;; private static final String TOP_PATH = \u0026#34;..\u0026#34;; private static final String CURRENT_PATH = \u0026#34;.\u0026#34;; private static final char EXTENSION_SEPARATOR = \u0026#39;.\u0026#39;; public StringUtils() { } } 优先考虑依赖注入来引用资源 通过依赖注入而非手动 new 对象，降低类于类之间的耦合度。而且应该尽量是基于接口而非实现来注入，这样更适合经常变更的类，或者模块。当然，不是 Service 都需要写接口，除非你真的很需要，例如 SOA 程序、微服务程序，需要提供给外部 SDK。像 Spring Cloud 所有模块，以及 Spring 所定义的所有抽象一样，定义了统一的接口，引用的都是接口，而非实现类，Spring 统一的 Caching 等接口也是如此。\n静态工具类和Singleton类不适合于需要引用底层资源的类。\n关于解耦，右侧有更多解释。细数软件架构中的解耦\n集中化配置，根据服务动态解析 IP 也算是解耦的方式。\n当创建一个新的实例时，就将该资源传到构造器中\n依赖注入（Dependency Injection）\n类似的内容，在进程间的 Broker 消息模式也有体现。\n关于构造器注入好，还是 Setter 注入好，个人认为是前者好。Spring作者也推荐前者，因为这样能判断你是不是传了非空、非法的参数。\n如果想更深入了解如何实现循环依赖，在构造器注入如何实现，可以看看 ObjectProvider，以及 Spring Boot MyBatis 的内容，那个比较简单。\nSpring 中单例的对象，并不一定是全局唯一的，它是 每个 ClassLoader 中唯一的，static 对象也是。所以插件 Spring Dev Tool 让项目重启，只需要新的 ClassLoader 加载这些内容。这里有个小知识点，就是分级处理。和 JVM 的分代处理其实是差不多的，就是将部分不变的类用固定的 ClassLoader 加载，项目中可变的类用新的 ClassLoader 加载，这样就实现每次代码变更，不用全部重新加载的功能了。当然，这里是简化了实现细节，内部实现没有这么简单。\n避免创建不必要的对象 字符串循环累加 包装类型循环累加 // DON\u0026#39;T DO THIS面试经常问到这个，傻瓜才会这么写 String s = new String(\u0026#34;bikini\u0026#34;); //正确的写法 String s = \u0026#34;bikini\u0026#34;; // 关于是否是罗马数字的正则校验 这样做不合理 static boolean isRomanNumeral(String s){ return s.matche(\u0026#34;^(?=.)M{1,3}?(CM|C?D|D?C{1,3})?(XC|XL|L|L?X{1,3})?(IX|I?V|V?I{1,3})?$\u0026#34;); } // 虽然String.matches方法最易于查看一个字符串是否与正则表达式相匹配，但并不适合在注重性能的情形中重复使用 public class RomanNumerals{ private static final Pattern ROMAN = Pattern.compile(\u0026#34;^(?=.)M{1,3}?(CM|C?D|D?C{1,3})?(XC|XL|L|L?X{1,3})?(IX|I?V|V?I{1,3})?$\u0026#34;); static boolean isRomanNumeral(String s){ return ROMAN.matcher(s).matches(); } } 适配器是指这样一个对象：它把功能委托给一个后备的对象（backing object），从而为后备对象提供一个可以代替的接口。\nWebMvcConfigurerAdapter 这是个适配器，一般用于配置web的一些配置，如拦截器Interceptor，JSONformatter等，不过在Java8出来接口中声明 default 方法后，这个类就被声明 @Deprecated。\n优先使用基础类型而不是装箱基本类型，要当心无意识的自动装箱。(当然，实际生产中，除非你用于科学计算，一般都用包装类，例如 long 和 Long，小写的 l 容易看成大写 i 避免歧义)。\n// 不推荐下面的写法，会让系统无意义得创建很多Long类型对象。 private static long sum(){ Long sum = 0L; for(long i = 0;i \u0026lt;= Integer.MAX_VALUE; i++){ //就算是一行代码，我也推荐加上大括号，语义清晰 sum += i; } return sum; } public class Stack{ public Object pop(){ if(size ==0){ return new NullPointException(); } Object result = elements[--size]; // 把数组中对象置空，防止内存泄漏 elements[size] = null; return result; } } 内存泄漏的另一个常见来源是缓存。用WeakHashMap代表缓存。只有当所要的缓存项的生命周期是由该键的外部引用而不是由值决定时，WeakHashMap才有用处。\n第三个常见来源是监听器和其他回调。可以借助 Heap 剖析工具（Heap Profiler）发现内存泄漏问题。\nThreadLocal 是否存在内存泄漏问题，为什么？\n阿里云云栖号\n避免使用finalizer方法，和Java9的cleaner方法 public class Room implements AutoCloseable{ private static final Clearner cleaner = Cleaner.create(); private final State state; private final Cleaner.Cleanable cleanable; private static class State implements Runnable{ int numJunkPiles; State(int numJunkPiles){ this.numJunkPiles = numJunkPiles; } @Override public void run(){ System.out.println(\u0026#34;Cleaning room\u0026#34;); numJunkPiles = 0; } } public Room(int numJunkPiles){ state = new State(numJunkPiles); cleanable = cleaner.register(this,state); } @Override public void close(){ cleanable.clean(); } } try with resources 优先于 try finally // 正例 static String firstLineOfFile(String path,String defualtVal){ try(BufferedReader br = new BufferedReader(new FileReader(path))){ return br.readLine(); }catch(IOException e){ return defaultVal; } } // 反例 void query(){ Connection conn = null; PreparedStatement pst = null; ResultSet rs = null; try{ conn = DriverManager.getConnection(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); // dual 表只在 Mysql 是默认有的，Oracle 查不到的 pst = conn.prepareStatement(\u0026#34;SELECT 1 FROM dual\u0026#34;); pst.execute(); rs = pst.getResultSet(); rs.getInt(0); // 老程序猿是这样教的，当然实际生产中不要这么写，尽量细化异常，让不同异常，做不同的事 }catch(Exception e){ e.printStackTrace(); }finally { try{ if(conn != null){ conn.close(); } }catch(Exception e){ e.printStackTrace(); } try{ if(pst != null){ pst.close(); } }catch(Exception e){ e.printStackTrace(); } try{ if(rs != null){ rs.close(); } }catch(Exception e){ // 这里的 logger 是 Slf4j 获取的 Logger logger.error(getStackTraceAsString(e)); } } } private String getStackTraceAsString(Throwable e) { if (e == null){ return \u0026#34;\u0026#34;; } StringWriter stringWriter = new StringWriter(); e.printStackTrace(new PrintWriter(stringWriter)); return stringWriter.toString()； } // 1.7引入的语法糖，让代码更简洁 // try with resource 相当于默认加了finally块，并且默认添加 finally 块，其中调用实现了 AutoCloseable 接口的 close 方法 // AtuoCloseable 接口自 1.7 引入，让 Closeable 继承，而 Closeable @since 1.5 // InputStream \u0026amp; OutputStream 都实现了 Closeable接口 Methods Common to All Objects 什么时候应该覆盖equals方法？ 如果类具有自己特有的“逻辑相等”（logical equality）概念，而且超类还没有equals。这通常属于”值类“（Value class），值类仅仅是表示一个表示值的类，例如Integer或String。\nString foo = new String(\u0026#34;str\u0026#34;); String bar = new String(\u0026#34;str\u0026#34;); foo.equals(bar);// true 比较的是对象内容，String重写了Object的equals方法 foo == bar ;// false 比较内存地址，只要内存地址为true，就一定是一样的对象 // 还有ons-client（RocketMQ的Java client） Subscription 订阅类，覆盖了equals方法，比较的是topic，只要topic相等，这个类就相等(dump)，但是他要根据不同 tag 获取不同消息内容，比如删除 人员信息的tag和新增人员信息的 tag 不一样。搞得我以不同 tag 为基础设置类，配置半天找不到问题。 equals方法实现了等价关系（equivalence relation）\n放心，在《算法》Java 版本的这本书上也有介绍，这只是个基本的概念而已。\n\u0026ndash; 所有前提是 对于任何非null的引用值x\n自反性（reflexive）：x.equals(x)必须为true 对称性（symmetric）：如果x.equals(y)==true，必定y.equals(x);前提是两个非null 传递性（transitive）：x.equals(y)==true,y.equals(z)==true,z.equals(x)==true; 一致性（consistent）：当x.equals(y)==true时，只要在比较操作在对象中所用的信息没有被修改，多次调用，都是true。 任何非null的引用值x，x.equals(null)==true; 里氏替换原则（Liskov substitution principle）认为，一个类型的任何重要属性也将适用于它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行得很好。\n@AutoValue public abstract class AutoValueMoney { public abstract String getCurrency(); public abstract long getAmount(); public static AutoValueMoney create(String currency, long amount) { return new AutoValue_AutoValueMoney(currency, amount); } } public final class AutoValue_AutoValueMoney extends AutoValueMoney { private final String currency; private final long amount; AutoValue_AutoValueMoney(String currency, long amount) { if (currency == null) throw new NullPointerException(currency); this.currency = currency; this.amount = amount; } @Override public int hashCode() { int h = 1; h *= 1000003; h ^= currency.hashCode(); h *= 1000003; h ^= amount; return h; } @Override public boolean equals(Object o) { if (o == this) { return true; } if (o instanceof AutoValueMoney) { AutoValueMoney that = (AutoValueMoney) o; return (this.currency.equals(that.getCurrency())) \u0026amp;\u0026amp; (this.amount == that.getAmount()); } return false; } } @Test public void givenValueTypeWithAutoValue_whenFieldsCorrectlySet_thenCorrect() { AutoValueMoney m = AutoValueMoney.create(\u0026#34;USD\u0026#34;, 10000); assertEquals(m.getAmount(), 10000); assertEquals(m.getCurrency(), \u0026#34;USD\u0026#34;); } 覆盖 equals 时总要覆盖 hashCode 在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对同一个对象的多次调用，hashCode方法必须始终放回同一个值。在一个应用程序与另一个程序的执行过程中，执行hashCode方法所返回的值可以不一致。 两个对象equals调用相等，hashCode一定相等 两个对象equals调用不相等，hashCode可以一样。例如String的hashCode public int hashCode(){\tint h = hash; if (h == 0 \u0026amp;\u0026amp; value.length \u0026gt; 0) { char val[] = value; for (int i = 0; i \u0026lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } //选31*每个h值+每个char的值 这是 HashMap 的实际的put 方法，里面通过\n// 如果你是 new HashMap()创建的对象，默认这里的 resize() 大小是 16，DEFAULT_INITIAL_CAPACITY = 1 \u0026lt;\u0026lt; 4 //aka 16 /** * Implements Map.put and related methods. * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don\u0026#39;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i; // 第一次创建 HashMap，如果没有特殊处理，这里的 table 为 null if ((tab = table) == null || (n = tab.length) == 0) //\t也就是这里的 n = 16 n = (tab = resize()).length; // 与 \u0026amp; 操作两个操作数中位都为1，结果才为1，否则结果为0 // 这里是判断 tab[i] 数组上有没有对象，没有直接存，跳过下面 else 复杂的步骤 if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u0026lt;K,V\u0026gt; e; K k; // 这里就用到 equals 来判断了 if (p.hash == hash \u0026amp;\u0026amp;((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size \u0026gt; threshold) resize(); afterNodeInsertion(evict); return null; } 始终要覆盖toString 下面是Spring中的抽象Bean定义类重写的hashCode()和toString()方法，重写toString()让我们能更好的debug以及了解这个类属性。String的hashCode是以31为优选乘子，选择相邻的质数也是ok的，但是 31 = (2\u0026lt;\u0026lt;5) -1 ,可以被JVM优化。\n{% note danger %}\n不建议用 Lombok 以及 AutoValue 。代码是简洁了，维护起来很麻烦。\n{% endnote %}\n你使用了这些插件，你的组员也要用，如果你在内网开发，其他人没有这个插件，完全是个灾难。 代码是整洁了，但是维护起来很麻烦，不要图一时之快。 当然你要用，要注意用@Slf4j，而不是@Log4j，SpringBoot默认使用Logback，你指定了Log4j，就会有冲突，你换成其他日志输出框架，那就有问题。Slf4j有桥接包，屏蔽了这些内容，让你可以LoggerFactory.getLogger(xxx.class)，而不用明确指定是哪个日志输出框架。\n那Spring 和其他框架是怎么输出日志的呢，就是用 apache.logging包下的protected final org.apache.commons.logging.Log logger = org.apache.commons.logging.LogFactory.LogFactory.getLog(this.getClass());里面的getLog方法，再来了LogAdpter.createLog()这个 LogAdpter里面就是去找slf4j或者log4j内容，当然你用Spring Boot默认的 logback就用Slf4j再来个桥接包。\nfinal class LogAdapter { private static final String LOG4J_SPI = \u0026#34;org.apache.logging.log4j.spi.ExtendedLogger\u0026#34;; private static final String LOG4J_SLF4J_PROVIDER = \u0026#34;org.apache.logging.slf4j.SLF4JProvider\u0026#34;; private static final String SLF4J_SPI = \u0026#34;org.slf4j.spi.LocationAwareLogger\u0026#34;; private static final String SLF4J_API = \u0026#34;org.slf4j.Logger\u0026#34;; private static final LogAdapter.LogApi logApi; private LogAdapter() { } } 下面是解析 Spring 中AbstractBeanDefinition 的 toString()方法。\npublic abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor implements BeanDefinition, Cloneable { public int hashCode() { int hashCode = ObjectUtils.nullSafeHashCode(this.getBeanClassName()); hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.scope); hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.constructorArgumentValues); hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.propertyValues); hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.factoryBeanName); hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.factoryMethodName); hashCode = 29 * hashCode + super.hashCode(); return hashCode; } public String toString() { StringBuilder sb = new StringBuilder(\u0026#34;class [\u0026#34;); sb.append(this.getBeanClassName()).append(\u0026#34;]\u0026#34;); sb.append(\u0026#34;; scope=\u0026#34;).append(this.scope); sb.append(\u0026#34;; abstract=\u0026#34;).append(this.abstractFlag); sb.append(\u0026#34;; lazyInit=\u0026#34;).append(this.lazyInit); sb.append(\u0026#34;; autowireMode=\u0026#34;).append(this.autowireMode); sb.append(\u0026#34;; dependencyCheck=\u0026#34;).append(this.dependencyCheck); sb.append(\u0026#34;; autowireCandidate=\u0026#34;).append(this.autowireCandidate); sb.append(\u0026#34;; primary=\u0026#34;).append(this.primary); sb.append(\u0026#34;; factoryBeanName=\u0026#34;).append(this.factoryBeanName); sb.append(\u0026#34;; factoryMethodName=\u0026#34;).append(this.factoryMethodName); sb.append(\u0026#34;; initMethodName=\u0026#34;).append(this.initMethodName); sb.append(\u0026#34;; destroyMethodName=\u0026#34;).append(this.destroyMethodName); if (this.resource != null) { sb.append(\u0026#34;; defined in \u0026#34;).append(this.resource.getDescription()); } return sb.toString(); } } 谨慎地覆盖 clone 不可变的类永远都不应该提供clone方法\n实际上clone方法就是另一个构造器，必须确保它不会伤害到原始的对象，并确保正确地创建被克隆对象中的约束条件（invariant）。\nCloneable架构与引用可变对象的final域的正常用法是不相兼容的。\nHashMap.Entry被加强了，它支持一个“深拷贝”deepCopy();\n@Override public Object clone() { HashMap\u0026lt;K,V\u0026gt; result; try { result = (HashMap\u0026lt;K,V\u0026gt;)super.clone(); } catch (CloneNotSupportedException e) { // this shouldn\u0026#39;t happen, since we are Cloneable throw new InternalError(e); } result.reinitialize(); result.putMapEntries(this, false); return result; } 什么是深拷贝，什么是浅拷贝\nJava Shallow clone\nShallow clone is default implementation in Java. In overridden clone method, if you are not cloning all the object types (not primitives（原生类型）, then you are making a shallow copy.\nJava Deep Copy\nIn the deep copy, we create a clone which is independent of original object and making changes in the cloned object should not affect original object.\n考虑实现 Comparable 接口 public interface Comparable\u0026lt;T\u0026gt;{ int compareTo(T t); } 返回值规范\nthis \u0026lt; t =\u0026gt; -1， this == t =\u0026gt; 0; this \u0026gt; t =\u0026gt; 1; 遵循下面几个规范\nsgn(x.compareTo(y)) == -sgn(y.compareTo(x)); 类似1 == -(-1) 传递性，a\u0026gt;b,b\u0026gt;c =\u0026gt; a\u0026gt;c 如果x.compareTo(y) ==0，sgn(x.compareTo(z)) == sgn(y.compareTo(z))。a==b,a.f(c) == b.f(c) 强烈建议 x 比 y == 0，x.equals(y) =\u0026gt; true,若违反了这个条件，都应该明确说明。\nBigDecimal foo = new BigDecimal(\u0026#34;1.0\u0026#34;); BigDecimal bar = new BigDecimal(\u0026#34;1.00\u0026#34;); foo.equals(bar);//false foo.compareTo(bar);// 0\t值相等 在ocmpareTo方法中使用关系操作符 \u0026lt; 和 \u0026gt; 是非常繁琐的，而且容易出错，因此不建议使用\nHashSet 会两个都存，TreeSet 只会存一个，因为利用了compareTo() 方法。 实现 Comparable 接口，有助于在有序集合中更好的排序。\nClasses and Interfaces 使类和成员的可访问性最小化 区分一个组件设计得好不好，唯一重要的因素在于，它对外部的其他组件而言，是否隐藏了其内部数据和其他实现细节。设计良好的组件会隐藏所有的实现细节，把API与实现清晰地隔离开来。然后组件之间通过API通信，一个模块不需要知道其他模块的内部工作情况。这个概念被称为信息隐藏（information hiding）/封装（encapsulation），是软件设计的基本原则之一。\n例如Spring Boot 2.0后的版本的Spring Boot，直接在https://start.spring.io直接生成就完事了，不像以前写一个Web应用先要Servlet 容器（Tomcat/Jetty/Weblogic等），再实现javax.servlet.http.HttpServlet重写它的doGet/doPost方法，甚至是service方法（不建议这么做，有关内容自己谷歌 Http Code 304），然后在 web.xml文件中添加这么一坨东西。\n{% tabs content-1 %}\n// Import required java libraries import java.io.*; import javax.servlet.*; import javax.servlet.http.*; // Extend HttpServlet class public class HelloWorld extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String message = \u0026#34;Hello World\u0026#34;; // Set response content type response.setContentType(\u0026#34;text/html\u0026#34;); // Actual logic goes here. PrintWriter out = response.getWriter(); out.println(\u0026#34;\u0026lt;h1\u0026gt;\u0026#34; + message + \u0026#34;\u0026lt;/h1\u0026gt;\u0026#34;); } } \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;HelloWorld\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;me.young1lin.HelloWorld\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;HelloWorld\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/HelloWorld\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; {% endtabs %}\n引用\n当然这些东西不算完，还要放进Servlet容器中启动，最终返回信息。\n而Spring Boot只需要简单几行代码的配置，就能启动一个web应用。\n信息隐藏之所以重要，是因为\n有效地解除组成系统的各组件之间的耦合关系，即解耦（decouple），使得这些组件可以独立地开发、测试、优化、使用、理解和修改。 同时减轻了维护的负担。 隐藏实现，就可以使代码组件化，如果因为哪个组件性能差，就可以单独对这个组件进行优化。 {% note info %}\n尽可能地使每个类或者成员不被外界访问\n{% endnote %}\n并且一个包级私有的顶层类（或者接口）只是在某一个类的内部被用到，就应该考虑使它成为唯一使用它的那个累的私有嵌套类（内部类）。像下面这样\n{% tabs content-2 %}\npublic class HashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt;, Cloneable, Serializable { //.....省略一大段代码 static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; final K key; V value; Node\u0026lt;K,V\u0026gt; next; Node(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \u0026#34;=\u0026#34; + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry\u0026lt;?,?\u0026gt; e = (Map.Entry\u0026lt;?,?\u0026gt;)o; if (Objects.equals(key, e.getKey()) \u0026amp;\u0026amp; Objects.equals(value, e.getValue())) return true; } return false; } } } public class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable { // ......省略一大段代码 private class Itr implements Iterator\u0026lt;E\u0026gt; { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() {} public boolean hasNext() { return cursor != size; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E next() { checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } public void remove() { if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } @Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; consumer) { Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i \u0026gt;= size) { return; } final Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) { throw new ConcurrentModificationException(); } while (i != size \u0026amp;\u0026amp; modCount == expectedModCount) { consumer.accept((E) elementData[i++]); } // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } } {% endtabs %}\n公有类的实例域决不能是公有的，包含公有可变域的类通常并不是线程安全的。\n虽然 ClassPathXmlApplicationContext 封装做的很好，但是学习起来比较费劲。\n使可变性最小化 善用final、加上final的静态工厂，享元模式。BigDecimal.ZERO，Integer的自动拆装箱里面的CacheInteger类。\n复合优于继承 我觉得更优的翻译应该叫组合优于继承。当然，不是所有情况下都要用组合。《UNIX 编程艺术》中也提到，善用组合。\n下面是 Spring 基石 GenericApplicationContext 中的源码，其中 DefaultListableBeanFactory 才是真正的容器。这个叫组合模式，两者都实现了同一个接口（BeanFactory），这里的 DefaultListableBeanFactory 可以是一个至多个，然后依次调用，直到返回结果为止。\npublic class GenericApplicationContext extends AbstractApplicationContext implements BeanDefinitionRegistry{ private final DefaultListableBeanFactory beanFactory; // 省略一大段代码 @Override public final ConfigurableListableBeanFactory getBeanFactory() { return this.beanFactory; } // .....省略一段代码 } 用内含的方式实现，例如JFinal中的Record对象，内含了一个HashMap对象，来实现一些操作。万物(单条数据)皆为Record。\nSpring 中 ApplicationContext 类型的对象就是内涵了个 BeanFactory，其实就是 DefaultListableBeanFactory，也就是所谓的 IoC （Inversion of Control）容器。\n要么设计继承并提供文档说明，要么禁止继承 类必须精心挑选的受保护的（protected）方法，提供适当的钩子（hook），一边进入其内部工作中。\n因为要符合里氏替换原则，之后开发的人，并不清楚你现在的类是什么意思。\n接口优于抽象类 类是单继承，接口可以多实现，多接口可以实现不同业务需求，由于1.8后可以用default修饰接口方法，实现和抽象类一样的效果，又可以有实体方法，又有待子类实现的抽象方法。\nNetty 中的 ChannelInboundHandler 就是个很好的例子。\n多个接口方法同名，实现类报错\ninterface A{ int f(); } interface B{ void f(); } class C implements A,B{ int f();// 这样会报错，不知道你到底要返回什么类型，但是把B的void改成int，就不会报错 } 接口是高度抽象的结果，而抽象类\n为后代设计接口 慎用 default 去修饰接口方法\nBeanFactory 接口定义了最基本的容器功能。\n接口只用于定义类型 常量接口模式是对接口的不良使用\npublic interface XXXConstants{ static final String MY_CONSTANTS = \u0026#34;my constants \u0026#34;; } java.io.ObjectStreamConstants 是个反例\n如果要去定义常量\n要么在类内部定义，想 Integer.MAX_VALUE，BigDecimal.ZERO等等\n要么用枚举实现，像我自定义的状态信息\n接口应该用来定义类型。\n类层次优先于标签类 字面意思。\n像这种 AbstractApplicationContext 继承自 DefaultResourceLoader，拥有了资源加载的能力，像 EventObject 这种就是标记类，你可以加上，也可以不加，但是这是约定俗称的事件对象的类。\n著名的标签接口（tagging interface）java.util.EventListener、java.lang.Serializable。注意这里是接口，平常项目开发也是会自己定义标记接口的，里面没有任何方法（行为），仅起到标记作用。这个是约定俗称的内容，你不遵守，等待的就是报错（例如 Java 序列化没有实现 Serializable 接口，就会报错）。\n/** * A tagging interface that all event listener interfaces must extend. * @since JDK1.1 */ public interface EventListener { } 静态成员类优先于非静态成员类 Builder\nMap.Entry\n限制源文件为单个顶级类(public 修饰与文件名相同的类) public class A{ static final String NAME = \u0026#34;pan\u0026#34;; } class B{ static final String NAME = \u0026#34;cake\u0026#34;; } // 两个不同文件，public 修饰的 class 为该文件 public class B{ static final String NAME = \u0026#34;bar\u0026#34;; } class A{ static final String NAME = \u0026#34;foo\u0026#34;; } public class C{ public static void main(String[] args){ System.out.println(A.NAME+B.NAME); } } 这样有歧义，编译不给过，分开存。如果一定要放一起，就放在顶级类内部做静态成员类。\nGenerics 翻译版本有误，SINCE Java 5, generics have been a part of the language. 翻译版本少了个 s 变成了 generic。因为 Think in Java 英文版中， generics 才是代表泛型。\n不要使用原生态类型 // 别这样使用，报黄线是结果，原因是没有确定类型，那么就是任何类型都可以存入，如果存错了东西，取出来强制转换的时候，会报错。编译时给不了提示。 List apples = new ArrayList(1\u0026lt;\u0026lt;4); // 应该这样用，编译器就会告诉你哪里出问题 List\u0026lt;Apple\u0026gt; apples = new ArrayList (1\u0026lt;\u0026lt;4); apples.add(new Banana()); //如果 Banana不是继承 Apple，就会报错 List 和 List\u0026lt;Object\u0026gt; 是有区别的，后者明确告诉该容器接受所有任意类型对象。\n必须在类文字（class literal）中使用原生态类型\nprivate static final Logger log = LoggerFactory.getLogger(User.class); 消除非受检的警告 /uncheck/\n⬆️尽量不要编译后出现这个（其实就是@SuppreWarnings(\u0026quot;unchecked\u0026quot;)），除非可以证明引起警告的代码是类型安全的，用 /uncheck/ 或者 @SuppreWarnings(\u0026quot;unchecked\u0026quot;)来禁止警告。尽可能在小的范围使用这个注解，像 synchronized 以及 catch Exception 一样，尽可能精准，细粒度去做。这样好调试啊。\n书上讲的 ArrayList.toArray(T[] a)方法，在 JDK1.8 中，源码是把去警告的注解放在方法上的，和他推荐的不一样。当然还是按照作者推荐的，这样让后人更容易懂你写的代码，尽量别写出祖传代码.\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; T[] toArray(T[] a) { if (a.length \u0026lt; size) // Make a new array of a\u0026#39;s runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length \u0026gt; size) a[size] = null; return a; } 列表优先于数组 除非写游戏类的，用二维数组表示坐标什么的，科学计算用基础类型。\n// 编译不报错，运行报错 Object[] o = new Long[1]; objectArray[0] = \u0026#34;str\u0026#34;; // 编译报错 List\u0026lt;Object\u0026gt; o2 = new ArrayList\u0026lt;Long\u0026gt;(); ol.add(\u0026#34;str\u0026#34;); 范型数组不存在，编译不通过。\n列表帮你做好了动态扩容，类型转换等操作。\n优先考虑范型 // 以前写 BaseDao 这种类时写的反射方法，也是 ORM 框架中会用到的方法。 \u0026lt;T\u0026gt; T query(Class\u0026lt;T\u0026gt; clazz); 优先考虑范型方法 ⬆️ 像上面这种\n善用通配符，E Element，T type表示具体的类型，K V key Value，？ 不确定什么类型\nJDK1.7引入@SafeVarargs 放在方法上，消除使用范型方法警告\n利用有限制通配符来提升 API 的灵活性 List\u0026lt;T extends Record\u0026gt; list; public boolean isContainAnnotation(Object target,Class\u0026lt;? extends Annotation\u0026gt; clazz){ return null == target.getClass().getAnnotation(clazz); } 谨慎使用并用范型和可变参数 《阿里巴巴 Java 开发规范》中也明确指出了，少用甚至不用可变参数，这是个语法糖。\npublic void foo(List\u0026lt;String\u0026gt;... stringLists)； // 这样一起用，就要谨慎了。不安全，当遇到不同类型转换时，编译器不能把你的错误给指出来。 如果真的方法是安全的，对于每一个带有范型可变参数或者参数化类型的方法，都要用@SafeVarargs进行注解.\n优先考虑类型安全的异构容器 以前写的手动分页的类。,List\u0026lt;E\u0026gt; Set\u0026lt;E\u0026gt; Map\u0026lt;K,V\u0026gt;\npublic class Page\u0026lt;E\u0026gt;{ private int index; private int size； private E[] list; //.... getter setter } Enums and Annotations 用 enum 代替 int 常量 Java 的枚举本质上是 int 值。《深入理解 Java 虚拟机》介绍了枚举类其实是隐式继承了 java.lang.Enum这个类，所以枚举不能继承其他类，只能实现接口。\nJava enums can extend java.lang.Enum class implicitly（隐含的）, so enum types cannot extend another class.\npublic class SomeThingStatus{ public static final int Y = 1; public static final int N = 0; } // 用枚举替代 public enum Status{ Y,N } 根据枚举所作用的范围，尽可能贴合实际使用范围来定义枚举类该在类私有/包级私有/顶层类（top-level class）/顶层类的成员类。\n策略模式枚举\ntrategy enum\npublic enum PayrollDay{ MONDAY,TUESEDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY(PayType.WEEKEND),SUNDAY(PayType.WEEKEND); private final PayType payType; PayrollDay(PayType paytype){this.payType = payType;} PayrollDay(){return this(PayType.WEEKDAY);} int pay (int minutesWorked, int payRate){ return payType.pay(minutesWorked, payRate); } private enum PayType{ WEEKDAY{ int overtimePay(int minsWorked, int payRate){ return minisWorked \u0026lt;= MINIS_PER_SHIT ? 0 : (minsWorked - NINS_PER_SHIFT) * payRate / 2; } }, WEEKEND{ int overtimePay(int minsWorked, int payRate){ return minsWorked * payRate / 2; } } abstract int overtimePay(int mins,int payRate); private static final int MINIS_PER_SHIFT = 8 * 60; int pay(int minsWorked, int payRate){ int basePay = minsWorked * payRate; return basePay + overtimePay(minsWorked, payRate); } } } 每当需要一组固定的常量，并且在编译时就知道其成员的时候，就应该使用枚举。如菜单的选项、操作代码以及命令行标记等。\n策略模式 如 org.springframework.core.io.Resource\n**UrlResource：**访问网络资源的实现类。 **ClassPathResource：**访问类加载路径里资源的实现类。 **FileSystemResource：**访问文件系统里资源的实现类。 **ServletContextResource：**访问相对于 ServletContext 路径里的资源的实现类. **InputStreamResource：**访问输入流资源的实现类。 **ByteArrayResource：**访问字节数组资源的实现类。 责任链模式，例如 Handler Interceptor，Filter 。如下所示：\nDispatcherServlet 中的 service 方法，经过一些校验和一些参数设置，最终会调用这个方法，如果你懂了这个方法，Spring MVC 一般的情况都能 Hold 住了。\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try { try { ModelAndView mv = null; Object dispatchException = null; try { processedRequest = this.checkMultipart(request); multipartRequestParsed = processedRequest != request; // HandlerMapping 会在系统启动的时候，把所有的 RequestMapping 相关的方法封装成 MethodHadler，注入进来 // 先从 HandlerMapping 中获取对应的 Handler mappedHandler = this.getHandler(processedRequest); if (mappedHandler == null) { this.noHandlerFound(processedRequest, response); return; } HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler()); String method = request.getMethod(); boolean isGet = \u0026#34;GET\u0026#34;.equals(method); // 做一些优化，304 方面的。看文件没有没改动过，没有就直接返回请求。 if (isGet || \u0026#34;HEAD\u0026#34;.equals(method)) { long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) \u0026amp;\u0026amp; isGet) { return; } } // mapperHandler，执行 preHandle 方法。对应 Interceptor preHandle 的方法 if (!mappedHandler.applyPreHandle(processedRequest, response)) { return; } mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) { return; } this.applyDefaultViewName(processedRequest, mv); // 对应 Intercaptor 的 postHandler 方法。 mappedHandler.applyPostHandle(processedRequest, response, mv); } catch (Exception var20) { dispatchException = var20; } catch (Throwable var21) { dispatchException = new NestedServletException(\u0026#34;Handler dispatch failed\u0026#34;, var21); } this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException); } catch (Exception var22) { this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22); } catch (Throwable var23) { this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\u0026#34;Handler processing failed\u0026#34;, var23)); } } finally { if (asyncManager.isConcurrentHandlingStarted()) { if (mappedHandler != null) { mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); } } else if (multipartRequestParsed) { this.cleanupMultipart(processedRequest); } } } 用实例域代替序数（表示次序的数目） 实例域 ONE(1),TWO(2)\n用 EnumSet 代替位域 让你用 OR 位运算将几个常量合并到一个集合中，称作位域（bit field）\nSet set = EnumSet.of(ONE,TWO); 用 EnumMap 代替序数索引 麻烦，平时用不到\n用接口模拟可扩展的枚举 public interface Foo{ void bar(String operation); } public enum SubFoo implements Foo{ A(\u0026#34;a\u0026#34;){ @Override public void bar(String operation){ System.out.println(\u0026#34;a\u0026#34;+operation); } }, B(\u0026#34;b\u0026#34;){ @Override public void bar(String operation){ System.out.println(\u0026#34;b\u0026#34;+operation); } }; private String s; SubFoo(String s){ this.s = s; } } 注解优先于命名模式 @Transactional(rollbackFor = Exception.class) public boolean updateUser(User user){ return userRepository.updateUser(user); } @ExceptionHandler(BindException.class) public ApiReturnObject defaultExceptionHandler(BindException bindException) { //处理返回的错误信息 List\u0026lt;ObjectError\u0026gt; errors = bindException.getBindingResult().getAllErrors(); if(errors.size()\u0026gt;0){ ObjectError objectError = errors.get(0); ResultCode resultCode = ResultCode.FAILURE.setMessage(objectError.getDefaultMessage()); return ApiReturnUtil.failure(resultCode); } return ApiReturnUtil.failure(ResultCode.SYSTEM_EXCEPTION); } 坚持使用 @Override 注解 保证写的代码，在编译时能检查得出来到底有没有重写 父类/接口 的方法。\n用标记接口定义类型 Spring 中的所有事件，默认继承 EventObject 这个也算是“接口”，一个不成文的规定。\n/** * 在使用 ObjectOutputstream 时，如果没有实现 Serializable 接口会报错，仅仅是个标记接口 * 在 writeObject0(Object obj, boolean unshared)中，显示的标注了，非 instance of Serializable 实现，将会抛出异常 */ public class UserEntity implements Serializable{ private int id; // 防止被序列化，当然实现了某个接口，还是设置一下，还是会被序列化 private transient BigDecimal salary; //... } // 标记注解 @Service @Repository @Compment Lambdas and Streams Lambda 优先于匿名类 接口只有一个待实现方法时，可以转换成 Lambda 写法。如下\npublic interface SayHelloInterface{ String sayHello(); } public static void main(Stirng[] args){ SayHelloInterface hello = () -\u0026gt; \u0026#34;hello\u0026#34;; } 还有 Comparable\u0026lt;T\u0026gt; 就是很好用 Lambda 写法的例子，而不是用匿名类去写。\n如果 Lambda 没有名称和文档，并且有很多行，那就不要用。\n方法引用优先于 Lambda System.out::println Integer::parseInt 方法引用详情见 《Java 8 实战》\n坚持使用标准的函数接口 接口 函数签名 范例 UnaryOperator T apply(T t) String::toLowerCase BinaryOperator T apply(T t1,T t2) BigInteger::add Predicate boolean test(T t) Collection::isEmpty Function\u0026lt;T,R\u0026gt; R apply(T t) Arrays::asList Supplier T get() Instant::now Consumer void accept(T t) System.out::println,Iterable::forEach default void forEach(Consumer\u0026lt;? super T\u0026gt; action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } // 上面的 Supplier 其实是下面的更简化版。 Supplier\u0026lt;Instant\u0026gt; supplier = () -\u0026gt; (Instant.now()); @FunctionalInterface\n这个注解有三个目的，\n告诉这个类及其文档的读者，这个接口是针对 Lambda 设计的。 这个接口不会进行编译，除非它只有一个抽象方法 避免后续维护人员不小心给该接口添加抽象方法 必须使用这个注解对自己编写的函数接口进行标注。\n谨慎使用 Stream 不建议使用 Stream 来进行 SQL 查询之类的操作。\n过度地使用函数式编程，会导致代码可读性变差，强调不要滥用\nMethods 检查参数的有效性 // 方法尽量是个动词，方法是行为/动作 public void validate(String str,Collection collection,Object obj){ if(StringUtils.isEmpty(str)){ throw new RuntimeException(); } // 这里是 apache common 包下的工具类，hutool 也有类似的类 if(CollectionUtils.isEmpty(collection)){ throw new RuntimeException(); } Objects.requireNonNull(obj,\u0026#34;obj is null\u0026#34;); // 其他操作.... } private void a(String str){ // 在违背导出的方法，使用断言，确保什么时候能够调用这个方法 assert str.length = 1; } 必要时进行保护性拷贝 对于参数类型可以被不可信任方子类化的参数，请不要使用 clone 方法进行保护性拷贝。\n谨慎设计方法签名 代码整洁之道\n对于参数类型，优先使用接口而不是具体实现类。\npublic interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor { /** * Modify the application context\u0026#39;s internal bean definition registry after its * standard initialization. All regular bean definitions will have been loaded, * but no beans will have been instantiated yet. This allows for adding further * bean definitions before the next post-processing phase kicks in. * @param registry the bean definition registry used by the application context * @throws org.springframework.beans.BeansException in case of errors */ void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException; //BeanDefinitionRegistry 常用实现为 DefaultListableBeanFactory，也有其他 ApplicationContext 实现 } boolean 参数，优先使用两个元素的枚举类型。\n慎用重载 不要在重载方法中使用范型，或者继承关系类型。如\ngetAll(List\u0026lt;?\u0026gt; list); getAll(Collection\u0026lt;?\u0026gt; collection); 需要调用哪个重载方法是在编译时作出决定的。\n对于重载方法的选择是静态的，而对于被覆盖的方法的选择则是动态的。\n慎用可变参数 可变参数其实是个语法糖\n每次调用可变参数方法都会导致一次数组分配和初始化。有性能问题。可以适当的利用重载方法，替代可变参数方法。当然方法参数超过3个，就一起用可变参数，具体方法参数内容可以参考《代码整洁之道》。\n最理想的参数数量是零，其次是一，再次是二，尽量避免三。有足够特殊的理由才能用三个以上参数（阿里巴巴Java开发手册：相同参数类型，相同业务含义，才可以使用 Java 的可变参数，可变参数放在最后，尽量不用可变参数，避免使用 Object）。\n很久以前记的《代码整洁之道》的笔记\n返回零长度的数组或者集合，而不是 null public byte[] getDigestKeyGen(String content){ byte[] bytes = {}; try{ // doSomething bytes = xxxx; }catch(Exception e){ } return bytes; } 谨慎返回 optional // DefaultListableBeanFactory /** * Create an {@link Optional} wrapper for the specified dependency. */ private Optional\u0026lt;?\u0026gt; createOptionalDependency( DependencyDescriptor descriptor, @Nullable String beanName, final Object... args) { DependencyDescriptor descriptorToUse = new NestedDependencyDescriptor(descriptor) { @Override public boolean isRequired() { return false; } @Override public Object resolveCandidate(String beanName, Class\u0026lt;?\u0026gt; requiredType, BeanFactory beanFactory) { return (!ObjectUtils.isEmpty(args) ? beanFactory.getBean(beanName, args) : super.resolveCandidate(beanName, requiredType, beanFactory)); } }; Object result = doResolveDependency(descriptorToUse, beanName, null, null); return (result instanceof Optional ? (Optional\u0026lt;?\u0026gt;) result : Optional.ofNullable(result)); } // Optional // 这个 value 就是该对象的引用 private final T value; // 这里是空的兜底的策略时，返回的 Optional null 对象 private static final Optional\u0026lt;?\u0026gt; EMPTY = new Optional\u0026lt;\u0026gt;(); 常用的方法 Optional.ofNullable(result)，返回一个 Optional(null)或者 Optional 的包装对象的。\nOptional\u0026lt;T\u0026gt; 类代表的是一个不可变的容器，它可以存放单个非 null 的 T 引用，或者什么内容都没有。\n永远不要通过返回 Optional 的方法返回 null，因为它彻底违背了 optional（可选的） 的本意。\n容器类型含集合、映射、Stream、数组和 optional，都不应该被包装在 optional 中。\n永远不要返回基本包装类型的 optional 。已经提供了 OptionalInt，OptionalDouble，OptionalLong 等。\n永远都不适合用 optional 作为键、值，或者集合或做数组中的元素。\n尽量不要将 Optional 用作返回值以外的任何其他用途。\n用了 Optional，你就必须在调用方，做相应的判断，因为如果使用 Optional.ofNullable(obj)它有最差返回 private static final Optional\u0026lt;?\u0026gt; EMPTY = new Optional\u0026lt;\u0026gt;();\n为所有到处的 API 元素编写文档注释 《代码整洁之道》—— 最好的注释是方法本身（见名知意、简短 不超过 50 行、方法参数最好不要超过 3 个、少用可变参数）。\n当然这是一种比较极端的说法，好的 API 应该至少写出 what why how，这个方法是什么，为什么这么实现，以及如何使用。\n// interface BeanFactory\t/** * Return an instance, which may be shared or independent, of the specified bean. * \u0026lt;p\u0026gt;Behaves the same as {@link #getBean(String)}, but provides a measure of type * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the * required type. This means that ClassCastException can\u0026#39;t be thrown on casting * the result correctly, as can happen with {@link #getBean(String)}. * \u0026lt;p\u0026gt;Translates aliases back to the corresponding canonical bean name. * Will ask the parent factory if the bean cannot be found in this factory instance. * @param name the name of the bean to retrieve * @param requiredType type the bean must match; can be an interface or superclass * @return an instance of the bean * @throws NoSuchBeanDefinitionException if there is no such bean definition * @throws BeanNotOfRequiredTypeException if the bean is not of the required type * @throws BeansException if the bean could not be created */ \u0026lt;T\u0026gt; T getBean(String name, Class\u0026lt;T\u0026gt; requiredType) throws BeansException; 使用 {@literal}忽略尖括号等需要转义的内容。如 {@literal r \u0026lt; 1}\nGeneral Programing 将局部变量的作用域最小化 只在需要用到变量的前一步，去声明变量。\n下面是AutowiredAnnotationBeanPostProcessor覆盖SmartInstantiationAwareBeanPostProcessor的方法。\n具体执行步骤 AbstractAutowireCapaleBeanFactory#doCreateBean -\u0026gt; AbstractAutowireCapaleBeanFactory#createBeanInstance -\u0026gt; AbstractAutowireCapaleBeanFactory#determineConstructorsFromBeanPostProcessors -\u0026gt; SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors -\u0026gt;AutowiredAnnotationBeanPostProcessor#determineCandidateConstructors\n在属性填充之前，创建 beanWrapper。\n@Override @Nullable public Constructor\u0026lt;?\u0026gt;[] determineCandidateConstructors(Class\u0026lt;?\u0026gt; beanClass, final String beanName) throws BeanCreationException { // Let\u0026#39;s check for lookup methods here.. if (!this.lookupMethodsChecked.contains(beanName)) { try { ReflectionUtils.doWithMethods(beanClass, method -\u0026gt; { Lookup lookup = method.getAnnotation(Lookup.class); if (lookup != null) { Assert.state(this.beanFactory != null, \u0026#34;No BeanFactory available\u0026#34;); // 检查 Lookup 方法，去覆盖原来的方法 LookupOverride override = new LookupOverride(method, lookup.value()); try { RootBeanDefinition mbd = (RootBeanDefinition) this.beanFactory.getMergedBeanDefinition(beanName); mbd.getMethodOverrides().addOverride(override); } catch (NoSuchBeanDefinitionException ex) { throw new BeanCreationException(beanName, \u0026#34;Cannot apply @Lookup to beans without corresponding bean definition\u0026#34;); } } }); } catch (IllegalStateException ex) { throw new BeanCreationException(beanName, \u0026#34;Lookup method resolution failed\u0026#34;, ex); } this.lookupMethodsChecked.add(beanName); } // 省略后面代码 } for 循环优先于 while 循环\n优先使用 foreach 而不是 for 简洁、灵活、预防出错（当然在里面删除元素又进行遍历，是不行的）\n不要在 foreach（增强 for 循环） 里面进行删除集合内部元素的操作。如果必要，请使用迭代器。\n什么时候不该用 foreach\n解构过滤：就是上面的情况，使用 Collection#removeIf。\n转换：就是要明确知道要替换的元素在哪几位的时候，予以替换的时候。\n平行迭代：多层迭代，例如排序算法\n正确的在遍历时删除元素\npublic void filter(List\u0026lt;User\u0026gt; users){ Iterator\u0026lt;User\u0026gt; it = users.iterator(); while(it.hasNext()){ User user = it.next(); if(user != null \u0026amp;\u0026amp; \u0026#34;zhangSan\u0026#34;.equals(user.name)){ it.remove(); } } } 了解和使用类库 从 Java7 开始该使用 ThreadLocalRandom 而不是 Random\n熟悉 java.lang、java.util、java.io及其子包中的内容。子包包括但不限于 java.util.concurrent，java.util.regex。\n如果需要精确的答案，避免使用 float 和 double float、double 适合科学计算。\n使用 BigDecimal、Joda Money 进行金额计算。\nJavaScript\n// js 0.1 + 0.2 != 0.3 // true //0.1 +0.2===0.30000000000000004 Java\ndouble a = 0.1; double b = 0.3; System.out.println(b-a == 0.2);// false double d = b-a; System.out.println(d);// 0.19999999999999998 基本类型优先于装箱基本类型 基本类型比包装类型更省内存，性能更高。当然，业务对性能要求不是非常高的，可以用装箱的类型。\n自动拆装箱会带来一些隐藏的问题，在《阿里巴巴 Java 开发手册》中介绍，统一使用装箱类型。\n如果基本类型和装箱基本类型混合使用，装箱基本类型则会自动拆箱。\n自动拆装箱本质上是为了简化开发，添加此类语法糖。\n// 编译时优化，自动装箱 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(2); // 实际上是 list.add(Integer.valueOf(1)); list.add(1); // 编译时优化，自动拆箱 Integer a = 129; a = 1 * a; // 自动装箱时，会在 IntegerCache 中查找是否有缓存中的元素，有即返回，这个最大值可以设置，最小值为 -128，low=-128， // String integerCacheHighPropValue = // sun.misc.VM.getSavedProperty(\u0026#34;java.lang.Integer.IntegerCache.high\u0026#34;); public static Integer valueOf(int i) { if (i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 如果其他类型更合适，尽量避免使用字符串 不适合代替枚举类型的值、聚合类型、能力表（capabilities）。\nThreadLocal 如果用 String 作为 Key，那将是全局共享的，不妥。\n// 聚合类型 String compoundKey = className + \u0026#34;#\u0026#34; + i.next(); // Spring 中也是这么做的。 String methodName = className + \u0026#34;#\u0026#34;+ methodName; 1kb = 1024 byte = 1024 * 8 bit\n数据类型 名称 长度 备注 byte 字节型 8bit 表示数据范围：-128~127 short 短整型 16bit char 字符型 16bit int 整型 32bit long 长整型 8 byte float 单精度浮点型 4 byte 精度：7-8位 double 双精度浮点型 8 byte boolean 布尔型 true/false 实际用 byte 存储，0 为 false，1 为 true 选择合适的类型，能使得占用内存更小。\n当然，为防止伪共享，提高 CPU 执行效率，如果使用 volatile 关键字禁止 CPU 缓存，如果需要提升代码性能，需要额外填充其他对象。\n如果一个对象包含线程局部变量且尺寸小于 64byte，就有可能发生伪共享。在Java7之前，一般通过对象填充的方式来避免伪共享问题：\n// java7 以前 private static final class PaddedVolatileLong { private volatile long v; private long p1, p2, p3, p4, p5, p6; } // java 8 加上注解，加上启动参数，自动填充。 @sun.misc.Contended public class ForkJoinPool extends AbstractExecutorService { } 需要给JVM加上启动项参数：\n-XX:-RestrictContended\nHotspot虚拟机文档 “oops/oop.hp”有对Markword字段的定义\n64 bits: -------- unused:25 hash:31 --\u0026gt;| unused:1 age:4 biased_lock:1 lock:2 (normal object) JavaThread*:54 epoch:2 unused:1 age:4 biased_lock:1 lock:2 (biased object) PromotedObject*:61 ---------------------\u0026gt;| promo_bits:3 -----\u0026gt;| (CMS promoted object) size:64 -----------------------------------------------------\u0026gt;| (CMS free block) class Fruit extends Object { private int size; } Object object = new Object(); Fruit fruit = new Fruit(); Object 对象，Markword 8 个字节，kclass 4 个字节， 加起来 12 个字节，加上 4 个字节的对齐填充，占用的空间是 16 个字节。 Fruit 对象， Markword 8 个字节，kclass 4 个字节，还有个 size 成员变量，int类型占 4 个字节，加起来是 16 个字节，不需要对齐填充 缓存行非64字节宽的处理器。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽。\n共享变量不会被频繁地写。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。\n了解字符串连接的性能 避免在循环使用 + 拼接字符串\nfor(int i = 0;i \u0026lt; 1000;i++){ String str = \u0026#34;1\u0026#34; + strs[i]; // 实际代码为 /** * StringBuilder sb = new StringBuilder(); *\tsb.append(str); * sb.append(strs[i]); * sb.toString(); */ } 通过接口引用对象 List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 更加灵活。\n样例 实际碰到的。\n@GetMapping public ArrayList\u0026lt;Object\u0026gt; getList(){ ArrayList\u0026lt;Object\u0026gt; list = aService.getList(); return list; } 当我需要按照构造器传入的 size 来截取 List，因为我客户端需要根据 pageSize 来获取指定 size 或小于该大小的数据。\n@GetMapping public ArrayList\u0026lt;Object\u0026gt; getList(){ ArrayList\u0026lt;Object\u0026gt; list = aService.getList(); SubList subList = list.subList(0,10); return new ArrayList(subList); } 我只是需要个 JSON 数组，我并不需要 ArrayList 的特殊的方法，这样就是严重耦合的代码。\n这个改成下面的，是不是更好点？\n@GetMapping public List\u0026lt;Object\u0026gt; getList(){ List\u0026lt;Object\u0026gt; list = aService.getList(); return list.subList(0,10); } Spring 中大量使用接口来引用，而非具体实现类。代码尽量使用依赖注入接口类型，实现实际类与调用类解耦。\n如果没有合适的接口，就用类层次结构中提供了必要功能的最小的具体类来引用对象。\n即如果要使用ArrayList.trimToSize()就声明为 ArrayList 引用，这是一种编程习惯，只用你用到的，只提供你想给外部调用的，不是全部，是部分（部分可以是全部）。\nSpring 中是采用的流水线的思维方式，将各个阶段，抽象了出来，每个阶段都有其对应的接口抽象。\n每个阶段的抽象。\nBeanFactory Resource BeanDefinition BeanWrapper 每个阶段中的前置后置处理抽象\nBeanFactoryPostProcessor（BeanFactory 启动的时候，可以在 AbstractApplicationContext#invokeBeanFactoryPostProcessors 中找到答案，打断点，自己慢慢看，就知道 @Component 是在这里的哪一步解析的了，启动一个随便什么的 Spring Boot 项目，即可查看具体内容） BeanDefinitionRegistryPostProcessor（BeanDefnition 注册的时候） MergedBeanDefinitionPostProcessor（GenericBeanDefinition 和其他 BeanDefinition 有个合并的过程，合并成 RooBeanDefinition，如果你看过小马哥的讲解的，这个其实是 XML 配置里面会出现的情况，一个 \u0026lt;bean/\u0026gt; 就是一个 RootBeanDefinition，当然，它会先包装成 GenericBeanDefinition 再进行合并） SmartInstantiationAwareBeanPostProcessor（一般带 Smart 的，都要先一步执行，例如 SmartInitializingSingleton，会在单例对象预实例化阶执行，SmartInstantiationAwareBeanPostProcessor 的实现的抽象类 AbstractAdvisorAutoProxyCreator 和 AOP 相关，就在这一步，对要拦截的 Bean 进行拦截，然后代理，这里会有 Pattern 正则来匹配的过程，@Transaction 也是在这一步做的） InstantiationAwareBeanPostProcessor DestructionAwareBeanPostProcessor BeanPostProcessor（上面所有 BeanPostProcessor 的父类，就是最卑微的，最后执行） 接口优先于反射机制 详情见\nSpring BeanProcessor\nInitializingBean 和 DisposableBean，它们也可以用 @PostConstruct 和 @PreDestroy 代替，当然，两者一起也是可以的，具体执行顺序。\n@PostConstruct\nInitializingBean\n自定义初始化方法\n@PreDestroy 标注方法\n实现 DisposableBean 接口的 destroy() 方法\n自定义销毁方法 (destroy-mehod)\nSpring MVC Interceptor\n给定了模版类，调用模版类的模版方法。\n如果使用反射机制\n损失了编译时类型检查的优势 执行反射访问所需要的代码非常笨拙和冗长 性能损失 谨慎使用本地方法 native method 是与平台相关的，破坏了 Java 的移植性，如非必须情况，要避免使用本地方法。\n可能的必要情况\n需要调用 dll 文件 需要真正高性能的高精度算术运算。 谨慎地进行优化 不等同于不要持续重构代码\n遵守普遍接受的命名惯例 包名com.xxxx，域名反写 类名 抽象类，BaseXXXXX，AbstractXXXXXX 变量名 局部变量名，String xxxStr， 方法名 方法名应该是个动词，如 createBean，getBean，表示的是类的行为。 get 是获取单个对象，list 是获取多个对象。 题外话 怪罪于 StringBuilder sb = new StringBuilder(100); 命名为 sb 的人，是真的 SB。本来就是局部变量用于拼接字符串的，没有很大的实际意义。\n有些现代工具（MyBatis）依赖 Beans 命名惯例，setter getter，从数据库中取出值后，赋值需要调用 setter 类型方法。\nException 只针对异常的情况才使用异常 不要将异常作为普通的控制流。\n对可恢复的情况使用受检异常，对编程错误使用运行时异常 // 可恢复情况 try{ Class.forName(\u0026#34;com.xxx.Driver\u0026#34;); }catch(ClassNotFoundException e){ } // 编程错误使用 RuntimeException int foo = 1/0; // Error 最好由 JVM 抛出，不适合自定义 Error 避免不必要地使用受检异常 可以适当将 try catch 块重构为 if else 块。\n优先使用标准的异常 类越精简，加载类的速度越快，优先使用专家级的定义的异常。加粗表示更为高频使用的，如\nIndexOfBoundsException\nNullPointException\nIllegalArgumentException\nIllegalStateException*\nIllegalAccessException\nConcurrentModificationException\nUnsupportedOperationException\n抛出与抽象对应的异常 更高层的实现应该捕获底层的异常，同时抛出可以按照高层抽象进行解释的异常。\n如果在 MyBatis 中，写 resultType 写成不存在的类，会先抛出 ClassNotFoundException，然后层层抛出，到 Spring 创建 Bean 的步骤中。最终由 Servlet 容器捕获，然后停止启动项目。可以自己手动试试。\n// AbstractAutowireCapableBeanFactory protected BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd, @Nullable Constructor\u0026lt;?\u0026gt;[] ctors, @Nullable Object[] explicitArgs) { return (new ConstructorResolver(this)).autowireConstructor(beanName, mbd, ctors, explicitArgs); } // org.springframework.beans.factory.support.ConstructorResolver // ConstructorResolver.ArgumentsHolder createArgumentArray 方法里面 try { Object autowiredArgument = resolveAutowiredArgument( methodParam, beanName, autowiredBeanNames, converter, fallback); args.rawArguments[paramIndex] = autowiredArgument; args.arguments[paramIndex] = autowiredArgument; args.preparedArguments[paramIndex] = new AutowiredArgumentMarker(); args.resolveNecessary = true; } catch (BeansException ex) { throw new UnsatisfiedDependencyException( mbd.getResourceDescription(), beanName, new InjectionPoint(methodParam), ex); } 异常链（exception chaining），如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。Spring 就是这样。\n实际 WEB 开发也是不要将异常捕获，尽量将异常向上抛出，最终由 **容器/框架 **进行 捕获/抛出。编写自定义含 @ExceptionHandler的类，进行捕获异常。\n如下：\n@RestControllerAdvice public class GlobalExceptionHandler { /** * 表单验证时异常返回信息 * * @param bindException 绑定异常 * @return 带异常的 ResponseEntiy * @author 杨逸林 * @date 2019-07-29 22:27 */ @ExceptionHandler(BindException.class) public ResponseEntity\u0026lt;?\u0026gt; defaultExceptionHandler(BindException bindException) { //处理返回的错误信息 List\u0026lt;ObjectError\u0026gt; errors = bindException.getBindingResult().getAllErrors(); if (!CollectionUtils.isEmpty(errors)) { ObjectError objectError = errors.get(0); ResultCode resultCode = ResultCode.FAILURE.setMessage(objectError.getDefaultMessage()); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(resultCode); } return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); } } 注意⚠️\n这里必须使用 ResponseEntity，不要自定义的什么乱七八糟的返回，没有必要再套一层，HTTP 早就想到了，不要像下面这样返回！！多此一举，如果这么做，多半不了解 HTTP 的一些细节内容，前人早就帮你想好了。\n{ \u0026#34;code\u0026#34; : \u0026#34;404\u0026#34;, \u0026#34;message\u0026#34; : \u0026#34;can\u0026#39;t find any matches response\u0026#34;, \u0026#34;data\u0026#34; : \u0026#34;404\u0026#34; } 这样做，只会徒增前端的负担。\n每个方法抛出的所有异常都要建立文档 永远不要声明一个公有方法直接 “throws Exception”。无法让调用者判断该如何解决并捕获该异常。\n有个例外，就是 main 方法，它可以被安全地声明抛出 Exception，因为它只通过虚拟机调用。\n还有就是 Spring Boot 的 CommandRunner，ApplicationRunner 以及 Spring 的 InitializingBean。注意这里的 @throws 需要你写清楚，像下面那样。如何写，在我的另一个我在公司分享的【代码规范】文章里面有讲解、翻译。\npublic interface InitializingBean { /** * Invoked by the containing {@code BeanFactory} after it has set all bean properties * and satisfied {@link BeanFactoryAware}, {@code ApplicationContextAware} etc. * \u0026lt;p\u0026gt;This method allows the bean instance to perform validation of its overall * configuration and final initialization when all bean properties have been set. * @throws Exception in the event of misconfiguration (such as failure to set an * essential property) or if initialization fails for any other reason */ void afterPropertiesSet() throws Exception; } 在细节消息中包含失败-捕获信息 为了捕获失败，异常的细节信息应该包含“对该异常由贡献”的所有参数和域的值。\n以下是 Spring 启动创建 Bean 时失败，抛出异常的堆栈异常信息。PS：就是上面说的 MyBatis 改了 resultType 的异常。这里就是按层级抛出异常的案例。注意：Spring 是以流水线（Pipeline）的形式来处理的 Bean，看过卓别林的《摩登时代》里面就有他在拧螺丝，是流水线上的一环，也是一个阶段的处理者。流水线是福特提出的，并且作用于福特汽车的生产，极大得提高了生产力。在软件行业同样适用，如果你懂了 Spring 是流水线的处理思想（没什么书上提到流水线和 Spring 的关系），你就懂了大半的 Spring，其他的注解解析，派生等等内容都不难。思想很重要，每个人都需要拥有多个学科的知识，例如达芬奇是画家、科学家、发明家。这个观念在查理·芒格的《穷查理宝典》中反复被提及，值得一看的书籍。\norg.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name \u0026#39;callEvaluationController\u0026#39; defined in file [/IdeaProjects/evaluation/target/classes/cn/luckyray/evaluation/api/CallEvaluationController.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name \u0026#39;userServiceImpl\u0026#39;: Unsatisfied dependency expressed through method \u0026#39;setUserMapper\u0026#39; parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name \u0026#39;userMapper\u0026#39; defined in file [/IdeaProjects/evaluation/target/classes/cn/luckyray/evaluation/dao/main/UserMapper.class]: Cannot resolve reference to bean \u0026#39;mainSqlSessionTemplate\u0026#39; while setting bean property \u0026#39;sqlSessionTemplate\u0026#39;; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name \u0026#39;mainSqlSessionTemplate\u0026#39; defined in class path resource [cn/luckyray/evaluation/config/DataSourceConfig.class]: Unsatisfied dependency expressed through method \u0026#39;sqlSessionTemplate\u0026#39; parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name \u0026#39;mainSqlSessionFactory\u0026#39; defined in class path resource [cn/luckyray/evaluation/config/DataSourceConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.ibatis.session.SqlSessionFactory]: Factory method \u0026#39;sqlSessionFactory\u0026#39; threw exception; nested exception is org.springframework.core.NestedIOException: Failed to parse mapping resource: \u0026#39;file [/IdeaProjects/evaluation/target/classes/mapping/main/UserMapper.xml]\u0026#39;; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is \u0026#39;file [/IdeaProjects/evaluation/target/classes/mapping/main/UserMapper.xml]\u0026#39;. Cause: org.apache.ibatis.builder.BuilderException: Error resolving class. Cause: org.apache.ibatis.type.TypeException: Could not resolve type alias \u0026#39;java1.lang.Integer\u0026#39;. Cause: java.lang.ClassNotFoundException: Cannot find class: java1.lang.Integer // 这其实是一行异常信息，我用换行分离出来 // 层层嵌套，将必要的信息给暴露出来。 不要在细节消息中包含密码、密钥以及类似的信息。输出异常消息日志时，或者正常日志时，一定要对敏感信息（用户名密码，用户名等等信息）进行脱敏操作。\n努力使失败保持原子性 一般而言，失败的方法调用应该使对象保持在被调用之前的状态。\n使用 JDBC 操作数据库进行增/删/改时，出现失败的情况，应该进行事务回滚。\n分布式系统中的 GET 操作即使失败，也要保持幂等性。\n// TODO Spring Cloud 的中就是这么 GET 默认为幂等的，会一直调用，直到你没出错为止。这个就需要提到 HATEOS 以及 RESTful 的一些约定的一些内容。\n不要忽略异常 空的 catch 块会使异常达不到应有的目的。\n如果选择忽略异常，catch 块中应该包含一条注释，说明情况，并将异常变量命名成 ignored\ntry{ }catch(TimeoutException | ExecutionException ignored){ // 这是一条注释 } Concurrency 同步访问共享的可变数据 不要使用 Thread#stop 方法。\n除非读和写操作都被同步，否则无法保证同步能起作用。\n避免线程不安全的条件，可以有，避免共享，没有共享就没有伤害，使用 Synchronized/volatile/Atomic 类保证线程安全。\n避免过度同步 使用 JUC 容器，如CopyOnWriteArrayList。\n// TODO 死锁代码\nexecutor、task、stream 优先于线程 不要用 Executors 创建线程池，里面具体实现有无界队列，Integer.MAX_VALUE 等坑人的定义。无界队列会一直堆积请求，直到OOM，应该使用 ArrayBlockingQueue 这种有界队列。使用 Guava 中 ThreadFactoryBuilder 创建 ThreadFactory，而不是继承原生的（不仅麻烦，而且很多东西其实是重复的，就是为了给线程加个名字和其他一些自定义的内容），也可以用 Spring 的。\nprivate static ThreadFactory namedThreadFactory = new ThreadFactoryBuilder() .setNameFormat(\u0026#34;demo-pool-%d\u0026#34;).build(); // 核心线程数，最大线程数，等待时间，时间单位，线程队列（应该用有界队列 ArrayBlockingQueue），线程工厂（继承 ThreadFactory），系统自带的拒绝策略 4 种 private static ExecutorService pool = new ThreadPoolExecutor(5, 200, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy()); 饱和策略 AbortPolicy：中止策略是默认的饱和策略，该策略将抛出未检查的 RejectedExecutionException 调用者可以捕获这个异常，然后根据需求编写自己的处理代码。 DiscardPolicy：当新提交的任务无法保存到队列中等待执行时，抛弃策略会悄悄抛弃该任务。 CallerRunsPolicy：调用者运行（Caller-Runs）策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛弃异常，而是将某些任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了 execute 的线程中执行该任务。 DiscardOldestPolicy：抛弃最旧的（Discard-Oldest）策略则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。如果工作队列是一个优先队列，那么”抛弃最旧的“策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用。 ForkJoinTask。// TODO 《Java 并发编程的艺术》解释，以及代码。Redis 子线程 Fork 父线程，进行集群同步。\n并发的 Stream 是在 Fork Join 池上编写的。\n并发工具优先于 wait 和 notify Executor FrameWork JUC 容器 ConcurrentHashMap（而不是 Collections.synchronizedMap/HashTable） 同步器 CountDownLatch，Semaphore,CyclicBarrier 和 Exchanger 等 对于间歇式的定时，始终应该优先使用 System.nanoTime 而不是 System.currentTimeMillis\n// TODO Spring 同步机制代码补充\n始终应该使用 wait 循环模式来调用 wait 方法，永远不要在循环之外调用 wait 方法。\n一般情况下，优先使用 notifyAll 方法。// 极客时间《并发编程》代码补充\n线程安全性的文档化 一个类为了可被多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别。\n不可变的（immutable）—— String、Long、BigInteger 无条件的线程安全（unconditionally thread-safe）—— 这个类的实例是可变的，但是这个类有着足够的内部同步。AtomicInteger、ConcurrentHashMap 有条件的线程安全（conditionally thread-safe）—— 除了有些方法为进行安全的并发使用而需要外部同步之外，和无条件的线程安全相同。Collections.synchronized 包装返回的集合。 非线程安全（not thread-safe）—— 类实例是可变的。ArrayList、HashMap 线程对立的（thread-hostile）—— 类不能安全地被多个线程并发使用，即使所有的方法调用都被外部同步包围。// TODO ThreadLocal？ 使用类内部私有锁对象。lock 域应该始终声明为 final。// TODO Spring 中也是这么做的\nprivate final Object lock = new Object(); 慎用延迟初始化 Lazy Initialization 是指延迟到需要域的值时才将它初始化的行为。Spring Boot 中有 @Lazy 标注是否延迟初始化，如果标记了，则将会该 Bean 进行延迟初始化，只有在其他类真正使用时，进行初始化。\n大多数情况下，非延迟初始化优先于延迟初始化。\n如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）\n除非绝对必要，否则就不要这么做。\n如果处于性能的考虑而需要对静态域使用延迟初始化，就使用 Lazy Initiazlization Holder Class 模式\npublic class Singleton{ private Singleton(){} private static class SingletonHolder{ private static final Singleton INSTANCE = new Singleton(); } public static getInstance(){ return SingletonHolder.INSTANCE; } } 如果出于性能的考虑而需要对实例域使用延迟初始化，就使用双重检查模式（Double-Check Idiom）\npublic class Singleton{ private volatile Singleton instance = null; // 构造器检查，防止反射多次创建 private Singleton(){if(instance != null)throw new RuntimeException()}; public static Singleton getInstance(){ if(instance == null){ synchronized(Singleton.class){ if(instance == null){ instance = new Singleton(); } } } return instance; } } Spring 中使用单例注册表（Bean 容器）控制 Bean 的单例。\n有时可能需要延迟初始化一个可以接受重复初始化的实例域。可以使用单重检查模式（Single-Check Idiom）\nprivate volatile FieldType field; private FieldType getField(){ FieldType result = filed; if(result == null){ field = result = computeFieldValue() } return result; } 不要依赖于线程调度器 任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移植的\n如果一个程序不能工作，是因为某些线程无法像其他线程那样获得足够的 CPU 时间片，那么，不要企图调用 Thread.yield 来 “修正” 该程序。\n线程优先级时 Java 平台上最不可移植的特征了。设置了优先级，不代表一定会按优先级执行，而是“看情况”。\nSerialize 其他方法优先于 Java 序列化 如果使用 Java 自带的反序列化，以下层次非常高的结构，会导致系统反序列化时占用大量资源。使用 JSON 代替 Java 中的序列化。\nstatic byte[] bomb(){ Set\u0026lt;Object\u0026gt; root = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;Object\u0026gt; s1 = root; Set\u0026lt;Object\u0026gt; s2 = new HashSet\u0026lt;\u0026gt;(); for(ini i = 0;i \u0026lt; 100; i++){ Set\u0026lt;Object\u0026gt; t1 = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;Object\u0026gt; t2 = new HashSet\u0026lt;\u0026gt;(); t1.add(\u0026#34;foo\u0026#34;); s1.add(t1); s1.add(t2); s2.add(t1); s2.add(t2); s1 = t1; s2 = t2; } return serialize(root); } 谨慎地实现 Serializable 接口 BigInteger、Instant 等值类应该实现 Serializable 接口，大多数的集合类也应该如此。代表活动实体的类，如线程池，一般不应该实现 Seriallizable 接口。\n内部类不该实现 Serializable。\n考虑使用自定义的序列化形式 跨语言的 Socket 通信，是自己实现序列化机制，包括 Redis，是以纯文本格式，换行的方式分隔操作符。\ntransient 表示该字段不能被序列化，当然实现了 // TODO 实现某个接口后，在方法中写明了字段，也是可以序列化的。\n保护性地编写 readObject 方法 当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果哪个域包含了这样的对象引用，必须做保护性拷贝。\n对于实例控制，枚举类型优先于 readObject // TODO 不太理解\n考虑用序列化代理代替序列化实例 使用静态内部类，代理外部类序列化内容，以及反序列化。\n// TODO 代码\nReferences 关于Integer面试的一个问题\nVM系列三:JVM参数设置、分析\nWhat does AggressiveOpts do with my timings?\n科普：为什么 String hashCode 方法选择数字31作为乘子\nhttps://cloud.tencent.com/developer/article/1593982\nhttps://blog.csdn.net/xx326664162/article/details/51743969\n无声的性能杀手-伪共享(FalseSharing)\n重学Java-一个Java对象到底占多少内存\n","permalink":"http://localhost:1313/posts/effective-java-spring/","summary":"\u003cp\u003e\u003ca href=\"https://www.oreilly.com/library/view/effective-java/9780134686097/\"\u003e电子原版目录以及概要\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e请购买实体书籍，支持作者、翻译以及出版社\u003c/p\u003e\n\u003ch1 id=\"creating-and-destroying-objects\"\u003eCreating and Destroying Objects\u003c/h1\u003e\n\u003ch2 id=\"用静态工厂方法代替构造器\"\u003e用静态工厂方法代替构造器\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e Boolean \u003cspan style=\"color:#a6e22e\"\u003evalueOf\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e b){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e b \u003cspan style=\"color:#f92672\"\u003e?\u003c/span\u003e Boolean.\u003cspan style=\"color:#a6e22e\"\u003eTRUE\u003c/span\u003e : Boolean.\u003cspan style=\"color:#a6e22e\"\u003eFALSE\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e静态工厂方法与设计模式中的工厂方法模式不同。并不能直接对应设计模式的工厂方法。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e优势\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e有名字（像这种\u003ccode\u003eBigInteger.probablePrime(int bitLength,Random rnd)\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e不必每次调用他们的时候，都创建一个新对象。像\u003ccode\u003eInteger.MAX_VALUE = 0x7fffffff\u003c/code\u003e（享元\u003ccode\u003eFlyweight\u003c/code\u003e模式）真正的享元模式如下，\u003ccode\u003eInteger\u003c/code\u003e中有个私有静态类，叫\u003ccode\u003eIntergeCache\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e可以返回原返回类型的任何子类型的对象。\u003ccode\u003eJava8\u003c/code\u003e允许接口中含有静态方法，\u003ccode\u003eJava9\u003c/code\u003e允许接口中有私有的静态方法，但是静态域和静态成员变量仍然需要是公有的。\u003c/li\u003e\n\u003cli\u003e所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。\u003c/li\u003e\n\u003cli\u003e方法返回的对象所属的类，在便携包含该静态工厂方法的类时可以不存在。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e Integer \u003cspan style=\"color:#a6e22e\"\u003evalueOf\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (i \u003cspan style=\"color:#f92672\"\u003e\u0026gt;=\u003c/span\u003e IntegerCache.\u003cspan style=\"color:#a6e22e\"\u003elow\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e IntegerCache.\u003cspan style=\"color:#a6e22e\"\u003ehigh\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e IntegerCache.\u003cspan style=\"color:#a6e22e\"\u003ecache\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003ei \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003eIntegerCache.\u003cspan style=\"color:#a6e22e\"\u003elow\u003c/span\u003e)\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Integer(i);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eIntegerCache\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efinal\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e low \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e128;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efinal\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e high;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efinal\u003c/span\u003e Integer cache\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// high value may be configured by property\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e h \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 127;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e/** \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e         * 这里定义了最大值，也就是说这个可以配置\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e         * -XX:AutoBoxCacheMax=NNN，这里的 NNN 表示最大值是多少，只能改最大值，不能改最小值。\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e         * 在设置了-XX:+AggressiveOpts启动参数后，AutoBoxCacheMax的默认值会被修改为20000并且生效。\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e         * 这里的 -XX:+AggressiveOpts 是表示加快编译\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e         * aggressive adj.好争斗的, 挑衅的, 侵略性的\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e         * export JAVA_OPTS=\u0026#34;-Xms2048m -Xmx2048m\u0026#34;。\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e         * 合起来翻译 积极的选择\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e         * - Tired compilers (hoping that it will make it into JDK7)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e         * - Scalar replacement (and I am still hoping that this will remove some of the memory throughput preassure 64-bit brought)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e         * EA and stack allocation\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e         * Code cache\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e         */\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        String integerCacheHighPropValue \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e sun.\u003cspan style=\"color:#a6e22e\"\u003emisc\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eVM\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003egetSavedProperty\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java.lang.Integer.IntegerCache.high\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (integerCacheHighPropValue \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enull\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003etry\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e parseInt(integerCacheHighPropValue);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Math.\u003cspan style=\"color:#a6e22e\"\u003emax\u003c/span\u003e(i, 127);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#75715e\"\u003e// Maximum array size is Integer.MAX_VALUE\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                h \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Math.\u003cspan style=\"color:#a6e22e\"\u003emin\u003c/span\u003e(i, Integer.\u003cspan style=\"color:#a6e22e\"\u003eMAX_VALUE\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003elow) \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e1);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            } \u003cspan style=\"color:#66d9ef\"\u003ecatch\u003c/span\u003e( NumberFormatException nfe) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#75715e\"\u003e// If the property cannot be parsed into an int, ignore it.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        high \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e h;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        cache \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Integer\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003e(high \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e low) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e 1\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e j \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e low;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e k \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e 0; k \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e cache.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e; k\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            cache\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003ek\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Integer(j\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// range [-128, 127] must be interned (JLS7 5.1.7)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eassert\u003c/span\u003e IntegerCache.\u003cspan style=\"color:#a6e22e\"\u003ehigh\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026gt;=\u003c/span\u003e 127;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eIntegerCache\u003c/span\u003e() {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e缺点\u003c/p\u003e","title":"Effective Java(with Spring core)"}]